{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/icp.png","path":"img/icp.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/third-party/ClickShowText.js","path":"js/third-party/ClickShowText.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/third-party/activate-power-mode.js","path":"js/third-party/activate-power-mode.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/third-party/canvas-nest.js","path":"js/third-party/canvas-nest.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/third-party/canvas-ribbon.js","path":"js/third-party/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/third-party/click_heart.js","path":"js/third-party/click_heart.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/third-party/fireworks.js","path":"js/third-party/fireworks.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/third-party/piao.js","path":"js/third-party/piao.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/《计算机专业导论》学习笔记.md","hash":"6c68f0ef6aab146098cc5a38fd31ee5406843630","modified":1600581139806},{"_id":"source/_posts/使用Hexo的butterfly主题搭建一个博客.md","hash":"f6c4a5a4c35cd341490ec4b27619853c7b1612d2","modified":1600183327749},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1598963768303},{"_id":"themes/butterfly/README.md","hash":"390d975914080f8918c9a1517f567f9dbf2161ab","modified":1598963768304},{"_id":"themes/butterfly/README_CN.md","hash":"350cc49af9ec3c1198acb8e86b48d9b32d2b18d6","modified":1598963768304},{"_id":"themes/butterfly/_config.yml","hash":"c9fdf1cdec07c9c7b2eb0138cdf4b02266cc4527","modified":1598963768304},{"_id":"themes/butterfly/package.json","hash":"b61233f1dee300db920042e5a5cbf3d50950cf68","modified":1598963768320},{"_id":"themes/butterfly/.github/stale.yml","hash":"7a131b8aa4936fbcedea3517299e1cdc1bcbcaab","modified":1598963768303},{"_id":"themes/butterfly/languages/default.yml","hash":"36ac8acd75ff9ea7b7eb49a55bdddf3131a5eb75","modified":1598963768304},{"_id":"themes/butterfly/languages/en.yml","hash":"36ac8acd75ff9ea7b7eb49a55bdddf3131a5eb75","modified":1598963768305},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"89041eb3aa2725bcf1330fa7ca42b519c3f7ffa0","modified":1598963768305},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"32390d572c7bf73a030c590b7d07d0c13af254ce","modified":1598963768305},{"_id":"themes/butterfly/layout/404.pug","hash":"2ad503a26792927189051a89dc40b3d6095098f9","modified":1598963768305},{"_id":"themes/butterfly/layout/archive.pug","hash":"2d5bf4b1755f89898c579c18d601be83d2bc8ebd","modified":1598963768305},{"_id":"themes/butterfly/layout/category.pug","hash":"90e56274a7c853f6f30337011f9c9d6d035950dc","modified":1598963768305},{"_id":"themes/butterfly/layout/flink.pug","hash":"ce0292973965e99c5a08336e920f06246927374a","modified":1598963768306},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1598963768319},{"_id":"themes/butterfly/layout/page.pug","hash":"b7c3c24cb030b6d1babb5e777aae029e80ee0c81","modified":1598963768319},{"_id":"themes/butterfly/layout/post.pug","hash":"bf9a832accfadda1f910a107d5a5dfe6eb1544a0","modified":1598963768319},{"_id":"themes/butterfly/layout/tag.pug","hash":"e658aa76a11d1e18ec00131d9cec1a38b3d6a62e","modified":1598963768319},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"b59e702649551e2fa2b25510003b05c00768f37a","modified":1598963768303},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"b41123ce5f0ccfa9e06a68b9f3cb59ba040a049a","modified":1598963768303},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"205a69ba038cf76affcdc1f39d88a8cb8079fc12","modified":1598963768303},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"410f26e9a4d0ec3e7f28bc1ba21d607a38f69e73","modified":1598963768306},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"98cce4e0079cd0888529a73ae3542c5eb8d1df78","modified":1598963768306},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"790729628182d0002752599c0c77f486dedd93fd","modified":1598963768306},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"e1b7aa8ec63ac4cde6f3c452ab695d735a5da02b","modified":1598963768309},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"ef9a7bc996a08f1aa939cdb6df03084b0ea6c9dd","modified":1598963768310},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"125780d4cf015c21a7b530d568a256d90afa3f8a","modified":1598963768311},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"076aba110f3234583670e4978be0e6388268d141","modified":1598963768311},{"_id":"themes/butterfly/scripts/events/404.js","hash":"5f6127ede7d139891208340b5cf5bf9314e4be7d","modified":1598963768320},{"_id":"themes/butterfly/scripts/events/check_hexo.js","hash":"76a0da1f6269acc2979aa6493ce8af17bcfc4e00","modified":1598963768320},{"_id":"themes/butterfly/scripts/events/replace_config.js","hash":"29d338125cd0c27952ef7ea1f36181ba3eed67d5","modified":1598963768320},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"1e1da036fae593be7e2cc502f0a5cbeb2e7881d1","modified":1598963768320},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"1e2ac4d26df7cd18a92f1404329f8eb1c388dc18","modified":1598963768321},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"1e0a0c84542cebbd91d8c2cd51254c382c7340c7","modified":1598963768321},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"d9cdeecfb0098ad9bf4814ea2f95167b637e015d","modified":1598963768321},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"5060ef561013dc036ec569f77521d5dab894db73","modified":1598963768321},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"1b53e1993bea3579accac369e35c815d29ffc541","modified":1598963768321},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"cb3766c32043bf97ac48b6aa89e485b3b1c2a08e","modified":1598963768321},{"_id":"themes/butterfly/scripts/tags/button.js","hash":"54c0c9c6d4d4ca754680cd24d7e204a745a6eec0","modified":1598963768322},{"_id":"themes/butterfly/scripts/tags/gallery.js","hash":"90e9d5f499c791225a257f062886fedec5973b18","modified":1598963768322},{"_id":"themes/butterfly/scripts/tags/hide.js","hash":"a3c3c3feafa544304c1beeb90d25022170a32643","modified":1598963768322},{"_id":"themes/butterfly/scripts/tags/mermaid.js","hash":"358efb534cbdbfa28aa2197dd23f458658d7957a","modified":1598963768322},{"_id":"themes/butterfly/scripts/tags/note.js","hash":"8009d722549f838b35e994c9f88517ded56574a5","modified":1598963768322},{"_id":"themes/butterfly/scripts/tags/tabs.js","hash":"296e17f28d45f85ea638fbc5bc0b6e8e002924aa","modified":1598963768322},{"_id":"themes/butterfly/source/css/index.styl","hash":"9a13b40cf4b79980f49a2578cb2c35c04b7f5618","modified":1598963768331},{"_id":"themes/butterfly/source/css/var.styl","hash":"f487284545741c7878524e4b5943a3dac2966ad4","modified":1598963768331},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1598963768331},{"_id":"themes/butterfly/source/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1598963768332},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1598963768332},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1598963768332},{"_id":"themes/butterfly/source/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1598963768333},{"_id":"themes/butterfly/source/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1598963768332},{"_id":"themes/butterfly/source/js/main.js","hash":"6ee37c114ae8f6d0fca63aa34e332c704e496085","modified":1598963768333},{"_id":"themes/butterfly/source/js/utils.js","hash":"6793fafaf0783b89f2b507c1fe4f45841f3f2568","modified":1598963768336},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"81952d4744af55a9e123c57fd8e0004d345d7352","modified":1598963768336},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"e613797213428031543952fd7ea262225c94013c","modified":1598963768306},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"25fdae675275d2cefe427c6b5c3f73ed72c6bfbf","modified":1598963768306},{"_id":"themes/butterfly/layout/includes/head/aplayer.pug","hash":"eb18647e15acbf0f9faf9c56bc43cecc6c3069b1","modified":1598963768307},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"166f3b0584ef2ddc430cb4b01314056ad687c43d","modified":1598963768307},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7d9b135665743b3e3cbd63ba3365afec68fd8884","modified":1598963768307},{"_id":"themes/butterfly/layout/includes/head/darkmode.pug","hash":"826dbec920ea3440c52480cef9950fc1aaf8c10e","modified":1598963768307},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1598963768307},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d3afe5ac3d3533629eaf0be432bc926920358db8","modified":1598963768307},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"59844b533b1f633e1cad4c7f7d79536429bc3d2c","modified":1598963768308},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1598963768308},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"1ddbd09e1902da7fa4bf7824654f132e41622c42","modified":1598963768308},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"499b85f6d68b9a7cd889a99e081cadb8c65c7354","modified":1598963768308},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"d22d4c98028272dfc6c2e721e469f572a6b62ed3","modified":1598963768308},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"a6eef85736af51d08a794fde00d1a9a8ef566d89","modified":1598963768308},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"9caf4b162c0232be83326a53a11cb1258caf67a8","modified":1598963768308},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"631ec7000fd4d6cfa2de118ee02ad8a42ffb34f5","modified":1598963768309},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"3a605e29a0607c315c0566f2a1c6487b4aa98140","modified":1598963768309},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"dd8e6813976be64e80eba6562b54e74527ab306d","modified":1598963768309},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"2beb27e33e4492fa80e88c37dcb7a3ffd7da9e24","modified":1598963768309},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"8e2ca4a63edc7d80250404b8b95984af9830c883","modified":1598963768310},{"_id":"themes/butterfly/layout/includes/mobile-sidebar/index.pug","hash":"e9eacd936c259d8f10e1becdd6e3ca129ea0e942","modified":1598963768310},{"_id":"themes/butterfly/layout/includes/mobile-sidebar/mobile-menus.pug","hash":"ad710f5951edc42388b5ed0ed0e24888128f3dc4","modified":1598963768310},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"6ec54b77e3a90e148e66e317e5bb6c89624fddca","modified":1598963768310},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"d9b96f24c2439f263a606fd38a5517bd4bb162b7","modified":1598963768311},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"cd702d4843d98e431df6d86d3c868f8e181c9926","modified":1598963768314},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"c7d65a5376b04e385d4b725c018f94ea40d0bf06","modified":1598963768315},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"897e9263c3cbe36177d1e90ecf63660ed14d5158","modified":1598963768315},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"2448b243ded58aa1d5fc22fd115e6d06b636f9fd","modified":1598963768315},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"166870d7acb0d8da8371cb8c973aefe82e8fbcc7","modified":1598963768317},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"44af3c7a67b86f048deacb451dd454b088631374","modified":1598963768317},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"59d1096a1bb04c9559367d54d90186afcc115850","modified":1598963768317},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"7450c5bae8aa422c39504a3574f97ef1709d1779","modified":1598963768317},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"4c848368fcaca7edeabf2d7b2a11ae01dfd21447","modified":1598963768318},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"b4a083b4bb2d16c5606700424e944b7f1a2be313","modified":1598963768318},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"40923d59c452d2a71195ddf1a8e3b840f27ef560","modified":1598963768318},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"46e4fb48f9b638f62a40cd66374002370e26c9eb","modified":1598963768318},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"b68b218472ef668890ab1207b1d9c15a9f2b585a","modified":1598963768318},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"a701dab84ef06177a3baf91f31a9e4cb9a2e967a","modified":1598963768318},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"bf05d5c0c57ce07857f9c4eaf7a66d6dd33852db","modified":1598963768319},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"3ed43ae97f6e7fef6e957bdcd11ceacd12145244","modified":1598963768323},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"ed1a88ccd0ea40231af2ec6f8da6e5329e65553d","modified":1598963768323},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"5f31d8da117ed37ffe9eb52bd25e36cd4e72698d","modified":1598963768323},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3f0b8699f529f0842c3b101006f60cb7933c16ff","modified":1598963768324},{"_id":"themes/butterfly/source/css/_layout/404.styl","hash":"480d64137e91a3e69055a70490a2fc070fe97c74","modified":1598963768325},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"15f621675bd55b3ae9c5337a852e41bd83160f7c","modified":1598963768325},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f27ad7b5d781c98bcac5c12c2d70b69b830e0374","modified":1598963768325},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"65ddad9ea585d697776b26b78542e4ee89789f92","modified":1598963768325},{"_id":"themes/butterfly/source/css/_layout/flink.styl","hash":"3c7a7efbb14d8ce6538f612992aa1a62fd278991","modified":1598963768325},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"473d2a6c11f7ff82b28923ddece95919d136d310","modified":1598963768325},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"3d5cbb4ec00e582109d976aaf7e1142bfeb9235d","modified":1598963768326},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"e07d2ee6b327a82c964546eefa110016b0af27a1","modified":1598963768326},{"_id":"themes/butterfly/source/css/_layout/mobile-sidebar.styl","hash":"12e6349921dfeddf925acf4b7e451eb425e230e1","modified":1598963768326},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"6774e3f57422aaeaa3c73204f0a76cc1424e55bf","modified":1598963768327},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"8f234806ec02ca37138c0d00629efa3428d94e01","modified":1598963768327},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"ba391266cd967fa96109677455dd6701292afd52","modified":1598963768327},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"d6149c50ad33b3feb3da8a9d0b9e6557d1137210","modified":1598963768327},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"a5d1d7f4175ff8c20c765452af70c4c095e422f3","modified":1598963768327},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"e68f19f71ad938ed69e6c94a44aa415a56a726ed","modified":1598963768327},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"a8001e683f027511432ad37cf33b256a2d40a941","modified":1598963768328},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"0eeef9de1d578a06afc1655db4c9ea1b29373976","modified":1598963768328},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"a29754c62c4d85fb5234d8683ba86db2280d28e3","modified":1598963768328},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"190b85de3e686393e45869d12464995f23b304dc","modified":1598963768328},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"2ccaaf3b586a454d9af7c5108345fe1592d8963b","modified":1598963768328},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"78bd5b96d56be29662ef897d2b92f9bf529e9bbd","modified":1598963768329},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"8c7e0a49b46f04b9a31c076100d22210c17ebbc7","modified":1598963768329},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"0a5253276107838ecc4f92b9d3f7604b51a78e15","modified":1598963768329},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"06fb002aa4f889c10215c1ac3a658ff9daf041e4","modified":1598963768329},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"202b01db6ef3cca9e5a173e1a0dadfee8854a849","modified":1598963768329},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"b9cfceaca8767da64d6a67f92cbe43ea68d71b7f","modified":1598963768329},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"0ee4e501da2c56dc43816af0477a0472cbac79f5","modified":1598963768330},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"a5fcce868c93c073ae2f555ace46a78f72c70067","modified":1598963768330},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"aa0728c556af75f5d66ecd44fa207722d474c26d","modified":1598963768330},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"8ab69f23ee331317abccafbc26943cfbae961ecc","modified":1598963768330},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"fb21235ce2547ebf624661914d1a3b7a7ce54ac5","modified":1598963768330},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"8520674768dd0b1837f947892e8402b192a4f9c1","modified":1598963768330},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1598963768331},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"bf195cb3cd2821a0662da67e6b51e9157ce02f1a","modified":1598963768334},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"14f842b15fe61d6e28a8719d52ad29f1deb08085","modified":1598963768334},{"_id":"themes/butterfly/source/js/third-party/ClickShowText.js","hash":"2af6ddbabdd36979cc9c05b117452a1534702c6d","modified":1598963768334},{"_id":"themes/butterfly/source/js/third-party/activate-power-mode.js","hash":"2c4ab494225b7d04eed934efc43a43791e596f4a","modified":1598963768334},{"_id":"themes/butterfly/source/js/third-party/canvas-nest.js","hash":"358ac6a6a99762fc2792d47de6f551595194289b","modified":1598963768335},{"_id":"themes/butterfly/source/js/third-party/canvas-ribbon.js","hash":"c345ea68e37caabe8d8f48af41837ccb86952cd5","modified":1598963768335},{"_id":"themes/butterfly/source/js/third-party/click_heart.js","hash":"7295ee03e9ae40f855d0c494a9b84e76a36ffe20","modified":1598963768335},{"_id":"themes/butterfly/source/js/third-party/fireworks.js","hash":"40349f599fb7ad35066c698443dbc0b6085773dc","modified":1598963768335},{"_id":"themes/butterfly/source/js/third-party/piao.js","hash":"8b05848ab89ea5a1af8ed6bd1237746ff151cb1d","modified":1598963768336},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"f3f6eaecbcf9352342e259f4a5a3ad7160f31fc9","modified":1598963768311},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"b741b5e942481d779a8a1fe94c45154a62a6b748","modified":1598963768311},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"e5af55cdb87d1ffd3d8702bc77097159acf95b54","modified":1598963768312},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"bb467bb22f3d0775b33f9eacbfc086ecb7831e78","modified":1598963768312},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"794ce3911f17d354b7196deb8c36d191afac63fb","modified":1598963768312},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"cd7ab4a776be93eea96a6f6fd0a547977fbe1ea3","modified":1598963768312},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"663a298253eddb5126ca1a6139d69c7097ffb52e","modified":1598963768312},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"89138a65cfd05137a7ba4887e2475cc44776d5fe","modified":1598963768312},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"9b6b7b589ef7a8109d88ba439b2d8baf7286b961","modified":1598963768313},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"35e25b7627c158a25e56b8fb5e47fb4dd751f7e0","modified":1598963768313},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"c71c1c6208190839dc86818087023723a6cda923","modified":1598963768313},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"d9eaf02acde9bd8b61282281cf045161e4d5e77b","modified":1598963768313},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1598963768313},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"1c7e9fe86b7d7ef18cc876dfce19263fd4e73066","modified":1598963768313},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"bcd5191c5c42f2bd7f548ff44a30995eee88e3ef","modified":1598963768313},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"0322d640fd6a91853dec3ad39cc24c9b1291322b","modified":1598963768314},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"60bd18e051a442d5ce25325a55982922ab15be04","modified":1598963768314},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"14e32b6c161369a44a71c22bcb4930bcffd8d58c","modified":1598963768314},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"ecb54cd040fa3648ee84f91988073e336a6ec4b8","modified":1598963768314},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"67d5fc4bd261f26a3cae4cac8c4ae646a95cd622","modified":1598963768315},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"3195be3ed3693ca025cf3b491caf8539458470b6","modified":1598963768315},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"659f2c0798cf4dbc934508de69bdc05348db7690","modified":1598963768315},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/leancloud.pug","hash":"09f0877ac0760f23144356125c40f358cbbbfb5e","modified":1598963768315},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"b3aa6d9d8e96ccad2ac57979dcbce92c7d502fd6","modified":1598963768316},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"ff3727c3ec698ec61a28c55cbc8c8508f0efb0a0","modified":1598963768316},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"7ca2d4866fd29e4d072a9ba55956ae885f012e46","modified":1598963768316},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1598963768316},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"fbac21a6c5924fb2f8d1190fd634105fdbc603d4","modified":1598963768316},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"0622e955f3d2efef457f61d0cec0408376bd180a","modified":1598963768316},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"ee17bb1905b007ce445817efa84e04d7b70467a8","modified":1598963768317},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"ba3bdf02a6c78b15eada95638173a11445dac7ac","modified":1598963768324},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"b10c4bf200f82b9f20c34bfa81bfb4555b730a20","modified":1598963768324},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1598963768324},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"a03038a4ac3b19f2439bc752655d955d13a00365","modified":1598963768324},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"c1747b8641303a1d9472ec94f2bc654885feb270","modified":1598963768324},{"_id":"public/2020/09/03/《计算机专业导论》学习笔记/index.html","hash":"58a236fc18e85ca62560489fa0776d1bd28d4016","modified":1609658189952},{"_id":"public/2020/09/01/使用Hexo的butterfly主题搭建一个博客/index.html","hash":"2d1a915bccd2a36e740c2134188c634ab05f9ef9","modified":1609658189952},{"_id":"public/archives/index.html","hash":"03388e3d3f6c3f7b79c27b521c25837d8e60ad84","modified":1610981905881},{"_id":"public/archives/2020/index.html","hash":"59a7f51801553e3cad1c35718cde8e5ece66e373","modified":1610981905881},{"_id":"public/archives/2020/09/index.html","hash":"93cb2d71635043e9c8577eab6b6d03dd47b6a589","modified":1610981905881},{"_id":"public/index.html","hash":"467a77be600d425a041178a1601e5a748c2756d5","modified":1610981905881},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1599317783660},{"_id":"public/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1599317783660},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1599317783660},{"_id":"public/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1599317783660},{"_id":"public/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1599317783660},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1599317783660},{"_id":"public/css/index.css","hash":"929525f6ee5873f3e633e3cd65c27023ab38d84f","modified":1599317783660},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1599317783660},{"_id":"public/js/utils.js","hash":"0218d720c9f44b70ce17daf4fdbdec31c62a35a4","modified":1599317783660},{"_id":"public/js/search/algolia.js","hash":"99bc7ef172e9af332d652e92c5ec8b9ec1481434","modified":1599317783660},{"_id":"public/js/third-party/ClickShowText.js","hash":"32864aee35b5d739a36702b8d916b17bac52b17e","modified":1599317783660},{"_id":"public/js/third-party/canvas-nest.js","hash":"38cb4f2b025f6354124dadb69fe0e0ce57d35094","modified":1599317783660},{"_id":"public/js/third-party/activate-power-mode.js","hash":"2c4ab494225b7d04eed934efc43a43791e596f4a","modified":1599317783660},{"_id":"public/js/search/local-search.js","hash":"591c1a91601287ab6d21e90bebf697792c785c10","modified":1599317783660},{"_id":"public/js/third-party/canvas-ribbon.js","hash":"1ddf4f6896175e77518f0fbd45776132b2954fb6","modified":1599317783660},{"_id":"public/js/third-party/click_heart.js","hash":"004ea645ed8c5e354711b5fc0dbfe015e181916b","modified":1599317783660},{"_id":"public/js/third-party/fireworks.js","hash":"a048478f020a5a5b4781dd7b4946e9bfe30d7560","modified":1599317783660},{"_id":"public/js/third-party/piao.js","hash":"8846788202ee4ad18a814fa492ac39bb7f09548a","modified":1599317783660},{"_id":"public/js/main.js","hash":"250ab73b37b534fcdbeb6cd51a53ceaf14ec7f26","modified":1599317783660},{"_id":"public/js/tw_cn.js","hash":"2eafc44f4a5b24bef836b00dfc4360a84edb8dcc","modified":1599317783660},{"_id":"source/tags/index.md","hash":"efa97e185d53aef529983a2437992f7ae4986652","modified":1600011563826},{"_id":"source/categories/index.md","hash":"a4e59dad5a202deb2ff89a025dfbcc576cfa065d","modified":1600012491874},{"_id":"public/tags/index.html","hash":"f0b8ada214029a6cf23e40ab5ae6c53adfcfe450","modified":1610981905881},{"_id":"public/categories/index.html","hash":"e441ff7a208bce1b5423e0ddb86b94063f639f3a","modified":1610981905881},{"_id":"public/categories/博客/index.html","hash":"08f0f5a915940b0f66fb2d92ac2349a8a6875697","modified":1610981905881},{"_id":"public/categories/计算机组成/index.html","hash":"f8be227ea58aef4116976a63b31492f123ae5eb3","modified":1610981905881},{"_id":"public/tags/计算机基础/index.html","hash":"29409680b1ee71a59c6e31c3c9f9e7ce4a7c54f8","modified":1610981905881},{"_id":"public/tags/Butterfly/index.html","hash":"196dd5e50f069f953045423cefdd4ab08248d9a6","modified":1610981905881},{"_id":"source/_posts/《淘宝技术这十年》.md","hash":"330e6adc3df2257459d553e849217f0151812640","modified":1600541212778},{"_id":"source/_posts/《浪潮之巅》.md","hash":"bea97977c80ecbdf7e22fcbfc1ef3ee7db9fe321","modified":1600354635028},{"_id":"source/_posts/《计算机组成原理》.md","hash":"6c529f424b76498597c477a6fb439a597be82b51","modified":1600589432940},{"_id":"public/2020/09/19/《淘宝技术这十年》/index.html","hash":"bae18fcea4f9781a94a3e16a303378a47b13c2cc","modified":1609658189952},{"_id":"public/2020/09/17/《浪潮之巅》/index.html","hash":"b18a7865376cf1e58c3022b0e1de98fbdb454ab1","modified":1609658189952},{"_id":"public/2020/09/15/《计算机组成原理》/index.html","hash":"ef4f458af8c489e32c965e115b341b940ce288b8","modified":1609658189952},{"_id":"public/categories/技术相关/index.html","hash":"013456ff985a94e1b7b282135840539646d55169","modified":1610981905881},{"_id":"public/tags/技术相关/index.html","hash":"2577892e5b557d40193d3ee13c906d0ce93c3872","modified":1610981905881},{"_id":"source/_posts/《Java数据结构与算法》.md","hash":"9c4f46a27d714c4fbf19aea511fead2c37070d86","modified":1610981860467},{"_id":"public/2020/09/22/《Java数据结构与算法》/index.html","hash":"2ebf3336ae4f069490e44a5b4f7985280ab2e498","modified":1610981905881},{"_id":"public/tags/计算机组成原理/index.html","hash":"e09bbb96204f415cd18dfb581503eac0d7f4e863","modified":1610981905881},{"_id":"public/tags/数据结构与算法/index.html","hash":"4f2f0e302edef3919bfb8988eb3c778518e79af6","modified":1610981905881},{"_id":"public/categories/数据结构与算法/index.html","hash":"eab0415b72987785171153f8221a320342373f16","modified":1610981905881}],"Category":[{"name":"计算机原理","_id":"ckf19kvi200013gv7ginuh8r2"},{"name":"计算机组成","parent":"ckf19kvi200013gv7ginuh8r2","_id":"ckf19kvi400043gv73y4z5lvi"},{"name":"博客","_id":"ckf19kvi600073gv7hf3hdesn"},{"name":"计算机组成","_id":"ckf2nyd4n00000ov7h91g1nu5"},{"name":"技术相关","_id":"ckfa0xret0003c4v74sjfhxhu"},{"name":"数据结构与算法","_id":"ckhirtmbc0000v0v7hxq3fxj1"}],"Data":[],"Page":[{"title":"tags","date":"2020-09-13T15:38:51.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-09-13 23:38:51\ntype: \"tags\"\n---\n","updated":"2020-09-13T15:39:23.826Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckf19kvhw00003gv7fb9yhnne","content":"","site":{"data":{}},"cover":"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/Simple_1366x768_wallpaper_by_PendoX.jpg.pagespeed.ce.QMM6r5k-ZV.jpg","excerpt":"","more":""},{"title":"categories","date":"2020-09-13T15:42:15.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-09-13 23:42:15\ntype: \"categories\"\n---\n","updated":"2020-09-13T15:54:51.874Z","path":"categories/index.html","_id":"ckf19ou1000009wv702b65hyx","comments":1,"layout":"page","content":"","site":{"data":{}},"cover":"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/Simple_1366x768_wallpaper_by_PendoX.jpg.pagespeed.ce.QMM6r5k-ZV.jpg","excerpt":"","more":""}],"Post":[{"title":"《计算机专业导论》学习笔记","date":"2020-09-03T15:16:46.000Z","top_img":"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/jake-davies-adc2oWaP9R4-unsplash%281%29.jpg","cover":"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/jake-davies-adc2oWaP9R4-unsplash%281%29.jpg","_content":"\n![image-20200920132251586](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200920132251586.png)\n\n\n\n[https://www.bilibili.com/video/BV1Qt411J7mo?p=1](https://www.bilibili.com/video/BV1Qt411J7mo?p=1)\n\n## 简介\n\n这是B站上哈尔滨工业大学战德臣老师讲的课程，我的目的是想把计算机专业的重要课程系统的学习一遍，而这个也是B站大佬推荐的系列课程的第一课\n\n\n\n仅就课程内容而言，对我而言还是有些尴尬的。前面讲的一些关于计算机组成的东西，讲的内容都很浅显，我基本都知道，而如果只是知道这么一点的话，肯定是不够的，所以不管怎样，还是要系统的、更具针对性的学习一遍。而后面关于代码和算法的内容，在算法建模之后直接来了个遗传算法，我是不知道如果是一个刚进大学，对计算机不甚了解的学生学完这个的帮助究竟有多大。数据结构和算法都很重要，这也是后面我打算逐步深入、认真学习的内容\n\n\n\n这个课程我没有看完，主要是感觉讲的东西很多不重要，重要的部分又讲的太浅，还是要专门去学习那一部分的内容\n\n\n\n如果你是一个刚入学的学生，或者是一个已经工作的程序员，但是对计算机全无了解，那么你可以考虑看一下这个课程。里面的内容也不用了解的太深，知道个大概就行。有了对计算机专业课程的大致了解之后，再选择性的去深入学习自己感兴趣的内容。说到底，这门课程，终究只是个导论\n\n\n\n**推荐指数**：★☆☆☆☆\n\n------\n\n\n\n## 符号化、计算化和自动化\n\n### 信息如何用0和1来表示\n\n#### 数值信息可以用进位制来表示\n\n\n\n**进位制**：用数码和带有权值的数位来表示有大小关系的数值性信息的表示方法\n\n计算机内部采用的都是二进制的计数法\n\n\n\n------\n\n#### 非数值的信息可以用编码来表示\n\n\n\n**编码**：编码是以若干位数码或符号的不同组合来表示非数值性信息的方法，它是人为的将若干位数码或符号的每一种组合指定一种唯一的含义\n\n\n\n**ASCII码**：\n\nASCII码是英文字母与符号的0，1型编码，是用 7 位 0 和 1 的不同组合来来表示10个数字、26个英文大写字母、26个英文小写字母及一些特殊符号的编码方法，是信息交换的标准编码\n\n\n\n------\n\n#### 汉字的编码\n\n\n\n**汉字内码**：汉字在计算机内部采用汉字内码存储，汉字内码是一两字节且最高位均为 1 的 0、1 型编码\n\n**汉字输入码**：汉字输入码是用键盘上的字母符号编码每一汉字的编码，它使人们通过键入字母符号代替键入汉字\n\n**汉字字形码**：汉字字形码是用 0 和 1 编码无亮点和有亮点像素，形成汉字字形的一种编码。依据字形码通过显示器或打印机是输出汉字\n\n\n\n------\n\n## 冯·诺伊曼计算机的思想与构成\n\n### 什么是冯·诺伊曼计算机\n\n#### 冯·诺伊曼计算机的基本思想\n\n\n\n冯·诺伊曼计算机的的基本思想\n\n* 运算和存储分离\n* 存储程序：指令和数据以同等地位事先存于存储器，可按地址寻访，连续自动执行\n* 五大部件构成：运算器、控制器、存储器、输入设备和输出设备\n* 指令和数据用二进制表示，指令由操作码和地址码组成\n* 以运算器为中心，控制器负责解释指令，运算器负责执行指令\n\n\n\n![1599230961](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1599230961.jpg)\n\n\n\n#### 计算机的基本部件\n\n\n\nCPU、主存储器、I/O设备及总线成为现代计算机的四大核心部件\n\nCPU：中央处理单元，将运算器和控制器集成在一块芯片上，形成微处理器\n\n\n\n------\n\n### 自动存储与存储器\n\n#### 存储器的简介\n\n\n\n存储器单元实际上是时序逻辑电路的一种。按存储器的使用类型可分为只读存储器(ROM)和随机存取存储器(RAM)，两者的功能有较大的区别，因此在描述上也有所不同\n\n\n\n存储器是许多存储单元的集合，按单元号顺序排列。每个单元由若干三进制位构成，以表示存储单元中存放的数值，这种结构和数组的结构非常相似，故在VHDL语言中，通常由数组描述存储器\n\n\n\n------\n\n#### 存储器的实现示例\n\n\n![1599236550](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1599236550.jpg)\n\n\n\n* 当地址线和数据线间连接有二极管时，则存储的是 1，否则，存储的是 0\n* 当地址线和数据线间连接有二极管时，由地址线决定其输出 1 或 0，即当地址线为高电平时，则输出 1，而当地址线为低电平时，则输出 0\n* 没有连接的，则不受地址线影响，输出低电平 0","source":"_posts/《计算机专业导论》学习笔记.md","raw":"---\ntitle: 《计算机专业导论》学习笔记\ndate: 2020-09-03 23:16:46\ntop_img: https://simon-bookcase.oss-cn-beijing.aliyuncs.com/jake-davies-adc2oWaP9R4-unsplash%281%29.jpg\ncover: https://simon-bookcase.oss-cn-beijing.aliyuncs.com/jake-davies-adc2oWaP9R4-unsplash%281%29.jpg\ntags: 计算机基础\ncategories: \n    - 计算机组成\n---\n\n![image-20200920132251586](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200920132251586.png)\n\n\n\n[https://www.bilibili.com/video/BV1Qt411J7mo?p=1](https://www.bilibili.com/video/BV1Qt411J7mo?p=1)\n\n## 简介\n\n这是B站上哈尔滨工业大学战德臣老师讲的课程，我的目的是想把计算机专业的重要课程系统的学习一遍，而这个也是B站大佬推荐的系列课程的第一课\n\n\n\n仅就课程内容而言，对我而言还是有些尴尬的。前面讲的一些关于计算机组成的东西，讲的内容都很浅显，我基本都知道，而如果只是知道这么一点的话，肯定是不够的，所以不管怎样，还是要系统的、更具针对性的学习一遍。而后面关于代码和算法的内容，在算法建模之后直接来了个遗传算法，我是不知道如果是一个刚进大学，对计算机不甚了解的学生学完这个的帮助究竟有多大。数据结构和算法都很重要，这也是后面我打算逐步深入、认真学习的内容\n\n\n\n这个课程我没有看完，主要是感觉讲的东西很多不重要，重要的部分又讲的太浅，还是要专门去学习那一部分的内容\n\n\n\n如果你是一个刚入学的学生，或者是一个已经工作的程序员，但是对计算机全无了解，那么你可以考虑看一下这个课程。里面的内容也不用了解的太深，知道个大概就行。有了对计算机专业课程的大致了解之后，再选择性的去深入学习自己感兴趣的内容。说到底，这门课程，终究只是个导论\n\n\n\n**推荐指数**：★☆☆☆☆\n\n------\n\n\n\n## 符号化、计算化和自动化\n\n### 信息如何用0和1来表示\n\n#### 数值信息可以用进位制来表示\n\n\n\n**进位制**：用数码和带有权值的数位来表示有大小关系的数值性信息的表示方法\n\n计算机内部采用的都是二进制的计数法\n\n\n\n------\n\n#### 非数值的信息可以用编码来表示\n\n\n\n**编码**：编码是以若干位数码或符号的不同组合来表示非数值性信息的方法，它是人为的将若干位数码或符号的每一种组合指定一种唯一的含义\n\n\n\n**ASCII码**：\n\nASCII码是英文字母与符号的0，1型编码，是用 7 位 0 和 1 的不同组合来来表示10个数字、26个英文大写字母、26个英文小写字母及一些特殊符号的编码方法，是信息交换的标准编码\n\n\n\n------\n\n#### 汉字的编码\n\n\n\n**汉字内码**：汉字在计算机内部采用汉字内码存储，汉字内码是一两字节且最高位均为 1 的 0、1 型编码\n\n**汉字输入码**：汉字输入码是用键盘上的字母符号编码每一汉字的编码，它使人们通过键入字母符号代替键入汉字\n\n**汉字字形码**：汉字字形码是用 0 和 1 编码无亮点和有亮点像素，形成汉字字形的一种编码。依据字形码通过显示器或打印机是输出汉字\n\n\n\n------\n\n## 冯·诺伊曼计算机的思想与构成\n\n### 什么是冯·诺伊曼计算机\n\n#### 冯·诺伊曼计算机的基本思想\n\n\n\n冯·诺伊曼计算机的的基本思想\n\n* 运算和存储分离\n* 存储程序：指令和数据以同等地位事先存于存储器，可按地址寻访，连续自动执行\n* 五大部件构成：运算器、控制器、存储器、输入设备和输出设备\n* 指令和数据用二进制表示，指令由操作码和地址码组成\n* 以运算器为中心，控制器负责解释指令，运算器负责执行指令\n\n\n\n![1599230961](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1599230961.jpg)\n\n\n\n#### 计算机的基本部件\n\n\n\nCPU、主存储器、I/O设备及总线成为现代计算机的四大核心部件\n\nCPU：中央处理单元，将运算器和控制器集成在一块芯片上，形成微处理器\n\n\n\n------\n\n### 自动存储与存储器\n\n#### 存储器的简介\n\n\n\n存储器单元实际上是时序逻辑电路的一种。按存储器的使用类型可分为只读存储器(ROM)和随机存取存储器(RAM)，两者的功能有较大的区别，因此在描述上也有所不同\n\n\n\n存储器是许多存储单元的集合，按单元号顺序排列。每个单元由若干三进制位构成，以表示存储单元中存放的数值，这种结构和数组的结构非常相似，故在VHDL语言中，通常由数组描述存储器\n\n\n\n------\n\n#### 存储器的实现示例\n\n\n![1599236550](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1599236550.jpg)\n\n\n\n* 当地址线和数据线间连接有二极管时，则存储的是 1，否则，存储的是 0\n* 当地址线和数据线间连接有二极管时，由地址线决定其输出 1 或 0，即当地址线为高电平时，则输出 1，而当地址线为低电平时，则输出 0\n* 没有连接的，则不受地址线影响，输出低电平 0","slug":"《计算机专业导论》学习笔记","published":1,"updated":"2020-09-20T05:52:19.806Z","_id":"ckepsik5p0000r0v7et8vhcq7","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200920132251586.png\" alt=\"image-20200920132251586\"></p>\n<p><a href=\"https://www.bilibili.com/video/BV1Qt411J7mo?p=1\">https://www.bilibili.com/video/BV1Qt411J7mo?p=1</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>这是B站上哈尔滨工业大学战德臣老师讲的课程，我的目的是想把计算机专业的重要课程系统的学习一遍，而这个也是B站大佬推荐的系列课程的第一课</p>\n<p>仅就课程内容而言，对我而言还是有些尴尬的。前面讲的一些关于计算机组成的东西，讲的内容都很浅显，我基本都知道，而如果只是知道这么一点的话，肯定是不够的，所以不管怎样，还是要系统的、更具针对性的学习一遍。而后面关于代码和算法的内容，在算法建模之后直接来了个遗传算法，我是不知道如果是一个刚进大学，对计算机不甚了解的学生学完这个的帮助究竟有多大。数据结构和算法都很重要，这也是后面我打算逐步深入、认真学习的内容</p>\n<p>这个课程我没有看完，主要是感觉讲的东西很多不重要，重要的部分又讲的太浅，还是要专门去学习那一部分的内容</p>\n<p>如果你是一个刚入学的学生，或者是一个已经工作的程序员，但是对计算机全无了解，那么你可以考虑看一下这个课程。里面的内容也不用了解的太深，知道个大概就行。有了对计算机专业课程的大致了解之后，再选择性的去深入学习自己感兴趣的内容。说到底，这门课程，终究只是个导论</p>\n<p><strong>推荐指数</strong>：★☆☆☆☆</p>\n<hr>\n<h2 id=\"符号化、计算化和自动化\"><a href=\"#符号化、计算化和自动化\" class=\"headerlink\" title=\"符号化、计算化和自动化\"></a>符号化、计算化和自动化</h2><h3 id=\"信息如何用0和1来表示\"><a href=\"#信息如何用0和1来表示\" class=\"headerlink\" title=\"信息如何用0和1来表示\"></a>信息如何用0和1来表示</h3><h4 id=\"数值信息可以用进位制来表示\"><a href=\"#数值信息可以用进位制来表示\" class=\"headerlink\" title=\"数值信息可以用进位制来表示\"></a>数值信息可以用进位制来表示</h4><p><strong>进位制</strong>：用数码和带有权值的数位来表示有大小关系的数值性信息的表示方法</p>\n<p>计算机内部采用的都是二进制的计数法</p>\n<hr>\n<h4 id=\"非数值的信息可以用编码来表示\"><a href=\"#非数值的信息可以用编码来表示\" class=\"headerlink\" title=\"非数值的信息可以用编码来表示\"></a>非数值的信息可以用编码来表示</h4><p><strong>编码</strong>：编码是以若干位数码或符号的不同组合来表示非数值性信息的方法，它是人为的将若干位数码或符号的每一种组合指定一种唯一的含义</p>\n<p><strong>ASCII码</strong>：</p>\n<p>ASCII码是英文字母与符号的0，1型编码，是用 7 位 0 和 1 的不同组合来来表示10个数字、26个英文大写字母、26个英文小写字母及一些特殊符号的编码方法，是信息交换的标准编码</p>\n<hr>\n<h4 id=\"汉字的编码\"><a href=\"#汉字的编码\" class=\"headerlink\" title=\"汉字的编码\"></a>汉字的编码</h4><p><strong>汉字内码</strong>：汉字在计算机内部采用汉字内码存储，汉字内码是一两字节且最高位均为 1 的 0、1 型编码</p>\n<p><strong>汉字输入码</strong>：汉字输入码是用键盘上的字母符号编码每一汉字的编码，它使人们通过键入字母符号代替键入汉字</p>\n<p><strong>汉字字形码</strong>：汉字字形码是用 0 和 1 编码无亮点和有亮点像素，形成汉字字形的一种编码。依据字形码通过显示器或打印机是输出汉字</p>\n<hr>\n<h2 id=\"冯·诺伊曼计算机的思想与构成\"><a href=\"#冯·诺伊曼计算机的思想与构成\" class=\"headerlink\" title=\"冯·诺伊曼计算机的思想与构成\"></a>冯·诺伊曼计算机的思想与构成</h2><h3 id=\"什么是冯·诺伊曼计算机\"><a href=\"#什么是冯·诺伊曼计算机\" class=\"headerlink\" title=\"什么是冯·诺伊曼计算机\"></a>什么是冯·诺伊曼计算机</h3><h4 id=\"冯·诺伊曼计算机的基本思想\"><a href=\"#冯·诺伊曼计算机的基本思想\" class=\"headerlink\" title=\"冯·诺伊曼计算机的基本思想\"></a>冯·诺伊曼计算机的基本思想</h4><p>冯·诺伊曼计算机的的基本思想</p>\n<ul>\n<li>运算和存储分离</li>\n<li>存储程序：指令和数据以同等地位事先存于存储器，可按地址寻访，连续自动执行</li>\n<li>五大部件构成：运算器、控制器、存储器、输入设备和输出设备</li>\n<li>指令和数据用二进制表示，指令由操作码和地址码组成</li>\n<li>以运算器为中心，控制器负责解释指令，运算器负责执行指令</li>\n</ul>\n<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1599230961.jpg\" alt=\"1599230961\"></p>\n<h4 id=\"计算机的基本部件\"><a href=\"#计算机的基本部件\" class=\"headerlink\" title=\"计算机的基本部件\"></a>计算机的基本部件</h4><p>CPU、主存储器、I/O设备及总线成为现代计算机的四大核心部件</p>\n<p>CPU：中央处理单元，将运算器和控制器集成在一块芯片上，形成微处理器</p>\n<hr>\n<h3 id=\"自动存储与存储器\"><a href=\"#自动存储与存储器\" class=\"headerlink\" title=\"自动存储与存储器\"></a>自动存储与存储器</h3><h4 id=\"存储器的简介\"><a href=\"#存储器的简介\" class=\"headerlink\" title=\"存储器的简介\"></a>存储器的简介</h4><p>存储器单元实际上是时序逻辑电路的一种。按存储器的使用类型可分为只读存储器(ROM)和随机存取存储器(RAM)，两者的功能有较大的区别，因此在描述上也有所不同</p>\n<p>存储器是许多存储单元的集合，按单元号顺序排列。每个单元由若干三进制位构成，以表示存储单元中存放的数值，这种结构和数组的结构非常相似，故在VHDL语言中，通常由数组描述存储器</p>\n<hr>\n<h4 id=\"存储器的实现示例\"><a href=\"#存储器的实现示例\" class=\"headerlink\" title=\"存储器的实现示例\"></a>存储器的实现示例</h4><p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1599236550.jpg\" alt=\"1599236550\"></p>\n<ul>\n<li>当地址线和数据线间连接有二极管时，则存储的是 1，否则，存储的是 0</li>\n<li>当地址线和数据线间连接有二极管时，由地址线决定其输出 1 或 0，即当地址线为高电平时，则输出 1，而当地址线为低电平时，则输出 0</li>\n<li>没有连接的，则不受地址线影响，输出低电平 0</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200920132251586.png\" alt=\"image-20200920132251586\"></p>\n<p><a href=\"https://www.bilibili.com/video/BV1Qt411J7mo?p=1\">https://www.bilibili.com/video/BV1Qt411J7mo?p=1</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>这是B站上哈尔滨工业大学战德臣老师讲的课程，我的目的是想把计算机专业的重要课程系统的学习一遍，而这个也是B站大佬推荐的系列课程的第一课</p>\n<p>仅就课程内容而言，对我而言还是有些尴尬的。前面讲的一些关于计算机组成的东西，讲的内容都很浅显，我基本都知道，而如果只是知道这么一点的话，肯定是不够的，所以不管怎样，还是要系统的、更具针对性的学习一遍。而后面关于代码和算法的内容，在算法建模之后直接来了个遗传算法，我是不知道如果是一个刚进大学，对计算机不甚了解的学生学完这个的帮助究竟有多大。数据结构和算法都很重要，这也是后面我打算逐步深入、认真学习的内容</p>\n<p>这个课程我没有看完，主要是感觉讲的东西很多不重要，重要的部分又讲的太浅，还是要专门去学习那一部分的内容</p>\n<p>如果你是一个刚入学的学生，或者是一个已经工作的程序员，但是对计算机全无了解，那么你可以考虑看一下这个课程。里面的内容也不用了解的太深，知道个大概就行。有了对计算机专业课程的大致了解之后，再选择性的去深入学习自己感兴趣的内容。说到底，这门课程，终究只是个导论</p>\n<p><strong>推荐指数</strong>：★☆☆☆☆</p>\n<hr>\n<h2 id=\"符号化、计算化和自动化\"><a href=\"#符号化、计算化和自动化\" class=\"headerlink\" title=\"符号化、计算化和自动化\"></a>符号化、计算化和自动化</h2><h3 id=\"信息如何用0和1来表示\"><a href=\"#信息如何用0和1来表示\" class=\"headerlink\" title=\"信息如何用0和1来表示\"></a>信息如何用0和1来表示</h3><h4 id=\"数值信息可以用进位制来表示\"><a href=\"#数值信息可以用进位制来表示\" class=\"headerlink\" title=\"数值信息可以用进位制来表示\"></a>数值信息可以用进位制来表示</h4><p><strong>进位制</strong>：用数码和带有权值的数位来表示有大小关系的数值性信息的表示方法</p>\n<p>计算机内部采用的都是二进制的计数法</p>\n<hr>\n<h4 id=\"非数值的信息可以用编码来表示\"><a href=\"#非数值的信息可以用编码来表示\" class=\"headerlink\" title=\"非数值的信息可以用编码来表示\"></a>非数值的信息可以用编码来表示</h4><p><strong>编码</strong>：编码是以若干位数码或符号的不同组合来表示非数值性信息的方法，它是人为的将若干位数码或符号的每一种组合指定一种唯一的含义</p>\n<p><strong>ASCII码</strong>：</p>\n<p>ASCII码是英文字母与符号的0，1型编码，是用 7 位 0 和 1 的不同组合来来表示10个数字、26个英文大写字母、26个英文小写字母及一些特殊符号的编码方法，是信息交换的标准编码</p>\n<hr>\n<h4 id=\"汉字的编码\"><a href=\"#汉字的编码\" class=\"headerlink\" title=\"汉字的编码\"></a>汉字的编码</h4><p><strong>汉字内码</strong>：汉字在计算机内部采用汉字内码存储，汉字内码是一两字节且最高位均为 1 的 0、1 型编码</p>\n<p><strong>汉字输入码</strong>：汉字输入码是用键盘上的字母符号编码每一汉字的编码，它使人们通过键入字母符号代替键入汉字</p>\n<p><strong>汉字字形码</strong>：汉字字形码是用 0 和 1 编码无亮点和有亮点像素，形成汉字字形的一种编码。依据字形码通过显示器或打印机是输出汉字</p>\n<hr>\n<h2 id=\"冯·诺伊曼计算机的思想与构成\"><a href=\"#冯·诺伊曼计算机的思想与构成\" class=\"headerlink\" title=\"冯·诺伊曼计算机的思想与构成\"></a>冯·诺伊曼计算机的思想与构成</h2><h3 id=\"什么是冯·诺伊曼计算机\"><a href=\"#什么是冯·诺伊曼计算机\" class=\"headerlink\" title=\"什么是冯·诺伊曼计算机\"></a>什么是冯·诺伊曼计算机</h3><h4 id=\"冯·诺伊曼计算机的基本思想\"><a href=\"#冯·诺伊曼计算机的基本思想\" class=\"headerlink\" title=\"冯·诺伊曼计算机的基本思想\"></a>冯·诺伊曼计算机的基本思想</h4><p>冯·诺伊曼计算机的的基本思想</p>\n<ul>\n<li>运算和存储分离</li>\n<li>存储程序：指令和数据以同等地位事先存于存储器，可按地址寻访，连续自动执行</li>\n<li>五大部件构成：运算器、控制器、存储器、输入设备和输出设备</li>\n<li>指令和数据用二进制表示，指令由操作码和地址码组成</li>\n<li>以运算器为中心，控制器负责解释指令，运算器负责执行指令</li>\n</ul>\n<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1599230961.jpg\" alt=\"1599230961\"></p>\n<h4 id=\"计算机的基本部件\"><a href=\"#计算机的基本部件\" class=\"headerlink\" title=\"计算机的基本部件\"></a>计算机的基本部件</h4><p>CPU、主存储器、I/O设备及总线成为现代计算机的四大核心部件</p>\n<p>CPU：中央处理单元，将运算器和控制器集成在一块芯片上，形成微处理器</p>\n<hr>\n<h3 id=\"自动存储与存储器\"><a href=\"#自动存储与存储器\" class=\"headerlink\" title=\"自动存储与存储器\"></a>自动存储与存储器</h3><h4 id=\"存储器的简介\"><a href=\"#存储器的简介\" class=\"headerlink\" title=\"存储器的简介\"></a>存储器的简介</h4><p>存储器单元实际上是时序逻辑电路的一种。按存储器的使用类型可分为只读存储器(ROM)和随机存取存储器(RAM)，两者的功能有较大的区别，因此在描述上也有所不同</p>\n<p>存储器是许多存储单元的集合，按单元号顺序排列。每个单元由若干三进制位构成，以表示存储单元中存放的数值，这种结构和数组的结构非常相似，故在VHDL语言中，通常由数组描述存储器</p>\n<hr>\n<h4 id=\"存储器的实现示例\"><a href=\"#存储器的实现示例\" class=\"headerlink\" title=\"存储器的实现示例\"></a>存储器的实现示例</h4><p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1599236550.jpg\" alt=\"1599236550\"></p>\n<ul>\n<li>当地址线和数据线间连接有二极管时，则存储的是 1，否则，存储的是 0</li>\n<li>当地址线和数据线间连接有二极管时，由地址线决定其输出 1 或 0，即当地址线为高电平时，则输出 1，而当地址线为低电平时，则输出 0</li>\n<li>没有连接的，则不受地址线影响，输出低电平 0</li>\n</ul>\n"},{"title":"使用Hexo的butterfly主题搭建一个博客","date":"2020-09-01T05:33:26.000Z","top_img":"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/domenico-loia-hGV2TfOh0ns-unsplash.jpg","cover":"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/domenico-loia-hGV2TfOh0ns-unsplash.jpg","_content":"\n## 安装Git\n\n#### 安装Git\n\n\n\nHexo 的主题需要通过 Git 来进行下载，同时生成的静态页面也需要部署到 GitHub Page，因此Git是必需的\n\n网上 Git 的安装和配置教程很多，大家可根据自己的需求选择合适的教程，这是我推荐的一个安装及配置教程\n\n[Git的下载、安装与环境配置](https://blog.csdn.net/huangqqdy/article/details/83032408)\n\n\n\n------\n\n## 安装npm\n\n#### 安装npm\n\n\n\nHexo 是一个前端框架，因此 npm 就更是必需的了，相比于 Git，npm 的安装就更简单了，这里同样也给出一个安装教程\n\n[npm的安装与配置](https://blog.csdn.net/u011342720/article/details/81267908)\n\n一般情况下，执行到第 5 步，npm 就算安装完成了，如果你的 npm 下载速度太慢或者你有更高的要求的话，可以考虑继续后面的配置\n\n\n\n------\n\n## butterfly初体验\n\n#### 创建 hexo 博客项目\n\n\n\nbutterfly 是 hexo 博客模板的一个主题，要是用 butterfly 主题，需要先创建一个 hexo 博客项目\n\n\n\n**安装 hexo**\n\n```\nnpm i -g hexo\n```\n\n**查看 hexo 版本**\n\n```\nhexo -v\n```\n\n**通过 hexo 创建一个博客项目**\n\n```\nhexo init 项目名\n```\n\n**下载项目所需的包**\n\n```\ncd 项目名\nnpm install\n```\n\n\n\n------\n\n#### 替换博客主题\n\n\n\nhexo 的默认博客主题是 landscape，我们需要将其替换为我们想要的博客主题\n\n\n\n**下载博客主题**\n\n在项目根目录下执行\n\n```\ngit clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly\n```\n\n**复制配置文件**\n\n将项目根目录下的 _config.yml 的配置文件复制一份，更名为 _config.butterfly.yml，之后就可以通过修改 _config.butterfly.yml 配置文件来自定义配置了。使用这种方式，不会在更新 Hexo 覆盖配置文件，当两个配置文件的配置冲突时，也会以 _config.butterfly.yml 的为准，此方法只支持 Hexo 5.0.0 及以上版本 \n\n![1599311824](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1599311824.jpg)\n\n**修改配置文件**\n\n修改 _config.butterfly.yml 的内容\n\n```\n# 修改主题\ntheme: butterfly\n# 修改博客项目名\ntitle: Simon的书柜\n# 修改作者\nauthor: Simon\n# 修改语言为中文\nlanguage: zh-CN\n# 修改博客顶部背景图\ndefault_top_img: 图片路径\n```\n\n**启动项目**\n\n```\n# 清除缓存\nhexo clean\n# 生成静态化页面\nhexo g\n# 启动项目\nhexo s\n```\n\n启动完成后，就可以在本地浏览器通过 http://localhost:4000/ 来访问自己的项目了\n\n\n\n如果页面上出现的是一下内容的话，则需要安装 pug 及 stylus 的渲染器\n\nextends includes/layout.pug block content include includes/recent-posts.pug include includes/partial\n\n**安装指令**\n\n```\nnpm install hexo-renderer-pug hexo-renderer-stylus --save\n```\n\n------\n\n\n\n#### 将博客部署到Git\n\n**新建Git仓库**\n\n在 Git 上新建一个名为 *用户名.github.io* 的仓库，这种方式是最简单的\n\n或者新建一个任意名称的仓库，然后去设置*里面将 Github Pages 的仓库地址改为该仓库，注意，一个 Git 账户只能有一个 Github Pages\n\n\n\n**安装Git插件**\n\n```\nnpm install --save hexo-deployer-git\n```\n\n\n\n**配置文件**\n\n在 _config.butterfly.yml 配置文件中添加以下内容\n\n```\ndeploy:\n  type: git\n  repo: https://github.com/CK-shadow/CK-shadow.github.io.git\n  branch: master\n```\n\n\n\n**项目部署**\n\n执行以下指定\n\n```\nhexo g -d\n```\n\n部署完成后，就可以通过 https://用户名.github.io/ 在浏览器上打开你的博客了\n\n[Simon的书柜](https://ck-shadow.github.io/)\n\n\n\n## 给博客添加标签和分类\n\n#### Front-matter\n\n\n\n我们可以在文章的 Front-matter 添加这篇文章的信息，可添加的内容有很多，一般主要用到的有\n\n* title：文章标题（必需）\n\n* date：文章创建日期（必需）\n\n* updated：文章更新日期\n\n* tags：标签\n\n* categories：分类\n\n* keywords：关键字\n\n* description：文章描述\n\n* top_img：文章顶部图片\n\n* cover：文章略缩图\n\n  \n\n除此之外，还以很多其它的可选信息，大家可以去官网查看并添加自己想要的内容\n\n------\n\n\n\n#### 添加标签\n\n**给文章添加响应的标签内容**\n\n```\ntitle: 使用Hexo的butterfly主题搭建一个博客\ndate: 2020-09-01 13:33:26\ntags: Butterfly\n```\n\n\n\n**创建tags文件**\n\n在博客根目录下输入以下命令\n\n```\nhexo new page tags\n```\n\n\n\n**修改文件**\n\n接下来就可以在项目中找到 source/tags/index.md 这个文件了，我们需要在其中添加以下内容\n\n```markdown\n---\ntitle: 标签\ndate: 2018-01-05 00:00:00\ntype: \"tags\"\n---\n```\n\n接下来重启项目，就可以看到自己添加的标签了\n\n------\n\n\n\n#### 添加分类\n\n**给文章添加响应的分类内容**\n\n```\ntitle: 使用Hexo的butterfly主题搭建一个博客\ndate: 2020-09-01 13:33:26\ncategories: \n  - 博客\n```\n\n文章可以支持多个分类，最终会是层级展示效果，语法为\n\n```\ncategories: \n\t- 分类A\n\t- 分类B\n```\n\n\n\n**创建 categories 文件**\n\n在博客根目录下输入以下命令\n\n```\nhexo new page categories\n```\n\n\n\n**修改文件**\n\n接下来就可以在项目中找到 source/categories/index.md 这个文件了，我们需要在其中添加以下内容\n\n```markdown\n---\ntitle: 分类\ndate: 2018-01-05 00:00:00\ntype: \"categories\"\n---\n```\n\n接下来重启项目，就可以看到自己添加的标签了\n\n------\n\n\n\n## 添加顶部导航栏\n\n\n\n在 _config.butterfly.yml 中添加以下配置内容，重启项目，就可以在博客顶部看到添加的导航栏了\n\n```\nmenu:\n  首页: / || fas fa-home\n  时间轴: /archives/ || fas fa-archive\n  标签: /tags/ || fas fa-tags\n  分类: /categories/ || fas fa-folder-open\n  清单 ||fa fa-heartbeat:\n    - 音乐 || /music/ || fas fa-music\n    - 照片 || /Gallery/ || fas fa-images\n    - 电影 || /movies/ || fas fa-video\n  友链: /link/ || fas fa-link\n  关于: /about/ || fas fa-heart\n```\n\n","source":"_posts/使用Hexo的butterfly主题搭建一个博客.md","raw":"---\ntitle: 使用Hexo的butterfly主题搭建一个博客\ndate: 2020-09-01 13:33:26\ntop_img: https://simon-bookcase.oss-cn-beijing.aliyuncs.com/domenico-loia-hGV2TfOh0ns-unsplash.jpg\ncover: https://simon-bookcase.oss-cn-beijing.aliyuncs.com/domenico-loia-hGV2TfOh0ns-unsplash.jpg\ntags: Butterfly\ncategories: \n  - 博客\n---\n\n## 安装Git\n\n#### 安装Git\n\n\n\nHexo 的主题需要通过 Git 来进行下载，同时生成的静态页面也需要部署到 GitHub Page，因此Git是必需的\n\n网上 Git 的安装和配置教程很多，大家可根据自己的需求选择合适的教程，这是我推荐的一个安装及配置教程\n\n[Git的下载、安装与环境配置](https://blog.csdn.net/huangqqdy/article/details/83032408)\n\n\n\n------\n\n## 安装npm\n\n#### 安装npm\n\n\n\nHexo 是一个前端框架，因此 npm 就更是必需的了，相比于 Git，npm 的安装就更简单了，这里同样也给出一个安装教程\n\n[npm的安装与配置](https://blog.csdn.net/u011342720/article/details/81267908)\n\n一般情况下，执行到第 5 步，npm 就算安装完成了，如果你的 npm 下载速度太慢或者你有更高的要求的话，可以考虑继续后面的配置\n\n\n\n------\n\n## butterfly初体验\n\n#### 创建 hexo 博客项目\n\n\n\nbutterfly 是 hexo 博客模板的一个主题，要是用 butterfly 主题，需要先创建一个 hexo 博客项目\n\n\n\n**安装 hexo**\n\n```\nnpm i -g hexo\n```\n\n**查看 hexo 版本**\n\n```\nhexo -v\n```\n\n**通过 hexo 创建一个博客项目**\n\n```\nhexo init 项目名\n```\n\n**下载项目所需的包**\n\n```\ncd 项目名\nnpm install\n```\n\n\n\n------\n\n#### 替换博客主题\n\n\n\nhexo 的默认博客主题是 landscape，我们需要将其替换为我们想要的博客主题\n\n\n\n**下载博客主题**\n\n在项目根目录下执行\n\n```\ngit clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly\n```\n\n**复制配置文件**\n\n将项目根目录下的 _config.yml 的配置文件复制一份，更名为 _config.butterfly.yml，之后就可以通过修改 _config.butterfly.yml 配置文件来自定义配置了。使用这种方式，不会在更新 Hexo 覆盖配置文件，当两个配置文件的配置冲突时，也会以 _config.butterfly.yml 的为准，此方法只支持 Hexo 5.0.0 及以上版本 \n\n![1599311824](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1599311824.jpg)\n\n**修改配置文件**\n\n修改 _config.butterfly.yml 的内容\n\n```\n# 修改主题\ntheme: butterfly\n# 修改博客项目名\ntitle: Simon的书柜\n# 修改作者\nauthor: Simon\n# 修改语言为中文\nlanguage: zh-CN\n# 修改博客顶部背景图\ndefault_top_img: 图片路径\n```\n\n**启动项目**\n\n```\n# 清除缓存\nhexo clean\n# 生成静态化页面\nhexo g\n# 启动项目\nhexo s\n```\n\n启动完成后，就可以在本地浏览器通过 http://localhost:4000/ 来访问自己的项目了\n\n\n\n如果页面上出现的是一下内容的话，则需要安装 pug 及 stylus 的渲染器\n\nextends includes/layout.pug block content include includes/recent-posts.pug include includes/partial\n\n**安装指令**\n\n```\nnpm install hexo-renderer-pug hexo-renderer-stylus --save\n```\n\n------\n\n\n\n#### 将博客部署到Git\n\n**新建Git仓库**\n\n在 Git 上新建一个名为 *用户名.github.io* 的仓库，这种方式是最简单的\n\n或者新建一个任意名称的仓库，然后去设置*里面将 Github Pages 的仓库地址改为该仓库，注意，一个 Git 账户只能有一个 Github Pages\n\n\n\n**安装Git插件**\n\n```\nnpm install --save hexo-deployer-git\n```\n\n\n\n**配置文件**\n\n在 _config.butterfly.yml 配置文件中添加以下内容\n\n```\ndeploy:\n  type: git\n  repo: https://github.com/CK-shadow/CK-shadow.github.io.git\n  branch: master\n```\n\n\n\n**项目部署**\n\n执行以下指定\n\n```\nhexo g -d\n```\n\n部署完成后，就可以通过 https://用户名.github.io/ 在浏览器上打开你的博客了\n\n[Simon的书柜](https://ck-shadow.github.io/)\n\n\n\n## 给博客添加标签和分类\n\n#### Front-matter\n\n\n\n我们可以在文章的 Front-matter 添加这篇文章的信息，可添加的内容有很多，一般主要用到的有\n\n* title：文章标题（必需）\n\n* date：文章创建日期（必需）\n\n* updated：文章更新日期\n\n* tags：标签\n\n* categories：分类\n\n* keywords：关键字\n\n* description：文章描述\n\n* top_img：文章顶部图片\n\n* cover：文章略缩图\n\n  \n\n除此之外，还以很多其它的可选信息，大家可以去官网查看并添加自己想要的内容\n\n------\n\n\n\n#### 添加标签\n\n**给文章添加响应的标签内容**\n\n```\ntitle: 使用Hexo的butterfly主题搭建一个博客\ndate: 2020-09-01 13:33:26\ntags: Butterfly\n```\n\n\n\n**创建tags文件**\n\n在博客根目录下输入以下命令\n\n```\nhexo new page tags\n```\n\n\n\n**修改文件**\n\n接下来就可以在项目中找到 source/tags/index.md 这个文件了，我们需要在其中添加以下内容\n\n```markdown\n---\ntitle: 标签\ndate: 2018-01-05 00:00:00\ntype: \"tags\"\n---\n```\n\n接下来重启项目，就可以看到自己添加的标签了\n\n------\n\n\n\n#### 添加分类\n\n**给文章添加响应的分类内容**\n\n```\ntitle: 使用Hexo的butterfly主题搭建一个博客\ndate: 2020-09-01 13:33:26\ncategories: \n  - 博客\n```\n\n文章可以支持多个分类，最终会是层级展示效果，语法为\n\n```\ncategories: \n\t- 分类A\n\t- 分类B\n```\n\n\n\n**创建 categories 文件**\n\n在博客根目录下输入以下命令\n\n```\nhexo new page categories\n```\n\n\n\n**修改文件**\n\n接下来就可以在项目中找到 source/categories/index.md 这个文件了，我们需要在其中添加以下内容\n\n```markdown\n---\ntitle: 分类\ndate: 2018-01-05 00:00:00\ntype: \"categories\"\n---\n```\n\n接下来重启项目，就可以看到自己添加的标签了\n\n------\n\n\n\n## 添加顶部导航栏\n\n\n\n在 _config.butterfly.yml 中添加以下配置内容，重启项目，就可以在博客顶部看到添加的导航栏了\n\n```\nmenu:\n  首页: / || fas fa-home\n  时间轴: /archives/ || fas fa-archive\n  标签: /tags/ || fas fa-tags\n  分类: /categories/ || fas fa-folder-open\n  清单 ||fa fa-heartbeat:\n    - 音乐 || /music/ || fas fa-music\n    - 照片 || /Gallery/ || fas fa-images\n    - 电影 || /movies/ || fas fa-video\n  友链: /link/ || fas fa-link\n  关于: /about/ || fas fa-heart\n```\n\n","slug":"使用Hexo的butterfly主题搭建一个博客","published":1,"updated":"2020-09-15T15:22:07.749Z","_id":"ckepsik5t0001r0v73ptdd86d","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"安装Git\"><a href=\"#安装Git\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h2><h4 id=\"安装Git-1\"><a href=\"#安装Git-1\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h4><p>Hexo 的主题需要通过 Git 来进行下载，同时生成的静态页面也需要部署到 GitHub Page，因此Git是必需的</p>\n<p>网上 Git 的安装和配置教程很多，大家可根据自己的需求选择合适的教程，这是我推荐的一个安装及配置教程</p>\n<p><a href=\"https://blog.csdn.net/huangqqdy/article/details/83032408\">Git的下载、安装与环境配置</a></p>\n<hr>\n<h2 id=\"安装npm\"><a href=\"#安装npm\" class=\"headerlink\" title=\"安装npm\"></a>安装npm</h2><h4 id=\"安装npm-1\"><a href=\"#安装npm-1\" class=\"headerlink\" title=\"安装npm\"></a>安装npm</h4><p>Hexo 是一个前端框架，因此 npm 就更是必需的了，相比于 Git，npm 的安装就更简单了，这里同样也给出一个安装教程</p>\n<p><a href=\"https://blog.csdn.net/u011342720/article/details/81267908\">npm的安装与配置</a></p>\n<p>一般情况下，执行到第 5 步，npm 就算安装完成了，如果你的 npm 下载速度太慢或者你有更高的要求的话，可以考虑继续后面的配置</p>\n<hr>\n<h2 id=\"butterfly初体验\"><a href=\"#butterfly初体验\" class=\"headerlink\" title=\"butterfly初体验\"></a>butterfly初体验</h2><h4 id=\"创建-hexo-博客项目\"><a href=\"#创建-hexo-博客项目\" class=\"headerlink\" title=\"创建 hexo 博客项目\"></a>创建 hexo 博客项目</h4><p>butterfly 是 hexo 博客模板的一个主题，要是用 butterfly 主题，需要先创建一个 hexo 博客项目</p>\n<p><strong>安装 hexo</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -g hexo</span><br></pre></td></tr></table></figure>\n\n<p><strong>查看 hexo 版本</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo -v</span><br></pre></td></tr></table></figure>\n\n<p><strong>通过 hexo 创建一个博客项目</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init 项目名</span><br></pre></td></tr></table></figure>\n\n<p><strong>下载项目所需的包</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd 项目名</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h4 id=\"替换博客主题\"><a href=\"#替换博客主题\" class=\"headerlink\" title=\"替换博客主题\"></a>替换博客主题</h4><p>hexo 的默认博客主题是 landscape，我们需要将其替换为我们想要的博客主题</p>\n<p><strong>下载博客主题</strong></p>\n<p>在项目根目录下执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone -b master https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly.git themes&#x2F;butterfly</span><br></pre></td></tr></table></figure>\n\n<p><strong>复制配置文件</strong></p>\n<p>将项目根目录下的 _config.yml 的配置文件复制一份，更名为 _config.butterfly.yml，之后就可以通过修改 _config.butterfly.yml 配置文件来自定义配置了。使用这种方式，不会在更新 Hexo 覆盖配置文件，当两个配置文件的配置冲突时，也会以 _config.butterfly.yml 的为准，此方法只支持 Hexo 5.0.0 及以上版本 </p>\n<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1599311824.jpg\" alt=\"1599311824\"></p>\n<p><strong>修改配置文件</strong></p>\n<p>修改 _config.butterfly.yml 的内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 修改主题</span><br><span class=\"line\">theme: butterfly</span><br><span class=\"line\"># 修改博客项目名</span><br><span class=\"line\">title: Simon的书柜</span><br><span class=\"line\"># 修改作者</span><br><span class=\"line\">author: Simon</span><br><span class=\"line\"># 修改语言为中文</span><br><span class=\"line\">language: zh-CN</span><br><span class=\"line\"># 修改博客顶部背景图</span><br><span class=\"line\">default_top_img: 图片路径</span><br></pre></td></tr></table></figure>\n\n<p><strong>启动项目</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 清除缓存</span><br><span class=\"line\">hexo clean</span><br><span class=\"line\"># 生成静态化页面</span><br><span class=\"line\">hexo g</span><br><span class=\"line\"># 启动项目</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n\n<p>启动完成后，就可以在本地浏览器通过 <a href=\"http://localhost:4000/\">http://localhost:4000/</a> 来访问自己的项目了</p>\n<p>如果页面上出现的是一下内容的话，则需要安装 pug 及 stylus 的渲染器</p>\n<p>extends includes/layout.pug block content include includes/recent-posts.pug include includes/partial</p>\n<p><strong>安装指令</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"将博客部署到Git\"><a href=\"#将博客部署到Git\" class=\"headerlink\" title=\"将博客部署到Git\"></a>将博客部署到Git</h4><p><strong>新建Git仓库</strong></p>\n<p>在 Git 上新建一个名为 <em>用户名.github.io</em> 的仓库，这种方式是最简单的</p>\n<p>或者新建一个任意名称的仓库，然后去设置*里面将 Github Pages 的仓库地址改为该仓库，注意，一个 Git 账户只能有一个 Github Pages</p>\n<p><strong>安装Git插件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>配置文件</strong></p>\n<p>在 _config.butterfly.yml 配置文件中添加以下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https:&#x2F;&#x2F;github.com&#x2F;CK-shadow&#x2F;CK-shadow.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>项目部署</strong></p>\n<p>执行以下指定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g -d</span><br></pre></td></tr></table></figure>\n\n<p>部署完成后，就可以通过 https://用户名.github.io/ 在浏览器上打开你的博客了</p>\n<p><a href=\"https://ck-shadow.github.io/\">Simon的书柜</a></p>\n<h2 id=\"给博客添加标签和分类\"><a href=\"#给博客添加标签和分类\" class=\"headerlink\" title=\"给博客添加标签和分类\"></a>给博客添加标签和分类</h2><h4 id=\"Front-matter\"><a href=\"#Front-matter\" class=\"headerlink\" title=\"Front-matter\"></a>Front-matter</h4><p>我们可以在文章的 Front-matter 添加这篇文章的信息，可添加的内容有很多，一般主要用到的有</p>\n<ul>\n<li><p>title：文章标题（必需）</p>\n</li>\n<li><p>date：文章创建日期（必需）</p>\n</li>\n<li><p>updated：文章更新日期</p>\n</li>\n<li><p>tags：标签</p>\n</li>\n<li><p>categories：分类</p>\n</li>\n<li><p>keywords：关键字</p>\n</li>\n<li><p>description：文章描述</p>\n</li>\n<li><p>top_img：文章顶部图片</p>\n</li>\n<li><p>cover：文章略缩图</p>\n</li>\n</ul>\n<p>除此之外，还以很多其它的可选信息，大家可以去官网查看并添加自己想要的内容</p>\n<hr>\n<h4 id=\"添加标签\"><a href=\"#添加标签\" class=\"headerlink\" title=\"添加标签\"></a>添加标签</h4><p><strong>给文章添加响应的标签内容</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 使用Hexo的butterfly主题搭建一个博客</span><br><span class=\"line\">date: 2020-09-01 13:33:26</span><br><span class=\"line\">tags: Butterfly</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>创建tags文件</strong></p>\n<p>在博客根目录下输入以下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page tags</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>修改文件</strong></p>\n<p>接下来就可以在项目中找到 source/tags/index.md 这个文件了，我们需要在其中添加以下内容</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: 标签</span><br><span class=\"line\">date: 2018-01-05 00:00:00</span><br><span class=\"line\">type: &quot;tags&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p>接下来重启项目，就可以看到自己添加的标签了</p>\n<hr>\n<h4 id=\"添加分类\"><a href=\"#添加分类\" class=\"headerlink\" title=\"添加分类\"></a>添加分类</h4><p><strong>给文章添加响应的分类内容</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 使用Hexo的butterfly主题搭建一个博客</span><br><span class=\"line\">date: 2020-09-01 13:33:26</span><br><span class=\"line\">categories: </span><br><span class=\"line\">  - 博客</span><br></pre></td></tr></table></figure>\n\n<p>文章可以支持多个分类，最终会是层级展示效果，语法为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">categories: </span><br><span class=\"line\">\t- 分类A</span><br><span class=\"line\">\t- 分类B</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>创建 categories 文件</strong></p>\n<p>在博客根目录下输入以下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page categories</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>修改文件</strong></p>\n<p>接下来就可以在项目中找到 source/categories/index.md 这个文件了，我们需要在其中添加以下内容</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: 分类</span><br><span class=\"line\">date: 2018-01-05 00:00:00</span><br><span class=\"line\">type: &quot;categories&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p>接下来重启项目，就可以看到自己添加的标签了</p>\n<hr>\n<h2 id=\"添加顶部导航栏\"><a href=\"#添加顶部导航栏\" class=\"headerlink\" title=\"添加顶部导航栏\"></a>添加顶部导航栏</h2><p>在 _config.butterfly.yml 中添加以下配置内容，重启项目，就可以在博客顶部看到添加的导航栏了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  首页: &#x2F; || fas fa-home</span><br><span class=\"line\">  时间轴: &#x2F;archives&#x2F; || fas fa-archive</span><br><span class=\"line\">  标签: &#x2F;tags&#x2F; || fas fa-tags</span><br><span class=\"line\">  分类: &#x2F;categories&#x2F; || fas fa-folder-open</span><br><span class=\"line\">  清单 ||fa fa-heartbeat:</span><br><span class=\"line\">    - 音乐 || &#x2F;music&#x2F; || fas fa-music</span><br><span class=\"line\">    - 照片 || &#x2F;Gallery&#x2F; || fas fa-images</span><br><span class=\"line\">    - 电影 || &#x2F;movies&#x2F; || fas fa-video</span><br><span class=\"line\">  友链: &#x2F;link&#x2F; || fas fa-link</span><br><span class=\"line\">  关于: &#x2F;about&#x2F; || fas fa-heart</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"安装Git\"><a href=\"#安装Git\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h2><h4 id=\"安装Git-1\"><a href=\"#安装Git-1\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h4><p>Hexo 的主题需要通过 Git 来进行下载，同时生成的静态页面也需要部署到 GitHub Page，因此Git是必需的</p>\n<p>网上 Git 的安装和配置教程很多，大家可根据自己的需求选择合适的教程，这是我推荐的一个安装及配置教程</p>\n<p><a href=\"https://blog.csdn.net/huangqqdy/article/details/83032408\">Git的下载、安装与环境配置</a></p>\n<hr>\n<h2 id=\"安装npm\"><a href=\"#安装npm\" class=\"headerlink\" title=\"安装npm\"></a>安装npm</h2><h4 id=\"安装npm-1\"><a href=\"#安装npm-1\" class=\"headerlink\" title=\"安装npm\"></a>安装npm</h4><p>Hexo 是一个前端框架，因此 npm 就更是必需的了，相比于 Git，npm 的安装就更简单了，这里同样也给出一个安装教程</p>\n<p><a href=\"https://blog.csdn.net/u011342720/article/details/81267908\">npm的安装与配置</a></p>\n<p>一般情况下，执行到第 5 步，npm 就算安装完成了，如果你的 npm 下载速度太慢或者你有更高的要求的话，可以考虑继续后面的配置</p>\n<hr>\n<h2 id=\"butterfly初体验\"><a href=\"#butterfly初体验\" class=\"headerlink\" title=\"butterfly初体验\"></a>butterfly初体验</h2><h4 id=\"创建-hexo-博客项目\"><a href=\"#创建-hexo-博客项目\" class=\"headerlink\" title=\"创建 hexo 博客项目\"></a>创建 hexo 博客项目</h4><p>butterfly 是 hexo 博客模板的一个主题，要是用 butterfly 主题，需要先创建一个 hexo 博客项目</p>\n<p><strong>安装 hexo</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -g hexo</span><br></pre></td></tr></table></figure>\n\n<p><strong>查看 hexo 版本</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo -v</span><br></pre></td></tr></table></figure>\n\n<p><strong>通过 hexo 创建一个博客项目</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init 项目名</span><br></pre></td></tr></table></figure>\n\n<p><strong>下载项目所需的包</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd 项目名</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h4 id=\"替换博客主题\"><a href=\"#替换博客主题\" class=\"headerlink\" title=\"替换博客主题\"></a>替换博客主题</h4><p>hexo 的默认博客主题是 landscape，我们需要将其替换为我们想要的博客主题</p>\n<p><strong>下载博客主题</strong></p>\n<p>在项目根目录下执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone -b master https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly.git themes&#x2F;butterfly</span><br></pre></td></tr></table></figure>\n\n<p><strong>复制配置文件</strong></p>\n<p>将项目根目录下的 _config.yml 的配置文件复制一份，更名为 _config.butterfly.yml，之后就可以通过修改 _config.butterfly.yml 配置文件来自定义配置了。使用这种方式，不会在更新 Hexo 覆盖配置文件，当两个配置文件的配置冲突时，也会以 _config.butterfly.yml 的为准，此方法只支持 Hexo 5.0.0 及以上版本 </p>\n<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1599311824.jpg\" alt=\"1599311824\"></p>\n<p><strong>修改配置文件</strong></p>\n<p>修改 _config.butterfly.yml 的内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 修改主题</span><br><span class=\"line\">theme: butterfly</span><br><span class=\"line\"># 修改博客项目名</span><br><span class=\"line\">title: Simon的书柜</span><br><span class=\"line\"># 修改作者</span><br><span class=\"line\">author: Simon</span><br><span class=\"line\"># 修改语言为中文</span><br><span class=\"line\">language: zh-CN</span><br><span class=\"line\"># 修改博客顶部背景图</span><br><span class=\"line\">default_top_img: 图片路径</span><br></pre></td></tr></table></figure>\n\n<p><strong>启动项目</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 清除缓存</span><br><span class=\"line\">hexo clean</span><br><span class=\"line\"># 生成静态化页面</span><br><span class=\"line\">hexo g</span><br><span class=\"line\"># 启动项目</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n\n<p>启动完成后，就可以在本地浏览器通过 <a href=\"http://localhost:4000/\">http://localhost:4000/</a> 来访问自己的项目了</p>\n<p>如果页面上出现的是一下内容的话，则需要安装 pug 及 stylus 的渲染器</p>\n<p>extends includes/layout.pug block content include includes/recent-posts.pug include includes/partial</p>\n<p><strong>安装指令</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"将博客部署到Git\"><a href=\"#将博客部署到Git\" class=\"headerlink\" title=\"将博客部署到Git\"></a>将博客部署到Git</h4><p><strong>新建Git仓库</strong></p>\n<p>在 Git 上新建一个名为 <em>用户名.github.io</em> 的仓库，这种方式是最简单的</p>\n<p>或者新建一个任意名称的仓库，然后去设置*里面将 Github Pages 的仓库地址改为该仓库，注意，一个 Git 账户只能有一个 Github Pages</p>\n<p><strong>安装Git插件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>配置文件</strong></p>\n<p>在 _config.butterfly.yml 配置文件中添加以下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https:&#x2F;&#x2F;github.com&#x2F;CK-shadow&#x2F;CK-shadow.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>项目部署</strong></p>\n<p>执行以下指定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g -d</span><br></pre></td></tr></table></figure>\n\n<p>部署完成后，就可以通过 https://用户名.github.io/ 在浏览器上打开你的博客了</p>\n<p><a href=\"https://ck-shadow.github.io/\">Simon的书柜</a></p>\n<h2 id=\"给博客添加标签和分类\"><a href=\"#给博客添加标签和分类\" class=\"headerlink\" title=\"给博客添加标签和分类\"></a>给博客添加标签和分类</h2><h4 id=\"Front-matter\"><a href=\"#Front-matter\" class=\"headerlink\" title=\"Front-matter\"></a>Front-matter</h4><p>我们可以在文章的 Front-matter 添加这篇文章的信息，可添加的内容有很多，一般主要用到的有</p>\n<ul>\n<li><p>title：文章标题（必需）</p>\n</li>\n<li><p>date：文章创建日期（必需）</p>\n</li>\n<li><p>updated：文章更新日期</p>\n</li>\n<li><p>tags：标签</p>\n</li>\n<li><p>categories：分类</p>\n</li>\n<li><p>keywords：关键字</p>\n</li>\n<li><p>description：文章描述</p>\n</li>\n<li><p>top_img：文章顶部图片</p>\n</li>\n<li><p>cover：文章略缩图</p>\n</li>\n</ul>\n<p>除此之外，还以很多其它的可选信息，大家可以去官网查看并添加自己想要的内容</p>\n<hr>\n<h4 id=\"添加标签\"><a href=\"#添加标签\" class=\"headerlink\" title=\"添加标签\"></a>添加标签</h4><p><strong>给文章添加响应的标签内容</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 使用Hexo的butterfly主题搭建一个博客</span><br><span class=\"line\">date: 2020-09-01 13:33:26</span><br><span class=\"line\">tags: Butterfly</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>创建tags文件</strong></p>\n<p>在博客根目录下输入以下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page tags</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>修改文件</strong></p>\n<p>接下来就可以在项目中找到 source/tags/index.md 这个文件了，我们需要在其中添加以下内容</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: 标签</span><br><span class=\"line\">date: 2018-01-05 00:00:00</span><br><span class=\"line\">type: &quot;tags&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p>接下来重启项目，就可以看到自己添加的标签了</p>\n<hr>\n<h4 id=\"添加分类\"><a href=\"#添加分类\" class=\"headerlink\" title=\"添加分类\"></a>添加分类</h4><p><strong>给文章添加响应的分类内容</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 使用Hexo的butterfly主题搭建一个博客</span><br><span class=\"line\">date: 2020-09-01 13:33:26</span><br><span class=\"line\">categories: </span><br><span class=\"line\">  - 博客</span><br></pre></td></tr></table></figure>\n\n<p>文章可以支持多个分类，最终会是层级展示效果，语法为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">categories: </span><br><span class=\"line\">\t- 分类A</span><br><span class=\"line\">\t- 分类B</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>创建 categories 文件</strong></p>\n<p>在博客根目录下输入以下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page categories</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>修改文件</strong></p>\n<p>接下来就可以在项目中找到 source/categories/index.md 这个文件了，我们需要在其中添加以下内容</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: 分类</span><br><span class=\"line\">date: 2018-01-05 00:00:00</span><br><span class=\"line\">type: &quot;categories&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p>接下来重启项目，就可以看到自己添加的标签了</p>\n<hr>\n<h2 id=\"添加顶部导航栏\"><a href=\"#添加顶部导航栏\" class=\"headerlink\" title=\"添加顶部导航栏\"></a>添加顶部导航栏</h2><p>在 _config.butterfly.yml 中添加以下配置内容，重启项目，就可以在博客顶部看到添加的导航栏了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  首页: &#x2F; || fas fa-home</span><br><span class=\"line\">  时间轴: &#x2F;archives&#x2F; || fas fa-archive</span><br><span class=\"line\">  标签: &#x2F;tags&#x2F; || fas fa-tags</span><br><span class=\"line\">  分类: &#x2F;categories&#x2F; || fas fa-folder-open</span><br><span class=\"line\">  清单 ||fa fa-heartbeat:</span><br><span class=\"line\">    - 音乐 || &#x2F;music&#x2F; || fas fa-music</span><br><span class=\"line\">    - 照片 || &#x2F;Gallery&#x2F; || fas fa-images</span><br><span class=\"line\">    - 电影 || &#x2F;movies&#x2F; || fas fa-video</span><br><span class=\"line\">  友链: &#x2F;link&#x2F; || fas fa-link</span><br><span class=\"line\">  关于: &#x2F;about&#x2F; || fas fa-heart</span><br></pre></td></tr></table></figure>\n\n"},{"title":"《浪潮之巅》","date":"2020-09-17T14:57:15.000Z","_content":"","source":"_posts/《浪潮之巅》.md","raw":"---\ntitle: 《浪潮之巅》\ndate: 2020-09-17 22:57:15\ntags:\n---\n","slug":"《浪潮之巅》","published":1,"updated":"2020-09-17T14:57:15.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfa0xrek0000c4v79p14gkai","content":"","site":{"data":{}},"cover":"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/Simple_1366x768_wallpaper_by_PendoX.jpg.pagespeed.ce.QMM6r5k-ZV.jpg","excerpt":"","more":""},{"title":"《淘宝技术这十年》","date":"2020-09-19T00:48:38.000Z","top_img":"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1600538235.jpg","cover":"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1600538235.jpg","_content":"\n\n\n![1600538235](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1600538235.jpg)\n\n\n\n#### 推荐指数：★☆☆☆☆\n\n#### 书评：\n\n《淘宝技术这十年》是阿里巴巴子柳的著作，从书名就可以看出来，主要的核心点有两个，一个是淘宝，另一个就是技术。这本书也是以一个工程师的角度讲述了淘宝的各种变革，全书主要分为了三大部分内容：\n\n* 第一部分 淘宝的技术变更\n\n  这是全部占比最大的一部分内容，讲述了淘宝从最初的 LAMP，到后来的 Java + Oracle，再到初具现代架构模型的分布式和各种自研组件。其中还包含了淘宝成立及发展过程中的一些小插曲\n\n* 第二部分 个人发展部分\n\n  子柳最开始是以一个技术开发人员进入的淘宝，但是后来的职位却是千变万化，从开发人员到项目经理，再到培训负责人等等，这一部分也是讲述了他自己在这一系列岗位中的主要工作内容，这一部分，与技术的关系已经不大了\n\n* 第三部分 大牛访谈\n\n  这一部分是对淘宝里面的一些技术大牛做的一些问答，比如章文嵩博士、吴瀚清等。子柳毕竟不是专业的记者人员，在我看来，这一部分的访谈内容显得有点尴尬。如果你对这些大牛一无所知的话，光看这些访谈的话，可能看完了你都不知道他干了什么；但是如果你对这些大牛有一些了解的话，他们讲的都是各自研究方向的内容，相信我，你很容易就能找到比这部分访谈更具干货的内容\n\n  \n\n我当初看这本书的时候，是想了解技术组件和架构在项目演变过程中是如何逐步升级的。确实了解到了一些，只不过这本书是以宏观角度来讲述的淘宝技术架构变化，真正涉及到我想了解的那部分内容其实并不多。而就一本书而言，如果只能了解的这么一点东西的话，其实就有些不值了\n\n\n\n这本书的第二部分内容讲了子柳转岗之后的工作成就，这部分内容跟技术的关系其实就没那么大了。至于第三部分内容，在我看完了章文嵩博士和吴瀚清的访谈之后，感觉自己仍是懵懵懂懂，还不如我去百度随便找两篇关于这两个人的博客了解的东西来的多，便彻底放弃继续阅读这部分内容了。而这两部分的内容，已经占到了全书一半的内容...\n\n\n\n但是有一说一，这本书的成书时间是 2013 年，当时的互联网资讯还没有现在这么发达，淘宝的一些内幕也还没有公开，因此这本书的很多内容在当时还是很有轰动性的。只不过时代在发展，我们获取知识的渠道和方式也应该有所变化\n\n\n\n最后再吐槽一下子柳的文笔，这本书的在讲述故事的过程中，平平无奇的话语中还透露着些许的不通顺。甚至还有内容重复的部分，第一部分讲过的内容，在第二部分子柳讲述个人发展的时候又重新讲了一遍，我当时看书的时候甚至以为自己看回去了\n\n\n\n总体来说，除非你对淘宝及其感兴趣（不只是技术方面），否则并不推荐购买这本书。想对淘宝有一些了解，找到资源阅读一下还是可以的。至于购买的话，300 多页的书，值得阅读的内容不到 100 页，想来还是有些不值的\n\n\n\n","source":"_posts/《淘宝技术这十年》.md","raw":"---\ntitle: 《淘宝技术这十年》\ndate: 2020-09-19 08:48:38\ntags: 技术相关\ncategories: 技术相关\ntop_img: https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1600538235.jpg\ncover: https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1600538235.jpg\n---\n\n\n\n![1600538235](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1600538235.jpg)\n\n\n\n#### 推荐指数：★☆☆☆☆\n\n#### 书评：\n\n《淘宝技术这十年》是阿里巴巴子柳的著作，从书名就可以看出来，主要的核心点有两个，一个是淘宝，另一个就是技术。这本书也是以一个工程师的角度讲述了淘宝的各种变革，全书主要分为了三大部分内容：\n\n* 第一部分 淘宝的技术变更\n\n  这是全部占比最大的一部分内容，讲述了淘宝从最初的 LAMP，到后来的 Java + Oracle，再到初具现代架构模型的分布式和各种自研组件。其中还包含了淘宝成立及发展过程中的一些小插曲\n\n* 第二部分 个人发展部分\n\n  子柳最开始是以一个技术开发人员进入的淘宝，但是后来的职位却是千变万化，从开发人员到项目经理，再到培训负责人等等，这一部分也是讲述了他自己在这一系列岗位中的主要工作内容，这一部分，与技术的关系已经不大了\n\n* 第三部分 大牛访谈\n\n  这一部分是对淘宝里面的一些技术大牛做的一些问答，比如章文嵩博士、吴瀚清等。子柳毕竟不是专业的记者人员，在我看来，这一部分的访谈内容显得有点尴尬。如果你对这些大牛一无所知的话，光看这些访谈的话，可能看完了你都不知道他干了什么；但是如果你对这些大牛有一些了解的话，他们讲的都是各自研究方向的内容，相信我，你很容易就能找到比这部分访谈更具干货的内容\n\n  \n\n我当初看这本书的时候，是想了解技术组件和架构在项目演变过程中是如何逐步升级的。确实了解到了一些，只不过这本书是以宏观角度来讲述的淘宝技术架构变化，真正涉及到我想了解的那部分内容其实并不多。而就一本书而言，如果只能了解的这么一点东西的话，其实就有些不值了\n\n\n\n这本书的第二部分内容讲了子柳转岗之后的工作成就，这部分内容跟技术的关系其实就没那么大了。至于第三部分内容，在我看完了章文嵩博士和吴瀚清的访谈之后，感觉自己仍是懵懵懂懂，还不如我去百度随便找两篇关于这两个人的博客了解的东西来的多，便彻底放弃继续阅读这部分内容了。而这两部分的内容，已经占到了全书一半的内容...\n\n\n\n但是有一说一，这本书的成书时间是 2013 年，当时的互联网资讯还没有现在这么发达，淘宝的一些内幕也还没有公开，因此这本书的很多内容在当时还是很有轰动性的。只不过时代在发展，我们获取知识的渠道和方式也应该有所变化\n\n\n\n最后再吐槽一下子柳的文笔，这本书的在讲述故事的过程中，平平无奇的话语中还透露着些许的不通顺。甚至还有内容重复的部分，第一部分讲过的内容，在第二部分子柳讲述个人发展的时候又重新讲了一遍，我当时看书的时候甚至以为自己看回去了\n\n\n\n总体来说，除非你对淘宝及其感兴趣（不只是技术方面），否则并不推荐购买这本书。想对淘宝有一些了解，找到资源阅读一下还是可以的。至于购买的话，300 多页的书，值得阅读的内容不到 100 页，想来还是有些不值的\n\n\n\n","slug":"《淘宝技术这十年》","published":1,"updated":"2020-09-19T18:46:52.778Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfa0xrer0001c4v7hhwn0tfb","content":"<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1600538235.jpg\" alt=\"1600538235\"></p>\n<h4 id=\"推荐指数：★☆☆☆☆\"><a href=\"#推荐指数：★☆☆☆☆\" class=\"headerlink\" title=\"推荐指数：★☆☆☆☆\"></a>推荐指数：★☆☆☆☆</h4><h4 id=\"书评：\"><a href=\"#书评：\" class=\"headerlink\" title=\"书评：\"></a>书评：</h4><p>《淘宝技术这十年》是阿里巴巴子柳的著作，从书名就可以看出来，主要的核心点有两个，一个是淘宝，另一个就是技术。这本书也是以一个工程师的角度讲述了淘宝的各种变革，全书主要分为了三大部分内容：</p>\n<ul>\n<li><p>第一部分 淘宝的技术变更</p>\n<p>这是全部占比最大的一部分内容，讲述了淘宝从最初的 LAMP，到后来的 Java + Oracle，再到初具现代架构模型的分布式和各种自研组件。其中还包含了淘宝成立及发展过程中的一些小插曲</p>\n</li>\n<li><p>第二部分 个人发展部分</p>\n<p>子柳最开始是以一个技术开发人员进入的淘宝，但是后来的职位却是千变万化，从开发人员到项目经理，再到培训负责人等等，这一部分也是讲述了他自己在这一系列岗位中的主要工作内容，这一部分，与技术的关系已经不大了</p>\n</li>\n<li><p>第三部分 大牛访谈</p>\n<p>这一部分是对淘宝里面的一些技术大牛做的一些问答，比如章文嵩博士、吴瀚清等。子柳毕竟不是专业的记者人员，在我看来，这一部分的访谈内容显得有点尴尬。如果你对这些大牛一无所知的话，光看这些访谈的话，可能看完了你都不知道他干了什么；但是如果你对这些大牛有一些了解的话，他们讲的都是各自研究方向的内容，相信我，你很容易就能找到比这部分访谈更具干货的内容</p>\n</li>\n</ul>\n<p>我当初看这本书的时候，是想了解技术组件和架构在项目演变过程中是如何逐步升级的。确实了解到了一些，只不过这本书是以宏观角度来讲述的淘宝技术架构变化，真正涉及到我想了解的那部分内容其实并不多。而就一本书而言，如果只能了解的这么一点东西的话，其实就有些不值了</p>\n<p>这本书的第二部分内容讲了子柳转岗之后的工作成就，这部分内容跟技术的关系其实就没那么大了。至于第三部分内容，在我看完了章文嵩博士和吴瀚清的访谈之后，感觉自己仍是懵懵懂懂，还不如我去百度随便找两篇关于这两个人的博客了解的东西来的多，便彻底放弃继续阅读这部分内容了。而这两部分的内容，已经占到了全书一半的内容…</p>\n<p>但是有一说一，这本书的成书时间是 2013 年，当时的互联网资讯还没有现在这么发达，淘宝的一些内幕也还没有公开，因此这本书的很多内容在当时还是很有轰动性的。只不过时代在发展，我们获取知识的渠道和方式也应该有所变化</p>\n<p>最后再吐槽一下子柳的文笔，这本书的在讲述故事的过程中，平平无奇的话语中还透露着些许的不通顺。甚至还有内容重复的部分，第一部分讲过的内容，在第二部分子柳讲述个人发展的时候又重新讲了一遍，我当时看书的时候甚至以为自己看回去了</p>\n<p>总体来说，除非你对淘宝及其感兴趣（不只是技术方面），否则并不推荐购买这本书。想对淘宝有一些了解，找到资源阅读一下还是可以的。至于购买的话，300 多页的书，值得阅读的内容不到 100 页，想来还是有些不值的</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1600538235.jpg\" alt=\"1600538235\"></p>\n<h4 id=\"推荐指数：★☆☆☆☆\"><a href=\"#推荐指数：★☆☆☆☆\" class=\"headerlink\" title=\"推荐指数：★☆☆☆☆\"></a>推荐指数：★☆☆☆☆</h4><h4 id=\"书评：\"><a href=\"#书评：\" class=\"headerlink\" title=\"书评：\"></a>书评：</h4><p>《淘宝技术这十年》是阿里巴巴子柳的著作，从书名就可以看出来，主要的核心点有两个，一个是淘宝，另一个就是技术。这本书也是以一个工程师的角度讲述了淘宝的各种变革，全书主要分为了三大部分内容：</p>\n<ul>\n<li><p>第一部分 淘宝的技术变更</p>\n<p>这是全部占比最大的一部分内容，讲述了淘宝从最初的 LAMP，到后来的 Java + Oracle，再到初具现代架构模型的分布式和各种自研组件。其中还包含了淘宝成立及发展过程中的一些小插曲</p>\n</li>\n<li><p>第二部分 个人发展部分</p>\n<p>子柳最开始是以一个技术开发人员进入的淘宝，但是后来的职位却是千变万化，从开发人员到项目经理，再到培训负责人等等，这一部分也是讲述了他自己在这一系列岗位中的主要工作内容，这一部分，与技术的关系已经不大了</p>\n</li>\n<li><p>第三部分 大牛访谈</p>\n<p>这一部分是对淘宝里面的一些技术大牛做的一些问答，比如章文嵩博士、吴瀚清等。子柳毕竟不是专业的记者人员，在我看来，这一部分的访谈内容显得有点尴尬。如果你对这些大牛一无所知的话，光看这些访谈的话，可能看完了你都不知道他干了什么；但是如果你对这些大牛有一些了解的话，他们讲的都是各自研究方向的内容，相信我，你很容易就能找到比这部分访谈更具干货的内容</p>\n</li>\n</ul>\n<p>我当初看这本书的时候，是想了解技术组件和架构在项目演变过程中是如何逐步升级的。确实了解到了一些，只不过这本书是以宏观角度来讲述的淘宝技术架构变化，真正涉及到我想了解的那部分内容其实并不多。而就一本书而言，如果只能了解的这么一点东西的话，其实就有些不值了</p>\n<p>这本书的第二部分内容讲了子柳转岗之后的工作成就，这部分内容跟技术的关系其实就没那么大了。至于第三部分内容，在我看完了章文嵩博士和吴瀚清的访谈之后，感觉自己仍是懵懵懂懂，还不如我去百度随便找两篇关于这两个人的博客了解的东西来的多，便彻底放弃继续阅读这部分内容了。而这两部分的内容，已经占到了全书一半的内容…</p>\n<p>但是有一说一，这本书的成书时间是 2013 年，当时的互联网资讯还没有现在这么发达，淘宝的一些内幕也还没有公开，因此这本书的很多内容在当时还是很有轰动性的。只不过时代在发展，我们获取知识的渠道和方式也应该有所变化</p>\n<p>最后再吐槽一下子柳的文笔，这本书的在讲述故事的过程中，平平无奇的话语中还透露着些许的不通顺。甚至还有内容重复的部分，第一部分讲过的内容，在第二部分子柳讲述个人发展的时候又重新讲了一遍，我当时看书的时候甚至以为自己看回去了</p>\n<p>总体来说，除非你对淘宝及其感兴趣（不只是技术方面），否则并不推荐购买这本书。想对淘宝有一些了解，找到资源阅读一下还是可以的。至于购买的话，300 多页的书，值得阅读的内容不到 100 页，想来还是有些不值的</p>\n"},{"title":"《计算机组成原理》","date":"2020-09-15T15:23:13.000Z","_content":"\n![img](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1240)\n\nhttps://www.bilibili.com/video/BV1ix41137Eu?from=search&seid=17192528101127840792\n\n# 计算机系统简介\n\n\n\n### 计算机软硬件的概念\n\n\n\n#### 计算机系统\n```mermaid\ngraph LR\n计算机系统--> 硬件_计算机的实体\n计算机系统--> 软件_由各类功能特殊的程序组成\n软件_由各类功能特殊的程序组成-->系统软件_用来管理整个计算机系统\n系统软件_用来管理整个计算机系统-->语言处理程序\n系统软件_用来管理整个计算机系统-->操作系统\n系统软件_用来管理整个计算机系统-->服务性程序\n系统软件_用来管理整个计算机系统-->数据库管理系统\n系统软件_用来管理整个计算机系统-->网络软件\n软件_由各类功能特殊的程序组成-->应用软件_按任务需要编制成的各种程序\n```\n\n------\n\n\n\n#### 计算机系统的层次结构\n\n![image-20200711201924842](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200711201924842.png)\n\n\n\n第0级：硬联逻辑级，这是计算机的内核，由门、触发器等逻辑电路组成  \n第1级：微程序级，这级的机器语言是微指令集，程序员用微指令编写的微程序，一般是直接由硬件执行的\n第2级：传统机器级，这级的机器语言是该级的指令集，程序员用机器指令编写的程序可以由微程序进行解释\n第3级：操作系统级，从操作系统的基本功能来看，一方面它要直接管理传统机器中的软硬件资源，另一方面它又是传统机器的延伸\n第4级：汇编语言级，这级的机器语言是汇编语言，完成汇编语言翻译的程序叫做汇编程序\n第5级：高级语言级，这级的机器语言就是各种高级语言，通常用编译程序来完成高级语言翻译的工作\n\n\n\n| 分类           | 主要工作                                                     | 示例             |\n| -------------- | ------------------------------------------------------------ | ---------------- |\n| 计算机体系结构 | 程序员所见到的计算机系统的属性、概念性的结构与功能特性（指令系统、数据类型、寻址技术、IO机理等） | 有无乘法指令     |\n| 计算机组成     | 实现计算机体系结构所体现的属性（具体指令的实现）             | 如何实现乘法指令 |\n\n------\n\n\n\n### 计算机的基本组成\n\n#### 冯·诺依曼计算机的特点\n\n\n\n1. 计算机由五大部分组成（运算器、存储器、控制器、输入设备和输出设备）\n2. 指令和数据以同等地位存于存储器，可按地址寻访\n3. 指令和数据用二进制表示\n4. 指令由操作码和地址码组成\n5. 存储程序\n6. 以运算器为中心\n\n------\n\n\n\n#### 冯·诺依曼计算机硬件框图\n```mermaid\ngraph LR\n硬件组成--> 运算器\n硬件组成--> 控制器\n硬件组成--> 存储器\n硬件组成--> 输入设备\n硬件组成--> 输出设备\n运算器 --> 算数运算,逻辑运算 \n控制器 --> 指挥程序运行\n存储器 --> 存放数据和程序\n输入设备 --> 将信息转化为机器能识别的形式\n输出设备 --> 将结果转化为人们熟悉的形式\n```\n\n\n\n早期的冯·诺依曼计算机是以运算器为核心的\n\n\n\n![image-20200711201945973](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200711201945973.png)\n\n------\n\n\n\n#### 现代计算机硬件框图\n\n```mermaid\ngraph LR\n硬件 --> 主机\n硬件 --> IO设备\n主机 --> CPU\n主机 --> 存储器\nCPU --> 运算器\nCPU --> 控制器\n存储器 --> 主存\n存储器 --> 辅存\nIO设备 --> 输入设备\nIO设备 --> 输出设备\n```\n\n\n\n现代的计算机以存储器为核心，可将一些不常用的数据放于存储器而不是运算器中，减小CPU的负载\n\n\n\n![image-20200711201959634](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200711201959634.png)\n\n------\n\n\n\n### 计算机的解题过程\n\n\n\n#### 存储器的基本组成\n\n\n\n![image-20200712123424898](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200712123424898.png)\n\n\n\n存储体是由存储单元构成，而存储单元是由一个个的存储元件构成，存储元件中则保存着0或1的信息\n\n存储单元：存放一串二进制代码\n\n存储字：存储单元中二进制代码的组合\n\n存储字长：存储单元中二进制代码的位数，每个存储单元赋予一个地址，存储单元是按地址寻访的\n\n------\n\n\n\n#### 运算器的基本组成\n\n![image-20200712233611705](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200712233611705.png)\n\n\n\nALU：算术逻辑单元\n\nACC：累加器\n\nMQ：乘商寄存器\n\nX:累加寄存器\n\n------\n\n\n\n#### 计算机硬件的主要技术指标\n\n\n\n1. 机器字长\nCPU一次能处理数据的位数，与CPU中的寄存器位数有关\n\n2. 运算速度\n$$\n\\begin{cases}\n主频 \\\\ \n核数，每个核支持的线程数 \\\\ \n吉普森法 \\\\\nCPI，执行一条指令所需的时钟周期数 \\\\\nMIPS，每秒执行百万条指令 \\\\\nFLOPS，每秒浮点运算次数\n\\end{cases}\n$$\n\n3. 存储容量\n\n   存放二进制信息的位数，主存容量+辅存容量\n   \n   ------\n   \n   ****","source":"_posts/《计算机组成原理》.md","raw":"---\ntitle: 《计算机组成原理》\ndate: 2020-09-15 23:23:13\ntags: 计算机组成原理\ncategories: \n    - 计算机组成\n---\n\n![img](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1240)\n\nhttps://www.bilibili.com/video/BV1ix41137Eu?from=search&seid=17192528101127840792\n\n# 计算机系统简介\n\n\n\n### 计算机软硬件的概念\n\n\n\n#### 计算机系统\n```mermaid\ngraph LR\n计算机系统--> 硬件_计算机的实体\n计算机系统--> 软件_由各类功能特殊的程序组成\n软件_由各类功能特殊的程序组成-->系统软件_用来管理整个计算机系统\n系统软件_用来管理整个计算机系统-->语言处理程序\n系统软件_用来管理整个计算机系统-->操作系统\n系统软件_用来管理整个计算机系统-->服务性程序\n系统软件_用来管理整个计算机系统-->数据库管理系统\n系统软件_用来管理整个计算机系统-->网络软件\n软件_由各类功能特殊的程序组成-->应用软件_按任务需要编制成的各种程序\n```\n\n------\n\n\n\n#### 计算机系统的层次结构\n\n![image-20200711201924842](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200711201924842.png)\n\n\n\n第0级：硬联逻辑级，这是计算机的内核，由门、触发器等逻辑电路组成  \n第1级：微程序级，这级的机器语言是微指令集，程序员用微指令编写的微程序，一般是直接由硬件执行的\n第2级：传统机器级，这级的机器语言是该级的指令集，程序员用机器指令编写的程序可以由微程序进行解释\n第3级：操作系统级，从操作系统的基本功能来看，一方面它要直接管理传统机器中的软硬件资源，另一方面它又是传统机器的延伸\n第4级：汇编语言级，这级的机器语言是汇编语言，完成汇编语言翻译的程序叫做汇编程序\n第5级：高级语言级，这级的机器语言就是各种高级语言，通常用编译程序来完成高级语言翻译的工作\n\n\n\n| 分类           | 主要工作                                                     | 示例             |\n| -------------- | ------------------------------------------------------------ | ---------------- |\n| 计算机体系结构 | 程序员所见到的计算机系统的属性、概念性的结构与功能特性（指令系统、数据类型、寻址技术、IO机理等） | 有无乘法指令     |\n| 计算机组成     | 实现计算机体系结构所体现的属性（具体指令的实现）             | 如何实现乘法指令 |\n\n------\n\n\n\n### 计算机的基本组成\n\n#### 冯·诺依曼计算机的特点\n\n\n\n1. 计算机由五大部分组成（运算器、存储器、控制器、输入设备和输出设备）\n2. 指令和数据以同等地位存于存储器，可按地址寻访\n3. 指令和数据用二进制表示\n4. 指令由操作码和地址码组成\n5. 存储程序\n6. 以运算器为中心\n\n------\n\n\n\n#### 冯·诺依曼计算机硬件框图\n```mermaid\ngraph LR\n硬件组成--> 运算器\n硬件组成--> 控制器\n硬件组成--> 存储器\n硬件组成--> 输入设备\n硬件组成--> 输出设备\n运算器 --> 算数运算,逻辑运算 \n控制器 --> 指挥程序运行\n存储器 --> 存放数据和程序\n输入设备 --> 将信息转化为机器能识别的形式\n输出设备 --> 将结果转化为人们熟悉的形式\n```\n\n\n\n早期的冯·诺依曼计算机是以运算器为核心的\n\n\n\n![image-20200711201945973](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200711201945973.png)\n\n------\n\n\n\n#### 现代计算机硬件框图\n\n```mermaid\ngraph LR\n硬件 --> 主机\n硬件 --> IO设备\n主机 --> CPU\n主机 --> 存储器\nCPU --> 运算器\nCPU --> 控制器\n存储器 --> 主存\n存储器 --> 辅存\nIO设备 --> 输入设备\nIO设备 --> 输出设备\n```\n\n\n\n现代的计算机以存储器为核心，可将一些不常用的数据放于存储器而不是运算器中，减小CPU的负载\n\n\n\n![image-20200711201959634](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200711201959634.png)\n\n------\n\n\n\n### 计算机的解题过程\n\n\n\n#### 存储器的基本组成\n\n\n\n![image-20200712123424898](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200712123424898.png)\n\n\n\n存储体是由存储单元构成，而存储单元是由一个个的存储元件构成，存储元件中则保存着0或1的信息\n\n存储单元：存放一串二进制代码\n\n存储字：存储单元中二进制代码的组合\n\n存储字长：存储单元中二进制代码的位数，每个存储单元赋予一个地址，存储单元是按地址寻访的\n\n------\n\n\n\n#### 运算器的基本组成\n\n![image-20200712233611705](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200712233611705.png)\n\n\n\nALU：算术逻辑单元\n\nACC：累加器\n\nMQ：乘商寄存器\n\nX:累加寄存器\n\n------\n\n\n\n#### 计算机硬件的主要技术指标\n\n\n\n1. 机器字长\nCPU一次能处理数据的位数，与CPU中的寄存器位数有关\n\n2. 运算速度\n$$\n\\begin{cases}\n主频 \\\\ \n核数，每个核支持的线程数 \\\\ \n吉普森法 \\\\\nCPI，执行一条指令所需的时钟周期数 \\\\\nMIPS，每秒执行百万条指令 \\\\\nFLOPS，每秒浮点运算次数\n\\end{cases}\n$$\n\n3. 存储容量\n\n   存放二进制信息的位数，主存容量+辅存容量\n   \n   ------\n   \n   ****","slug":"《计算机组成原理》","published":1,"updated":"2020-09-20T08:10:32.940Z","_id":"ckfa0xres0002c4v72ghi4ake","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1240\" alt=\"img\"></p>\n<p><a href=\"https://www.bilibili.com/video/BV1ix41137Eu?from=search&amp;seid=17192528101127840792\">https://www.bilibili.com/video/BV1ix41137Eu?from=search&amp;seid=17192528101127840792</a></p>\n<h1 id=\"计算机系统简介\"><a href=\"#计算机系统简介\" class=\"headerlink\" title=\"计算机系统简介\"></a>计算机系统简介</h1><h3 id=\"计算机软硬件的概念\"><a href=\"#计算机软硬件的概念\" class=\"headerlink\" title=\"计算机软硬件的概念\"></a>计算机软硬件的概念</h3><h4 id=\"计算机系统\"><a href=\"#计算机系统\" class=\"headerlink\" title=\"计算机系统\"></a>计算机系统</h4><pre class=\"mermaid\">graph LR\n计算机系统--> 硬件_计算机的实体\n计算机系统--> 软件_由各类功能特殊的程序组成\n软件_由各类功能特殊的程序组成-->系统软件_用来管理整个计算机系统\n系统软件_用来管理整个计算机系统-->语言处理程序\n系统软件_用来管理整个计算机系统-->操作系统\n系统软件_用来管理整个计算机系统-->服务性程序\n系统软件_用来管理整个计算机系统-->数据库管理系统\n系统软件_用来管理整个计算机系统-->网络软件\n软件_由各类功能特殊的程序组成-->应用软件_按任务需要编制成的各种程序</pre>\n\n<hr>\n<h4 id=\"计算机系统的层次结构\"><a href=\"#计算机系统的层次结构\" class=\"headerlink\" title=\"计算机系统的层次结构\"></a>计算机系统的层次结构</h4><p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200711201924842.png\" alt=\"image-20200711201924842\"></p>\n<p>第0级：硬联逻辑级，这是计算机的内核，由门、触发器等逻辑电路组成<br>第1级：微程序级，这级的机器语言是微指令集，程序员用微指令编写的微程序，一般是直接由硬件执行的<br>第2级：传统机器级，这级的机器语言是该级的指令集，程序员用机器指令编写的程序可以由微程序进行解释<br>第3级：操作系统级，从操作系统的基本功能来看，一方面它要直接管理传统机器中的软硬件资源，另一方面它又是传统机器的延伸<br>第4级：汇编语言级，这级的机器语言是汇编语言，完成汇编语言翻译的程序叫做汇编程序<br>第5级：高级语言级，这级的机器语言就是各种高级语言，通常用编译程序来完成高级语言翻译的工作</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>主要工作</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>计算机体系结构</td>\n<td>程序员所见到的计算机系统的属性、概念性的结构与功能特性（指令系统、数据类型、寻址技术、IO机理等）</td>\n<td>有无乘法指令</td>\n</tr>\n<tr>\n<td>计算机组成</td>\n<td>实现计算机体系结构所体现的属性（具体指令的实现）</td>\n<td>如何实现乘法指令</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"计算机的基本组成\"><a href=\"#计算机的基本组成\" class=\"headerlink\" title=\"计算机的基本组成\"></a>计算机的基本组成</h3><h4 id=\"冯·诺依曼计算机的特点\"><a href=\"#冯·诺依曼计算机的特点\" class=\"headerlink\" title=\"冯·诺依曼计算机的特点\"></a>冯·诺依曼计算机的特点</h4><ol>\n<li>计算机由五大部分组成（运算器、存储器、控制器、输入设备和输出设备）</li>\n<li>指令和数据以同等地位存于存储器，可按地址寻访</li>\n<li>指令和数据用二进制表示</li>\n<li>指令由操作码和地址码组成</li>\n<li>存储程序</li>\n<li>以运算器为中心</li>\n</ol>\n<hr>\n<h4 id=\"冯·诺依曼计算机硬件框图\"><a href=\"#冯·诺依曼计算机硬件框图\" class=\"headerlink\" title=\"冯·诺依曼计算机硬件框图\"></a>冯·诺依曼计算机硬件框图</h4><pre class=\"mermaid\">graph LR\n硬件组成--> 运算器\n硬件组成--> 控制器\n硬件组成--> 存储器\n硬件组成--> 输入设备\n硬件组成--> 输出设备\n运算器 --> 算数运算,逻辑运算 \n控制器 --> 指挥程序运行\n存储器 --> 存放数据和程序\n输入设备 --> 将信息转化为机器能识别的形式\n输出设备 --> 将结果转化为人们熟悉的形式</pre>\n\n\n\n<p>早期的冯·诺依曼计算机是以运算器为核心的</p>\n<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200711201945973.png\" alt=\"image-20200711201945973\"></p>\n<hr>\n<h4 id=\"现代计算机硬件框图\"><a href=\"#现代计算机硬件框图\" class=\"headerlink\" title=\"现代计算机硬件框图\"></a>现代计算机硬件框图</h4><pre class=\"mermaid\">graph LR\n硬件 --> 主机\n硬件 --> IO设备\n主机 --> CPU\n主机 --> 存储器\nCPU --> 运算器\nCPU --> 控制器\n存储器 --> 主存\n存储器 --> 辅存\nIO设备 --> 输入设备\nIO设备 --> 输出设备</pre>\n\n\n\n<p>现代的计算机以存储器为核心，可将一些不常用的数据放于存储器而不是运算器中，减小CPU的负载</p>\n<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200711201959634.png\" alt=\"image-20200711201959634\"></p>\n<hr>\n<h3 id=\"计算机的解题过程\"><a href=\"#计算机的解题过程\" class=\"headerlink\" title=\"计算机的解题过程\"></a>计算机的解题过程</h3><h4 id=\"存储器的基本组成\"><a href=\"#存储器的基本组成\" class=\"headerlink\" title=\"存储器的基本组成\"></a>存储器的基本组成</h4><p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200712123424898.png\" alt=\"image-20200712123424898\"></p>\n<p>存储体是由存储单元构成，而存储单元是由一个个的存储元件构成，存储元件中则保存着0或1的信息</p>\n<p>存储单元：存放一串二进制代码</p>\n<p>存储字：存储单元中二进制代码的组合</p>\n<p>存储字长：存储单元中二进制代码的位数，每个存储单元赋予一个地址，存储单元是按地址寻访的</p>\n<hr>\n<h4 id=\"运算器的基本组成\"><a href=\"#运算器的基本组成\" class=\"headerlink\" title=\"运算器的基本组成\"></a>运算器的基本组成</h4><p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200712233611705.png\" alt=\"image-20200712233611705\"></p>\n<p>ALU：算术逻辑单元</p>\n<p>ACC：累加器</p>\n<p>MQ：乘商寄存器</p>\n<p>X:累加寄存器</p>\n<hr>\n<h4 id=\"计算机硬件的主要技术指标\"><a href=\"#计算机硬件的主要技术指标\" class=\"headerlink\" title=\"计算机硬件的主要技术指标\"></a>计算机硬件的主要技术指标</h4><ol>\n<li><p>机器字长<br>CPU一次能处理数据的位数，与CPU中的寄存器位数有关</p>\n</li>\n<li><p>运算速度<br>$$<br>\\begin{cases}<br>主频 \\<br>核数，每个核支持的线程数 \\<br>吉普森法 \\<br>CPI，执行一条指令所需的时钟周期数 \\<br>MIPS，每秒执行百万条指令 \\<br>FLOPS，每秒浮点运算次数<br>\\end{cases}<br>$$</p>\n</li>\n<li><p>存储容量</p>\n<p>存放二进制信息的位数，主存容量+辅存容量</p>\n<hr>\n<hr>\n</li>\n</ol>\n","site":{"data":{}},"cover":"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/Simple_1366x768_wallpaper_by_PendoX.jpg.pagespeed.ce.QMM6r5k-ZV.jpg","excerpt":"","more":"<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/1240\" alt=\"img\"></p>\n<p><a href=\"https://www.bilibili.com/video/BV1ix41137Eu?from=search&amp;seid=17192528101127840792\">https://www.bilibili.com/video/BV1ix41137Eu?from=search&amp;seid=17192528101127840792</a></p>\n<h1 id=\"计算机系统简介\"><a href=\"#计算机系统简介\" class=\"headerlink\" title=\"计算机系统简介\"></a>计算机系统简介</h1><h3 id=\"计算机软硬件的概念\"><a href=\"#计算机软硬件的概念\" class=\"headerlink\" title=\"计算机软硬件的概念\"></a>计算机软硬件的概念</h3><h4 id=\"计算机系统\"><a href=\"#计算机系统\" class=\"headerlink\" title=\"计算机系统\"></a>计算机系统</h4><pre class=\"mermaid\">graph LR\n计算机系统--> 硬件_计算机的实体\n计算机系统--> 软件_由各类功能特殊的程序组成\n软件_由各类功能特殊的程序组成-->系统软件_用来管理整个计算机系统\n系统软件_用来管理整个计算机系统-->语言处理程序\n系统软件_用来管理整个计算机系统-->操作系统\n系统软件_用来管理整个计算机系统-->服务性程序\n系统软件_用来管理整个计算机系统-->数据库管理系统\n系统软件_用来管理整个计算机系统-->网络软件\n软件_由各类功能特殊的程序组成-->应用软件_按任务需要编制成的各种程序</pre>\n\n<hr>\n<h4 id=\"计算机系统的层次结构\"><a href=\"#计算机系统的层次结构\" class=\"headerlink\" title=\"计算机系统的层次结构\"></a>计算机系统的层次结构</h4><p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200711201924842.png\" alt=\"image-20200711201924842\"></p>\n<p>第0级：硬联逻辑级，这是计算机的内核，由门、触发器等逻辑电路组成<br>第1级：微程序级，这级的机器语言是微指令集，程序员用微指令编写的微程序，一般是直接由硬件执行的<br>第2级：传统机器级，这级的机器语言是该级的指令集，程序员用机器指令编写的程序可以由微程序进行解释<br>第3级：操作系统级，从操作系统的基本功能来看，一方面它要直接管理传统机器中的软硬件资源，另一方面它又是传统机器的延伸<br>第4级：汇编语言级，这级的机器语言是汇编语言，完成汇编语言翻译的程序叫做汇编程序<br>第5级：高级语言级，这级的机器语言就是各种高级语言，通常用编译程序来完成高级语言翻译的工作</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>主要工作</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>计算机体系结构</td>\n<td>程序员所见到的计算机系统的属性、概念性的结构与功能特性（指令系统、数据类型、寻址技术、IO机理等）</td>\n<td>有无乘法指令</td>\n</tr>\n<tr>\n<td>计算机组成</td>\n<td>实现计算机体系结构所体现的属性（具体指令的实现）</td>\n<td>如何实现乘法指令</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"计算机的基本组成\"><a href=\"#计算机的基本组成\" class=\"headerlink\" title=\"计算机的基本组成\"></a>计算机的基本组成</h3><h4 id=\"冯·诺依曼计算机的特点\"><a href=\"#冯·诺依曼计算机的特点\" class=\"headerlink\" title=\"冯·诺依曼计算机的特点\"></a>冯·诺依曼计算机的特点</h4><ol>\n<li>计算机由五大部分组成（运算器、存储器、控制器、输入设备和输出设备）</li>\n<li>指令和数据以同等地位存于存储器，可按地址寻访</li>\n<li>指令和数据用二进制表示</li>\n<li>指令由操作码和地址码组成</li>\n<li>存储程序</li>\n<li>以运算器为中心</li>\n</ol>\n<hr>\n<h4 id=\"冯·诺依曼计算机硬件框图\"><a href=\"#冯·诺依曼计算机硬件框图\" class=\"headerlink\" title=\"冯·诺依曼计算机硬件框图\"></a>冯·诺依曼计算机硬件框图</h4><pre class=\"mermaid\">graph LR\n硬件组成--> 运算器\n硬件组成--> 控制器\n硬件组成--> 存储器\n硬件组成--> 输入设备\n硬件组成--> 输出设备\n运算器 --> 算数运算,逻辑运算 \n控制器 --> 指挥程序运行\n存储器 --> 存放数据和程序\n输入设备 --> 将信息转化为机器能识别的形式\n输出设备 --> 将结果转化为人们熟悉的形式</pre>\n\n\n\n<p>早期的冯·诺依曼计算机是以运算器为核心的</p>\n<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200711201945973.png\" alt=\"image-20200711201945973\"></p>\n<hr>\n<h4 id=\"现代计算机硬件框图\"><a href=\"#现代计算机硬件框图\" class=\"headerlink\" title=\"现代计算机硬件框图\"></a>现代计算机硬件框图</h4><pre class=\"mermaid\">graph LR\n硬件 --> 主机\n硬件 --> IO设备\n主机 --> CPU\n主机 --> 存储器\nCPU --> 运算器\nCPU --> 控制器\n存储器 --> 主存\n存储器 --> 辅存\nIO设备 --> 输入设备\nIO设备 --> 输出设备</pre>\n\n\n\n<p>现代的计算机以存储器为核心，可将一些不常用的数据放于存储器而不是运算器中，减小CPU的负载</p>\n<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200711201959634.png\" alt=\"image-20200711201959634\"></p>\n<hr>\n<h3 id=\"计算机的解题过程\"><a href=\"#计算机的解题过程\" class=\"headerlink\" title=\"计算机的解题过程\"></a>计算机的解题过程</h3><h4 id=\"存储器的基本组成\"><a href=\"#存储器的基本组成\" class=\"headerlink\" title=\"存储器的基本组成\"></a>存储器的基本组成</h4><p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200712123424898.png\" alt=\"image-20200712123424898\"></p>\n<p>存储体是由存储单元构成，而存储单元是由一个个的存储元件构成，存储元件中则保存着0或1的信息</p>\n<p>存储单元：存放一串二进制代码</p>\n<p>存储字：存储单元中二进制代码的组合</p>\n<p>存储字长：存储单元中二进制代码的位数，每个存储单元赋予一个地址，存储单元是按地址寻访的</p>\n<hr>\n<h4 id=\"运算器的基本组成\"><a href=\"#运算器的基本组成\" class=\"headerlink\" title=\"运算器的基本组成\"></a>运算器的基本组成</h4><p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20200712233611705.png\" alt=\"image-20200712233611705\"></p>\n<p>ALU：算术逻辑单元</p>\n<p>ACC：累加器</p>\n<p>MQ：乘商寄存器</p>\n<p>X:累加寄存器</p>\n<hr>\n<h4 id=\"计算机硬件的主要技术指标\"><a href=\"#计算机硬件的主要技术指标\" class=\"headerlink\" title=\"计算机硬件的主要技术指标\"></a>计算机硬件的主要技术指标</h4><ol>\n<li><p>机器字长<br>CPU一次能处理数据的位数，与CPU中的寄存器位数有关</p>\n</li>\n<li><p>运算速度<br>$$<br>\\begin{cases}<br>主频 \\<br>核数，每个核支持的线程数 \\<br>吉普森法 \\<br>CPI，执行一条指令所需的时钟周期数 \\<br>MIPS，每秒执行百万条指令 \\<br>FLOPS，每秒浮点运算次数<br>\\end{cases}<br>$$</p>\n</li>\n<li><p>存储容量</p>\n<p>存放二进制信息的位数，主存容量+辅存容量</p>\n<hr>\n<hr>\n</li>\n</ol>\n"},{"title":"《Java数据结构与算法》","date":"2020-09-22T15:44:50.000Z","top_img":"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/franki-chamaki-1K6IQsQbizI-unsplash.jpg","cover":"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/franki-chamaki-1K6IQsQbizI-unsplash.jpg","_content":"\n\n\n## 如何区分算法的好坏\n\n### 算法的效率\n\n虽然计算机能快速的完成运算处理，但实际上，它也需要根据输入数据的大小和算法效率来消耗一定的处理器资源。要想编写出能高效运行的程序，我们就需要考虑到算法的效率\n\n\n\n算法的效率主要由以下两个复杂度来评估： \n**时间复杂度**：评估执行程序所需的时间。可以估算出程序对处理器的使用程度\n**空间复杂度**：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度\n\n\n\n设计算法时，一般是要先考虑系统环境，然后权衡时间复杂度和空间复杂度，选取一个平衡点。不过，时间复杂度要比空间复杂度更容易产生问题，因此算法研究的主要也是时间复杂度，不特别说明的情况下，复杂度就是指时间复杂度\n\n\n\n------\n\n\n\n### 时间复杂度\n\n#### 大O表示法\n\n算法的时间复杂度通常用大O符号表述，定义为T[n] = O(f(n))。称函数T(n)以f(n)为界或者称T(n)受限于f(n)。  如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)。T(n)称为这一算法的“时间复杂度”。当输入量n逐渐加大时，时间复杂度的极限情形称为算法的“渐近时间复杂度”\n\n\n\n**推导大O阶**\n\n1. 用常数1来取代运行时间中所有加法常数。 \n2. 修改后的运行次数函数中，只保留最高阶项 \n3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数\n\n\n\n------\n\n\n\n#### 常见时间复杂度\n\n**常数阶**\n\n```java\n// 3行代码均只执行一次\nint sum = 0, a = 1;\nsum = (a + 1) * 2;\nSystem.out.println(sum);\n```\n\n上面算法的运行的次数的函数为 f(n)=3，根据推导大O阶的规则1，我们需要将常数3改为1，则这个算法的时间复杂度为 O(1)。如果 sum = (a + 1) * 2 这条语句再执行10次，这个算法的复杂度仍为 O(1)，因此称之为常数阶\n\n\n\n**线性阶**\n\n```java\nfor(int i=0; i<n; i++) {\n    // 时间复杂度为O(1)的算法\n    ...\n}\n```\n\n上面算法循环体中的代码执行了 n 次，因此这个算法的时间复杂度为 O(n)\n\n\n\n**对数阶**\n\n```java\nint a = 1;\nwhile(a < n) {\n\ta = a * 2;\n\t// 时间复杂度为O(1)的算法\n    ...\n}\n```\n\n上面算法中，随着 a 的每次乘 2，其数值都会越来越接近 n，直到大于 n，那么就将跳出循环。假设这个算法循环了 x 次，那么 2^x = n，可算得 x = logn。因此这个算法得时间复杂度为 O(logn)\n\n\n\n**平方阶**\n\n```java\nfor(int i=0; i<n; i++) {\n\tfor (int j=0; j<n; j++) {\n\t\t // 时间复杂度为O(1)的算法\n    \t...\n\t}\n}\n```\n\n上面算法中，我们已知内层循环得时间复杂度为 O(n)，再经过外层循环 n 次，因此这个算法的时间复杂度为 O(n²)\n\n\n\n如果我们算得某个算法的时间复杂度为 f(n) = 5n³ + 3n + 2，那么根据推导大O阶的第二条规则，只保留最高阶，那么这个算法的时间复杂度就变成了 f(n) = 5n³，再根据推导大O阶的第三条规则，去掉常数项，因此这个算法最终算得的时间复杂度应该是 O(n³)\n\n\n\n------\n\n\n\n#### 其它常见时间复杂度\n\n除了常数阶、线性阶、平方阶、对数阶，还有如下时间复杂度\n\n* f(n) = nlogn 时，时间复杂度为 O(nlogn)，称为 nlogn 阶\n* f(n) = n³ 时，时间复杂度为 O(n³)，称为立方阶\n* f(n) = 2ⁿ 时，时间复杂度为 O(2ⁿ)，称为指数阶\n* f(n) = n! 时，时间复杂度为 O(n!)，称为阶乘阶\n* f(n) = √n 时，时间复杂度为 O(√n)，称为平方根阶\n\n\n\n------\n\n\n\n#### 时间复杂度的比较\n\n![image-20201103001513219](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201103001513219.png)\n\n\n\n在上图中，X 轴代表 n 值，Y 轴代表时间复杂度。时间复杂度随着 n 值得变化而变化，可以看到，O(n)、O(logn)、O(√n )、O(nlogn )随着 n 的增加，复杂度提升不大，而 O(2ⁿ) 和 O(n!)  在 n 值较大时变化非常之大。实际上，在 n 等于 50 时，O(2ⁿ) 和 O(n!)  的复杂度就已经突破十位数了\n\n\n\n常用的时间复杂度按照耗费的时间从小到大依次是：\n\nO(1) < O(logn) < O(n) < O(nlogn) < O(n²) < O(n³) < O(2ⁿ) < O(n!)\n\n\n\n------\n\n\n\n## 数组\n\n### 数组的概念\n\n\n\n![image-20201104232327992](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201104232327992.png)\n\n\n\n定义：数组（Array）是一种线性表数据结构，他用一组连续的内存空间，来存储一组具有相同类型的数据\n\n\n\n1. 线性表\n\n   所谓线性表，指的是每个元素最多只有前后两个方向，像一条线一样进行排列，除了数组，链表、队列、栈等都是线性表\n\n2. 连续的内存空间和相同类型的数据\n\n\n\n正是因为这两点，才使得数组拥有了它的核心特性 -- 随机访问\n\n\n\n**随机访问**\n\n所谓随机访问，指的是能够随意访问数组中的任意一个元素，比如我想访问第 n 个元素，那么该元素的起始位置就是：\n\n​\t\t第 n 个元素的起始位置 = 第 1 个元素的起始位置  + 下标（从0开始）* 元素的长度\n\n而不是从第 1 个元素开始，依次访问第 2 个、第 3个 ...，直到访问到第 n 个为止\n\n\n\n------\n\n### 数组的操作\n\n\n\n* 数组支持随机访问，根据下标获取指定元素的时间复杂度为 O(1)\n* 如果想获取数组中指定某个值的元素的话，时间复杂度就变成了 O(n)；如果是有序数组的话，使用二分法，可以将时间复杂度将为 O(logn)\n* 数组为了保证内存数据的连续性，会导致插入、删除这两个操作比较低效\n\n\n\n#### 数组的插入\n\n1. 从头部和中间插入\n   * 如果是无序数组的话，最简单的插入方式是将要插入的第 k 个位置的元素移到最末尾，然后将新元素放入第 k 个位置，这种插入方法的时间复杂度为 O(1)\n   * 如果是有序数组的话，向第 k 个位置插入元素，那么位置 k 后的所有元素都需要向后移动一位，这种情况下最坏的时间复杂度可达到 O(n)\n2. 从尾部插入\n   * 从尾部插入数据的话只需要直接在数据末尾添加一个元素即可，不需要移动其它元素，时间复杂度为 O(1)\n\n\n\n#### 数组的删除\n\n1. 删除头部和中间元素\n   * 为了保证数组中数据的连续性，数组中间的第 k 个元素删除之后，位置 k 之后的所有元素都需要向前移动一位，最坏时间复杂度为 O(n)\n2. 删除尾部元素\n   * 删除尾部元素不需要移动元素，只需要将末尾元素删除即可，时间复杂度为 O(1)\n\n\n\n------\n\n### ArrayList\n\n#### 介绍\n\n\n\n在 Java 中，我们可以自己创建并维护一个数组，也可以使用 Java 提供的数组容器类 ArrayList。相比于自建数组，ArrayList 提供了一些高级功能，比如自动扩容、泛型、更方便的处理元素等等\n\n\n\n在我们使用数组时，除非已知数组的所有元素并且几乎不再更改，否则都会使用 ArrayList 来进行数组的相关操作\n\n\n\nArrayList 并不是线程安全的，如果我们想要保障 ArrayList 的线程安全，需要自己使用 Synchronized 关键字维护，或者调用 Collections.synchronizedList() 方法，获得一个线程安全的 ArryList，或者直接使用 JUC 包中的 CopyOnWriteArrayList\n\n\n\nArrayList 继承了 RandomAccess 接口，进入这个接口会发现 RandomAccess 接口中并无任何的变量或方法。事实上，这是一个“标志”接口，标志这 ArrayList 这个类具备随机访问的特性\n\n\n\n------\n\n#### 主要的成员变量\n\n\n\n```java\n/**\n * Default initial capacity.\n */\n private static final int DEFAULT_CAPACITY = 10;\n```\n\nArrayList 的初始数组长度为 10\n\n\n\n------\n\n#### 构造方法\n\n\n\n![image-20201107180130865](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201107180130865.png)\n\n* 无参构造方法\n\n  返回一个空数组，在第一次往数组里添加元素的时候才赋予数组长度，初始长度为 0\n\n* int 类型参数构造方法\n\n  返回一个指定长度的数组，入参为 0 的时候返回一个空数组，与无参构造方法类似，入参小于 0 则抛出异常\n\n* Collection 类型参数构造方法\n\n  传入一个 Collection 集合，将该集合转为 ArrayList 数组\n\n\n\n------\n\n####   扩容机制\n\n\n\n调用 ArrayList 的 add() 方法时，ArrayList 都会先判断一下当前数组是否已满，如果已经满了的话，就会调用 grow() 方法进行扩容\n\n\n\n```java\nprivate Object[] grow(int minCapacity) {\n     int oldCapacity = elementData.length;\n     if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n         int newCapacity = ArraysSupport.newLength(oldCapacity,\n                minCapacity - oldCapacity, /* minimum growth */\n                oldCapacity >> 1           /* preferred growth */);\n        return elementData = Arrays.copyOf(elementData, newCapacity);\n    } else {\n        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];\n    }\n}\n```\n\n\n\nadd() 方法在调用 grow() 方法时，传入的 minCapacity 的值为 size+1，但是 ArraysSupport.newLength() 会判断 minCapacity 的值和 oldCapacity >> 1（即原数组长度的一半）哪个更大，原数组长度加上两者之间的大者即为扩容后的新数组的长度。因此通常情况下扩容后的容量为原容量的 1.5 倍\n\n\n\n**自动扩容带来的问题**\n\n数字的自动扩容会带来一些空间资源的浪费，有时候只是想往数组中添加一个元素，长度加 1 即可，但是却让数组长度变成了原来的 1.5倍。在数组长度较小的时候，些许的浪费无伤大雅，但是当数据量较大时，带来的资源浪费就显得没必要了\n\n\n\n**解决方法**\n\n* 如果在创建数组时便知道数组的长度，就可以使用 ArrayList 的 int 类型参数构造方法来创建一个指定长度的数组了\n* 如果在创建数组的时候并不知道数组的长度，但是在插入数组的时候知道了，那么可以使用 ensureCapacity() 方法来将数组扩容到想要的长度\n* 还可以在数组插入完成之后，调用 trimToSize() 方法，将数组多余的长度清空掉\n\n\n\n------\n\n#### 迭代器\n\n\n\n迭代器 Iterator 是一种设计模式，所有的 Collections 集合类都有实现这种设计模式，为得是提供一套统一的 API 来操作元素\n\n\n\n迭代器有两种属性，fail-fast 和 fail-safe\n\n* fail-fast\n\n  ArrayList 会维护一个 modCount 变量，每次对数组的增删改操作都会将 modCount 加 1。迭代器在遍历元素时直接获取原有集合的内容，在操作过程中如果发现 modCount 的值发生了变化，就会抛出异常\n\n* fail-safe\n\n  迭代器在遍历元素时，会将原有集合复制出来一份，然后在复制出来的这个集合上进行操作。这样做避免了抛出异常，但是原有集合上的操作并不能被迭代器检测到\n  \n  \n\n------\n\n## 链表\n\n### 链表的概念\n\n\n\n数组是使用最广泛的一种通用数据结构，但是也不可避免的存在着一些缺陷。在无序数组中，搜索是低效的；而在有序数组中，插入效率又很低；而不管再哪一种数组中，删除效率都很低；并且一个数组在创建后，它的大小是不可改变的。而链表则可以解决上面的一些问题\n\n\n\n链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。每个元素节点除了存储自己的数据域之外，还存储着下一个节点的指针域\n\n\n\n![image-20201110211256134](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201110211256134.png)\n\n\n\n链表需通过头元素一个一个遍历才能找到目标元素，不支持随机访问。但是链表的增删操作只需要改变节点的指针域即可，不需要移动元素，增删速度较快。除非需要频繁通过下标访问元素，否则很多使用数组的地方都可以使用链表代替。而链表也是除数组外运用第二广泛的通用数据结构\n\n\n\n------\n\n### 链表的操作\n\n#### 链表的基本结构\n\n\n\n链表作为一个集合，首先需要知道头节点的位置，否则即使查询也不知道从何查起。而集合中存储着一系列的节点，这些节点既需要保存着自己的数据域，还需要保存着下一个节点的位置\n\n\n\n```java\npublic class LinkList {\n    // 头节点\n    private Link fisrt;\n    \n    class Link {\n        // 指向下一个节点\n        private Link next;\n        // 数据域\n        private Object data;\n    }\n    ...\n}\n```\n\n\n\n这是一个链表最基本的组成，还可以通过添加其它属性和方法来丰富这个链表，比如添加 size 属性，获得这个链表的长度；还可添加 Link last 属性，来更快的找到尾节点等等\n\n\n\n------\n\n#### 链表的查询\n\n\n\n不管是查询指定值的节点，还是查询第 k 个元素，链表都需要从头节点一个个遍历，因此链表查询的时间复杂度固定为 O(n)\n\n\n\n------\n\n#### 链表的插入和删除\n\n\n\n链表删除节点 k，只需要将节点 k-1 的指针域执行节点 k+1 即可，时间复杂度为 O(1)\n\n```java\npublic void remove(Link removeLink) {\n    // 获取被删除节点的上一个节点\n    Link preLink = removeLink.pre;\n    // 将上一个节点的指针域只想被删除节点的下一个节点\n    preLink.next = removeLink.next;\n}\n```\n\n\n\n链表想在节点 k 和 k+1 之间插入一个元素，需要将节点 k 的指针域指向插入的节点，然后将插入节点的指针域指向节点 k+1，时间复杂度为 O(1)\n\n```java\npublic void insert(Link preLink, Link insertLink) {\n    // preLink为节点k，通过节点k获取节点k+1\n    Link afterLink = preLink.next;\n    // 将节点k的指针域指向插入的节点\n    preLink.next = insertLink;\n    // 将插入节点的指针域指向节点k+1\n    insertLink.next = afterLink;\n}\n```\n\n\n\n------\n\n### 不同类型的链表\n\n\n\n* 单向链表\n\n  像上面这样只能从上一个节点获取下一个节点的链表，称为单项链表\n\n* 双向链表\n\n  如果链表中的节点不仅存储着下一个节点的指针域，还存储着上一个节点的指针域，这种链表称为双向链表\n\n* 循环链表\n\n  链表的尾节点又重新指向头节点，形成了一个圈，这种链表称为循环链表\n\n\n\n------\n\n### LinkedList\n\n#### 主要的成员变量\n\n\n\n```java\ntransient int size = 0;\n\n/**\n * Pointer to first node.\n */\ntransient Node<E> first;\n\n/**\n * Pointer to last node.\n */\ntransient Node<E> last;\n```\n\n\n\nLinkedList 只有三个成员变量，size 用于记录集合中的元素个数，first 和 last 分别指向头节点和尾节点\n\n\n\n#### Node节点元素\n\n\n\n```java\nprivate static class Node<E> {\n    E item;\n    Node<E> next;\n    Node<E> prev;\n\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\n\n\n可以看出，LinkedList 的节点元素既可以指向上一个元素，也可以指向下一个元素，所以 LinkedList 是一个双向链表\n\n\n\n------\n\n#### 构造方法\n\n\n\n**无参构造方法**\n\n```java\npublic LinkedList() {\n}\n```\n\nJava 15 中，LinkedList 的无参构造方法会返回一个空集合，头节点和尾节点都是 null\n\n\n\n**有参构造方法**\n\n```java\npublic LinkedList(Collection<? extends E> c) {\n    this();\n    addAll(c);\n}\n```\n\nLinkedList 的有参构造方法可以传入一个集合，将这个集合转为 LinkedList\n\n\n\n相比与 ArrayList，LinkedList 无须扩容，新增和删除的实现方式也比较简单\n\n\n\n------\n\n## 栈和队列\n\n### 抽象数据类型（ADT）\n\n\n\n抽象数据类型（Abstract Data Type，ADT）是带有一组操作的一些对象的集合。抽象数据类型是数学的抽象，在 ADT 的定义中没有地方提到关于这组操作是如何实现的具体解释。比如我们定义了线性表（List）这么一个 ADT，要求元素像一条线一样只有前后两个方向排列，那么只要满足了这个要求的，都可以看作线性表 ADT 的具体实现\n\n\n\nJava 也考虑了 ADT 的实现，不过适当了隐藏了实现的细节。最直观的方式就是“接口”，Java 中有 List 接口，只有实现了这个接口的类，都是 List 的具体实现类，例如 ArrayList、LinkedList，还有后续的 Deque、Stack等，都可以看作一个List。而在 Java 中，这就是对象多态的体现\n\n\n\n```java\npublic static void main(String[] args) {\n\n    List<String> list1 = new ArrayList<>();\n    List<String> list2 = new LinkedList<>();\n        \n    list1.add(\"list1\");\n    list2.add(\"list2\");\n\n}\n```\n\n如上所示，我们可以只需要获得一个 List集合，然后支持 List 集合的方法即可，而不关系它究竟是 ArrayList 还是 LinkedList\n\n\n\n\n\n![image-20201115151509347](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201115151509347.png)\n\n**此图只是对ADT的简单展示，Java中数据结构中的层次远比这个复杂得多**\n\n\n\n不同的 ADT 之间也有着不同的关系，如上图所示，可以有层级关系，如 List 和 Queue 之间；也有并列关系，如 List 和 Map 之间；还有可能什么关系也没有。我们可以根据自己的需求去选用合适的 ADT 实现类，如果我们想要个 List 集合的话，就去找一个实现了 List 集合接口的类；如果想要个 Queue 的话，就去找一个实现了 Queue 接口的类；如果当前存在的都不满足需求的话，我们也可以自己实现一个，只要实现了对应的 ADT 接口即可\n\n\n\n------\n\n\n\n### 栈ADT\n\n#### 栈模型\n\n\n\n栈（Stack）是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈的顶（top）。对栈的基本操作有 push（进栈）和 pop（出栈），前者相当于插入，后者则是删除最后插入的元素。最后插入的元素可以通过 top 例程在执行 pop 之前进行考察。对空栈进行 top 或 pop 操作一般被认为栈 ADT 中的一个错误。另一方面，当运行 push 时空间用尽是一个实现限制，但不是 ADT 错误\n\n\n\n栈有时又叫做 LIFO（后进先出）表。普通的清空栈的操作和判断是否空栈的操作都是栈的操作系统指令的一部分。但是，我们对栈所能够做的，基本上也就是 pop 和 push 操作\n\n\n\n![image-20201115170259354](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201115170259354.png)\n\n![image-20201115170423180](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201115170423180.png)\n\n\n\n------\n\n### 队列ADT\n\n#### 队列模型\n\n\n\n像栈一样，队列也是表。但是，使用队列时插入在一段进行而删除则在另一端进行\n\n\n\n队列的基本操作是 enqueue（入队），它是在表的末端（叫做队尾 rear）插入一个元素；以及 dequeue（出队），它是返回并删除在表开头（叫做对头 front）的元素。队列，也叫做 FIFO（先进先出）表\n\n\n\n![image-20201115195545751](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201115195545751.png)\n\n\n\n------\n\n### 栈的具体实现\n\n#### 栈的实现\n\n\n\n由于栈是一个表，因此任何实现表的方法都能实现栈。显然，ArrayList 和 LinkedList 都支持栈操作，99% 的时间它们都是最合理的选择。偶尔设计一种特殊目的的实现可能会更快。因为栈操作的时间复杂度为 O(1)，所以，除非在非常独特的环境下，这是不可能产生任何明显的改进的。对于这些特殊的时机，一般给出了两种流行的实现方法，一种方法使用链式结构，而另一种方法使用数组，二者均简化了在 ArrayList 和 LinkedList 中的逻辑\n\n\n\n------\n\n#### 栈的链式实现\n\n\n\n栈的第一种实现方法是使用单链表，通过在表的顶端插入来实现 push，通过删除表顶端元素来实现 pop。top 操作只是考查表顶端元素并返回它的值，有时 pop 操作和 top操作合二为一\n\n\n\n------\n\n#### 栈的数组实现\n\n\n\n另一种方式避免了链并且可能是更流行的解决方案。由于模仿 ArrayList 的 add 操作，因此相应的实现方式非常简单。与每个栈相关联的操作是 theArray 和 topOfStack，对于空栈它是 -1，这就是空栈初始化的做法。为将某个元素 x 推入栈中，我们是 topOfStack 增 1 然后置 theArray[topOfStack] = x。为了弹出栈元素，我们置返回值为 theArray[topOfStack] 然后使 topOfStack 减 1\n\n\n\n注意，这些操作不仅以常数时间运行，而且是以非常快的常数时间运行。在某些机器上，若在带有自增和自减寻址功能的寄存器上操作，则（整数的）pop 和 push 都可以写成一条机器指令。最现代化的计算机将栈操作作为它指令系统的一部分，这个事实强化了这样一种观念，即栈很可能是计算机科学中在数组之后的最基本的数据结构\n\n\n\n------\n\n### 队列的具体实现\n\n#### 队列的链表实现\n\n\n\n同栈一样，任何表都可以实现队列，而使用链表来实现队列是最简单的。入队对应的就是 LinkedList 的 add 操作，而出队则是取出 first 元素，并将 first 指向后一个元素即可\n\n\n\n------\n\n#### 队列的数组实现\n\n\n\n对于每一个队列数据结构，我们保留一个数组 theArray 以及位置 front 和 back，他们代表队列的两端。还要记录实际存在与队列中的元素个数 currentSize，下图表示处于某个中间状态的队列\n\n\n\n![image-20201119210337396](C:\\Users\\A\\Desktop\\image-20201119210337396.png)\n\n\n\n为使一个元素 x 入队（即执行 enqueue），我们让 currentSize 和 back 置 1，然后置 theArray[back] = x。若是元素  dequeue（出队），我们置返回值为 theArray[front]，且 currentSize 和 front 都增 1\n\n\n\n上述实现存在着一个潜在的问题，经过 10 次 enqueue 之后队列似乎是满了，因为 back 现在是数组的最后一个下标，而下一次再 enqueue 就会是一个不存在的位置。然而，队列中也许只存在几个元素，因为若干元素可能已经出队了。像栈一样，即使在有许多操作的情况下队列也常常不是很大\n\n\n\n简单的解决办法是，只要 front 或 back 到达数组的尾端，它就又绕回开头，这就是循环数组\n\n\n\n------\n\n#### 双端队列\n\n\n\n栈和队列都是线性表的一种，且二者添加元素都是在线性表的尾部新增元素。不同的是，取出元素的时候，栈是从尾部取出的，而队列是从头部取出的。那么如果有一个线性表，既可以从头部取出元素，也可以从尾部取出元素，那么它就具备了栈和队列的双重特性，而像这样可以从两端弹出元素的线性表，则称之为双端队列\n\n\n\n双端队列让我们可以更自由的操作线性表中的元素，还可以减少代码的实现。如果想使用队列，则只从表的头部取出元素，如果想使用栈，则只从尾部取出元素。双端队列将栈和队列的抽象从数据结构层转移到了代码层，如果我们想固定使用某一种结构的话，就需要严格调用该结构对应的方法，否则就会使线性表中的元素混乱\n\n\n\nJava 将双端队列定义为一个接口 Deque，以下是 Deque 接口常用的一些方法：\n\n* push：像尾部添加元素\n* pop：移除尾部元素并返回它的值\n* poll：将头部元素弹出，如果表为空就返回 null\n* peek：查看头部元素，不会移除，如果是空就返回 null\n* element：查看头部元素，不会移除，如果是空就抛出异常\n\n\n\n------\n\n### JAVA 中的栈和队列\n\n#### LinkedList\n\n\n\n查看 LinkedList 的源码，会发现它实现了 Deque 接口，这意味着 LinkedList 也是也是一个双端队列。所以由链表实现的栈和由链表实现的队列都是 LinkedList\n\n\n\n------\n\n#### Stack\n\n\n\nStack 是由数组实现的栈，它继承了 Vector 类，Vector 是线程安全的 ArrayList，Stack 调用的也是它的方法，这意味着 Stack 也是线程安全的栈\n\n\n\n------\n\n#### ArrayQueue\n\n\n\nArrayQueue 是用数组实现的队列，底层的数据结构也是上文提到的循环数组\n\n\n\n![image-20201121224210165](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201121224210165.png)\n\n\n\n上图分别是队空时和队满时的两种状态，当队空时，头坐标和尾坐标指向同一个元素，即 front = rear；当队满时，尾坐标在头坐标的前一个位置，而头坐标指向的位置没有放置元素，这意味着循环数组能够放置的元素数量会比数组的长度小一个\n\n\n\n我们也可用一个状态标识 empty 来区分当前队列是空还是满，队列初始化时 full为 false，而当 rear 在 front 前一个位置时，我们再往其中添加一个元素，此时 full 就变成了 true，此时如果有元素出队的话，full 再重新变为 false\n\n</br>\n\n**成员变量**\n\n```java\n// 队列可容纳元素的数量\nprivate int capacity;\n// 放置元素的数组\nprivate T[] queue;\n// 头元素下标\nprivate int head;\n// 尾元素下标\nprivate int tail;\n```\n\n\n\n**构造方法**\n\n```java\npublic ArrayQueue(int capacity) {\n    // 为了让队列可容纳元素的数量为构造方法传入的值，将传入的capacity的值加1\n    this.capacity = capacity + 1;\n    this.queue = newArray(capacity + 1);\n    // 初始化时头尾坐标均指向0\n    this.head = 0;\n    this.tail = 0;\n}\n```\n\n\n\n**扩容**\n\n当 ArrayQueue 满了的时候，我们再往里面添加元素会抛出异常，如果当前队列的大小不满足需求的话，需要我们调用 resize() 方法进行扩容\n\n```java\npublic void resize(int newcapacity) {\n    // resize方法不仅可以扩容，还可以缩容，如果新队列的长度小于实际元素个数的话就会抛出异常\n    int size = size();\n    if (newcapacity < size)\n        throw new IndexOutOfBoundsException(\"Resizing would lose data\");\n    // 队列长度为目标长度+1\n    newcapacity++;\n    if (newcapacity == this.capacity)\n        return;\n    T[] newqueue = newArray(newcapacity);\n    // get(i)是循环将头节点和尾节点的元素取出\n    for (int i = 0; i < size; i++)\n        newqueue[i] = get(i);\n    this.capacity = newcapacity;\n    this.queue = newqueue;\n    // 新队列的头节点为0\n    this.head = 0;\n    this.tail = size;\n}\n```\n\n</br>\n\n**入队**\n\n```java\npublic boolean add(T o) {\n    // 先给队尾添加值，再判断是否队满\n    queue[tail] = o;\n    // 判断队满的方式：(tail + 1) % capacity == head\n    int newtail = (tail + 1) % capacity;\n    if (newtail == head)\n        throw new IndexOutOfBoundsException(\"Queue full\");\n    // 队列没满的情况下，队尾下标才会后移一位\n    tail = newtail;\n    return true; // we did add something\n}\n```\n\n先插入元素再判断队列有没有满，这样队尾下标元素实际上是有值的，但是我们无法取得而已。并且每次添加元素都会把之前的值覆盖掉\n\n</br>\n\n**出队**\n\n```java\npublic T remove(int i) {\n    // 队列只能从头元素开始取\n    if (i != 0)\n        throw new IllegalArgumentException(\"Can only remove head of queue\");\n    // 当 head == tail 的时候队列为空\n    if (head == tail)\n        throw new IndexOutOfBoundsException(\"Queue empty\");\n    // 获取头元素\n    T removed = queue[head];\n    // 将头元素置空\n    queue[head] = null;\n    // 头元素下标加1\n    head = (head + 1) % capacity;\n    return removed;\n}\n```\n\n## 树\n\n### 什么是树\n\n#### 树的简介\n\n![image-20201124204551109](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201124204551109.png)\n\n\n\n树是一种抽象数据类型或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n>0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：\n\n1. 每个节点有零个或多个子节点；\n2. 没有父节点的节点称为根节点；\n3. 每一个非根节点有且只有一个父节点；\n4. 除了根节点外，每个子节点可以分为多个不相交的子树；\n\n\n\n------\n\n#### 树的术语\n\n\n\n![image-20201124221707828](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201124221707828.png)\n\n* 结点：使用树存储结构存储的每一个数据元素都被称为结点\n* 路径：顺着连接结点的边从一个结点走到另一个节点，所经过的结点顺序排列就称为路径\n* 根结点：树顶端的结点称为根结点，如果一个结点没有父结点，那么它就是整棵树的根节点，上图的根结点就是 A\n* 父结点：每个结点（除根结点）都恰好有一条边向上连接到另一个结点，上面这个结点就称为下面这个结点的父结点\n* 子结点：与父结点相反，比如 B 是 E 的父结点，那么 E 就是 B 的子结点\n* 叶结点：如果结点没有任何子结点，那么此结点称为叶结点\n* 空树：如果集合本身为空，那么构成的树就为空树，空树没有结点\n* 子树：全部由子结点构成的树称为子树，如上图，整个是一棵树，B、E、F、K、L 也可看作一棵树，E、K、L也可看作一棵树，它们都可看作这棵树的子树\n* 结点的度：对于一个结点，拥有的子树数（结点有多少分支）称为结点的度\n* 结点的层次：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推\n* 树的深度：一棵树的深度（高度）是树中结点所在的最大的层次\n* 有序树和无序树：如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为有序树；反之称为无序树\n* 森林：由 m（m >= 0）个互不相交的树组成的集合被称为森林\n\n------\n\n### 二叉树\n\n#### 二叉树的定义\n\n\n\n简单地理解，满足以下两个条件的树就是二叉树：\n\n1. 本身是有序树\n2. 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2\n\n\n\n![image-20201211175500008](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201211175500008.png)\n\n\n\n\n\n------\n\n#### 二叉树的性质\n\n\n\n1. 二叉树中，第 i 层最多有 2^(i-1) 个结点\n2. 如果二叉树的深度为 K，那么此二叉树最多有 2^(K-1) 个结点\n3. 二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1\n\n\n\n------\n\n#### 满二叉树\n\n\n\n如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树\n\n\n\n![image-20201211180057924](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201211180057924.png)\n\n\n\n满二叉树除了满足普通二叉树的性质，还具有以下性质：\n\n1.  满二叉树中第 i 层的节点数为 2^(n-1) 个\n2. 深度为 k 的满二叉树必有 2^(k-1) 个节点 ，叶子数为 2^(k-1)\n3. 满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层\n4. 具有 n 个节点的满二叉树的深度为 log2(n+1)\n\n\n\n------\n\n#### 完全二叉树\n\n\n\n如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树\n\n![image-20201212192543825](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201212192543825.png)\n\n\n\n对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号，对于任意一个结点 i ，完全二叉树还有以下几个结论成立：\n\n1. 当 i>1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）\n2.  如果 2*i>n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2*i \n3.  如果 2*i+1>n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2*i+1 \n\n\n\n------\n\n### 二叉树的结构\n\n#### 二叉树的顺序储存结构\n\n\n\n二叉树的顺序存储，指的是使用数组存储二叉树。需要注意的是，顺序存储只适用于完全二叉树。换句话说，只有完全二叉树才可以使用顺序表存储。因此，如果我们想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树\n\n\n\n完全二叉树的顺序存储，仅需从根节点开始，按照层次依次将树中节点存储到数组即可\n\n\n\n![image-20210103150636489](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210103150636489.png)\n\n\n\n------\n\n#### 二叉树的链式存储结构\n\n\n\n其实二叉树并不适合用数组存储，因为并不是每个二叉树都是完全二叉树，普通二叉树使用顺序表存储或多或多会存在空间浪费的现象。而一棵普通的二叉树，若将其采用链式存储，则只需从树的根节点开始，将各个节点及其左右孩子使用链表存储即可\n\n\n\n![image-20210103151203203](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210103151203203.png)\n\n\n\n采用链式存储二叉树时，其节点结构由三部分组成\n\n* 指向左孩子节点的指针（leftChild）\n* 节点存储的数据（data）\n* 指向右孩子节点的指针（rightChild）\n\n![image-20210103151359861](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210103151359861.png)\n\n我们还可以在该节点中添加一个指针，指向该结点的父节点。这样的链表结构，称为三叉链表\n\n\n\n```java\npublic class Node{\n    private Node leftChild;\n    private Object Data;\n    private Node rightChild;\n    \n    private Node parent;\n}\n```\n\n\n\n------\n\n### 二叉树的遍历\n\n\n\n所谓遍历(Traversal)是指沿着某条搜索路线，依次对树中每个结点均做一次且仅做一次访问。访问结点所做的操作依赖于具体的应用问题。 遍历是二叉树上最重要的运算之一，是二叉树上进行其它运算之基础\n\n\n\n二叉树的遍历主要有以下四种方式：\n\n* 前序遍历\n* 中序遍历\n* 后序遍历\n* 层序遍历\n\n\n\n#### 前序遍历\n\n![image-20210103183839223](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210103183839223.png)\n\n二叉树前序遍历的实现思想是：\n\n1. 访问根节点\n2. 访问当前节点的左子树\n3. 若当前节点无左子树或左子树已访问过，继续访问当前节点的右子树\n\n因此，以上二叉树采用前序遍历得到的序列为：1245367\n\n\n\n```java\n/**\n* 前序遍历代码实现\n*/\npublic void preOrderTraveral(Node node) {\n    if (node == null) {\n        return;\n    }\n    System.out.println(node.data.toString());\n    preOrderTraveral(node.leftChild);\n    preOrderTraveral(node.rightChild);\n}\n```\n\n\n\n------\n\n#### 中序遍历\n\n\n\n二叉树中序遍历的实现思想是：\n\n1. 访问当前节点的左子树\n2. 访问根节点\n3. 访问当前节点的右子树\n\n因此，以上二叉树采用中序遍历得到的序列为：4251637\n\n\n\n```java\n/**\n* 中序遍历代码实现\n*/\npublic void inOrderTraveral(Node node) {\n    if (node == null) {\n        return;\n    }\n    inOrderTraveral(node.leftChild);\n    System.out.println(node.data.toString());\n    inOrderTraveral(node.rightChild);\n}\n```\n\n\n\n------\n\n#### 后序遍历\n\n\n\n二叉树前序遍历的实现思想是：\n\n1. 访问当前节点的左子树\n2. 访问当前节点的右子树\n3. 访问当前节点\n\n因此，以上二叉树采用中序遍历得到的序列为：1376254\n\n\n\n```java\n/**\n* 后序遍历代码实现\n*/\npublic void postOrderTraveral(Node node) {\n    if (node == null) {\n        return;\n    }\n    postOrderTraveral(node.leftChild);\n    postOrderTraveral(node.rightChild);\n    System.out.println(node.data.toString());\n}\n```\n\n\n\n------\n\n#### 层序遍历\n\n\n\n![image-20210110194451416](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210110194451416.png)\n\n\n\n二叉树层序遍历的实现思想是：\n\n1. 通过使用队列的数据结构，从树的根节点开始，先入队，再出队\n2. 出队的同时，将根节点的左右子结点分别入队\n3. 此后每次出队操作，都将该节点的左右孩子节点入队，知道树中的所有结点都出队\n\n```java\n/**\n* 层序遍历代码实现\n*/\npublic void levelOrder(Node root) {\n    LinkedList<Node> queue = new LinkedList<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n        node = queue.pop();\n        System.out.println(node.data.toString());\n        if (node.leftChild != null) {\n            queue.add(node.leftChild);\n        }\n        if (node.rightChild != null) {\n            queue.add(node.rightChild);\n        }\n    }\n}\n```\n\n\n\n### 线索二叉树\n\n#### 定义\n\n\n\n普通的二叉树，不管形态如何，空链域的个数总是多过非空链域的个数。所谓空链域，指的是孩子节点为 null 的指针域。实际上，n 个节点的二叉树共有 2n 个链域，其中非空链域有 n - 1 个，而空链域却有 n + 1 个\n\n\n\n因此，我们可以利用这些空链域，指向该节点的前驱节点或者后继节点，这样就可以充分利用到这些空链域，提升遍历速度。所谓前驱节点和后继节点，指的是该二叉树遍历完成后顺序输出的顺序中，该节点的前一个节点和后一个节点。众所周知，使用不同的遍历方法遍历出来的节点顺序是不一样的，因此同一个二叉树使用不同的线索顺序，同一个节点的前驱和后继节点也可能是不一样的。这里我们主要介绍一下中序遍历线索二叉树\n\n\n\n使用空链域来指向前驱后继节点，我们就需要区分该节点的左右孩子节点指向的是自己的孩子还是前驱后继节点，因此我们需要增加两个标识位，leftTag 和 rightTag，当 tag 的值为 0 时说明指向的是自己的孩子节点，值为 1 时说明指向的是前驱或者后继节点\n\n\n\n![image-20210117135411299](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210117135411299.png)\n\n\n\n```java\npublic class Node {\n    private Object data;\n    private Node leftChild;\n    private Node rightChild;\n    private Integer leftTag;\n    private Integer rightTag;\n}\n```\n\n\n\n------\n\n#### 线索化\n\n\n\n将一棵普通的二叉树转为线索二叉树，即将二叉树所有的空链域指向自己的前驱或者后继节点，这个过程称为线索化\n\n```java\npublic class ThreadTree {\n    private Node root;\n    // 前驱节点\n    private Node pre = null;\n    \n \t/**\n \t* 将以root为根节点的二叉树线索化 中序法\n \t**/\n\tpublic void inThread(Node root) {\n    \tif (root != null) {\n        \t// 找到该二叉树的最左孩子节点，该节点即为该二叉树的最前驱节点\n        \tinThread(root.leftChild);\n        \tif (root.leftChild == null) {\n            \troot.setLeftTag(1);\n                root.setLeftChild(pre);\n        \t}\n            if (pre != null && null == pre.rightChild) {\n                pre.setRightTag(1);\n                pre.setRightChild(root);\n            }\n            pre = root;\n            inThread(root.rightChild);\n    \t}\n\t}\n}\n```\n\n","source":"_posts/《Java数据结构与算法》.md","raw":"---\ntitle: 《Java数据结构与算法》\ndate: 2020-09-22 23:44:50\ntags: 数据结构与算法\ncategories: 数据结构与算法\ntop_img: https://simon-bookcase.oss-cn-beijing.aliyuncs.com/franki-chamaki-1K6IQsQbizI-unsplash.jpg\ncover: https://simon-bookcase.oss-cn-beijing.aliyuncs.com/franki-chamaki-1K6IQsQbizI-unsplash.jpg\n---\n\n\n\n## 如何区分算法的好坏\n\n### 算法的效率\n\n虽然计算机能快速的完成运算处理，但实际上，它也需要根据输入数据的大小和算法效率来消耗一定的处理器资源。要想编写出能高效运行的程序，我们就需要考虑到算法的效率\n\n\n\n算法的效率主要由以下两个复杂度来评估： \n**时间复杂度**：评估执行程序所需的时间。可以估算出程序对处理器的使用程度\n**空间复杂度**：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度\n\n\n\n设计算法时，一般是要先考虑系统环境，然后权衡时间复杂度和空间复杂度，选取一个平衡点。不过，时间复杂度要比空间复杂度更容易产生问题，因此算法研究的主要也是时间复杂度，不特别说明的情况下，复杂度就是指时间复杂度\n\n\n\n------\n\n\n\n### 时间复杂度\n\n#### 大O表示法\n\n算法的时间复杂度通常用大O符号表述，定义为T[n] = O(f(n))。称函数T(n)以f(n)为界或者称T(n)受限于f(n)。  如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)。T(n)称为这一算法的“时间复杂度”。当输入量n逐渐加大时，时间复杂度的极限情形称为算法的“渐近时间复杂度”\n\n\n\n**推导大O阶**\n\n1. 用常数1来取代运行时间中所有加法常数。 \n2. 修改后的运行次数函数中，只保留最高阶项 \n3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数\n\n\n\n------\n\n\n\n#### 常见时间复杂度\n\n**常数阶**\n\n```java\n// 3行代码均只执行一次\nint sum = 0, a = 1;\nsum = (a + 1) * 2;\nSystem.out.println(sum);\n```\n\n上面算法的运行的次数的函数为 f(n)=3，根据推导大O阶的规则1，我们需要将常数3改为1，则这个算法的时间复杂度为 O(1)。如果 sum = (a + 1) * 2 这条语句再执行10次，这个算法的复杂度仍为 O(1)，因此称之为常数阶\n\n\n\n**线性阶**\n\n```java\nfor(int i=0; i<n; i++) {\n    // 时间复杂度为O(1)的算法\n    ...\n}\n```\n\n上面算法循环体中的代码执行了 n 次，因此这个算法的时间复杂度为 O(n)\n\n\n\n**对数阶**\n\n```java\nint a = 1;\nwhile(a < n) {\n\ta = a * 2;\n\t// 时间复杂度为O(1)的算法\n    ...\n}\n```\n\n上面算法中，随着 a 的每次乘 2，其数值都会越来越接近 n，直到大于 n，那么就将跳出循环。假设这个算法循环了 x 次，那么 2^x = n，可算得 x = logn。因此这个算法得时间复杂度为 O(logn)\n\n\n\n**平方阶**\n\n```java\nfor(int i=0; i<n; i++) {\n\tfor (int j=0; j<n; j++) {\n\t\t // 时间复杂度为O(1)的算法\n    \t...\n\t}\n}\n```\n\n上面算法中，我们已知内层循环得时间复杂度为 O(n)，再经过外层循环 n 次，因此这个算法的时间复杂度为 O(n²)\n\n\n\n如果我们算得某个算法的时间复杂度为 f(n) = 5n³ + 3n + 2，那么根据推导大O阶的第二条规则，只保留最高阶，那么这个算法的时间复杂度就变成了 f(n) = 5n³，再根据推导大O阶的第三条规则，去掉常数项，因此这个算法最终算得的时间复杂度应该是 O(n³)\n\n\n\n------\n\n\n\n#### 其它常见时间复杂度\n\n除了常数阶、线性阶、平方阶、对数阶，还有如下时间复杂度\n\n* f(n) = nlogn 时，时间复杂度为 O(nlogn)，称为 nlogn 阶\n* f(n) = n³ 时，时间复杂度为 O(n³)，称为立方阶\n* f(n) = 2ⁿ 时，时间复杂度为 O(2ⁿ)，称为指数阶\n* f(n) = n! 时，时间复杂度为 O(n!)，称为阶乘阶\n* f(n) = √n 时，时间复杂度为 O(√n)，称为平方根阶\n\n\n\n------\n\n\n\n#### 时间复杂度的比较\n\n![image-20201103001513219](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201103001513219.png)\n\n\n\n在上图中，X 轴代表 n 值，Y 轴代表时间复杂度。时间复杂度随着 n 值得变化而变化，可以看到，O(n)、O(logn)、O(√n )、O(nlogn )随着 n 的增加，复杂度提升不大，而 O(2ⁿ) 和 O(n!)  在 n 值较大时变化非常之大。实际上，在 n 等于 50 时，O(2ⁿ) 和 O(n!)  的复杂度就已经突破十位数了\n\n\n\n常用的时间复杂度按照耗费的时间从小到大依次是：\n\nO(1) < O(logn) < O(n) < O(nlogn) < O(n²) < O(n³) < O(2ⁿ) < O(n!)\n\n\n\n------\n\n\n\n## 数组\n\n### 数组的概念\n\n\n\n![image-20201104232327992](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201104232327992.png)\n\n\n\n定义：数组（Array）是一种线性表数据结构，他用一组连续的内存空间，来存储一组具有相同类型的数据\n\n\n\n1. 线性表\n\n   所谓线性表，指的是每个元素最多只有前后两个方向，像一条线一样进行排列，除了数组，链表、队列、栈等都是线性表\n\n2. 连续的内存空间和相同类型的数据\n\n\n\n正是因为这两点，才使得数组拥有了它的核心特性 -- 随机访问\n\n\n\n**随机访问**\n\n所谓随机访问，指的是能够随意访问数组中的任意一个元素，比如我想访问第 n 个元素，那么该元素的起始位置就是：\n\n​\t\t第 n 个元素的起始位置 = 第 1 个元素的起始位置  + 下标（从0开始）* 元素的长度\n\n而不是从第 1 个元素开始，依次访问第 2 个、第 3个 ...，直到访问到第 n 个为止\n\n\n\n------\n\n### 数组的操作\n\n\n\n* 数组支持随机访问，根据下标获取指定元素的时间复杂度为 O(1)\n* 如果想获取数组中指定某个值的元素的话，时间复杂度就变成了 O(n)；如果是有序数组的话，使用二分法，可以将时间复杂度将为 O(logn)\n* 数组为了保证内存数据的连续性，会导致插入、删除这两个操作比较低效\n\n\n\n#### 数组的插入\n\n1. 从头部和中间插入\n   * 如果是无序数组的话，最简单的插入方式是将要插入的第 k 个位置的元素移到最末尾，然后将新元素放入第 k 个位置，这种插入方法的时间复杂度为 O(1)\n   * 如果是有序数组的话，向第 k 个位置插入元素，那么位置 k 后的所有元素都需要向后移动一位，这种情况下最坏的时间复杂度可达到 O(n)\n2. 从尾部插入\n   * 从尾部插入数据的话只需要直接在数据末尾添加一个元素即可，不需要移动其它元素，时间复杂度为 O(1)\n\n\n\n#### 数组的删除\n\n1. 删除头部和中间元素\n   * 为了保证数组中数据的连续性，数组中间的第 k 个元素删除之后，位置 k 之后的所有元素都需要向前移动一位，最坏时间复杂度为 O(n)\n2. 删除尾部元素\n   * 删除尾部元素不需要移动元素，只需要将末尾元素删除即可，时间复杂度为 O(1)\n\n\n\n------\n\n### ArrayList\n\n#### 介绍\n\n\n\n在 Java 中，我们可以自己创建并维护一个数组，也可以使用 Java 提供的数组容器类 ArrayList。相比于自建数组，ArrayList 提供了一些高级功能，比如自动扩容、泛型、更方便的处理元素等等\n\n\n\n在我们使用数组时，除非已知数组的所有元素并且几乎不再更改，否则都会使用 ArrayList 来进行数组的相关操作\n\n\n\nArrayList 并不是线程安全的，如果我们想要保障 ArrayList 的线程安全，需要自己使用 Synchronized 关键字维护，或者调用 Collections.synchronizedList() 方法，获得一个线程安全的 ArryList，或者直接使用 JUC 包中的 CopyOnWriteArrayList\n\n\n\nArrayList 继承了 RandomAccess 接口，进入这个接口会发现 RandomAccess 接口中并无任何的变量或方法。事实上，这是一个“标志”接口，标志这 ArrayList 这个类具备随机访问的特性\n\n\n\n------\n\n#### 主要的成员变量\n\n\n\n```java\n/**\n * Default initial capacity.\n */\n private static final int DEFAULT_CAPACITY = 10;\n```\n\nArrayList 的初始数组长度为 10\n\n\n\n------\n\n#### 构造方法\n\n\n\n![image-20201107180130865](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201107180130865.png)\n\n* 无参构造方法\n\n  返回一个空数组，在第一次往数组里添加元素的时候才赋予数组长度，初始长度为 0\n\n* int 类型参数构造方法\n\n  返回一个指定长度的数组，入参为 0 的时候返回一个空数组，与无参构造方法类似，入参小于 0 则抛出异常\n\n* Collection 类型参数构造方法\n\n  传入一个 Collection 集合，将该集合转为 ArrayList 数组\n\n\n\n------\n\n####   扩容机制\n\n\n\n调用 ArrayList 的 add() 方法时，ArrayList 都会先判断一下当前数组是否已满，如果已经满了的话，就会调用 grow() 方法进行扩容\n\n\n\n```java\nprivate Object[] grow(int minCapacity) {\n     int oldCapacity = elementData.length;\n     if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n         int newCapacity = ArraysSupport.newLength(oldCapacity,\n                minCapacity - oldCapacity, /* minimum growth */\n                oldCapacity >> 1           /* preferred growth */);\n        return elementData = Arrays.copyOf(elementData, newCapacity);\n    } else {\n        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];\n    }\n}\n```\n\n\n\nadd() 方法在调用 grow() 方法时，传入的 minCapacity 的值为 size+1，但是 ArraysSupport.newLength() 会判断 minCapacity 的值和 oldCapacity >> 1（即原数组长度的一半）哪个更大，原数组长度加上两者之间的大者即为扩容后的新数组的长度。因此通常情况下扩容后的容量为原容量的 1.5 倍\n\n\n\n**自动扩容带来的问题**\n\n数字的自动扩容会带来一些空间资源的浪费，有时候只是想往数组中添加一个元素，长度加 1 即可，但是却让数组长度变成了原来的 1.5倍。在数组长度较小的时候，些许的浪费无伤大雅，但是当数据量较大时，带来的资源浪费就显得没必要了\n\n\n\n**解决方法**\n\n* 如果在创建数组时便知道数组的长度，就可以使用 ArrayList 的 int 类型参数构造方法来创建一个指定长度的数组了\n* 如果在创建数组的时候并不知道数组的长度，但是在插入数组的时候知道了，那么可以使用 ensureCapacity() 方法来将数组扩容到想要的长度\n* 还可以在数组插入完成之后，调用 trimToSize() 方法，将数组多余的长度清空掉\n\n\n\n------\n\n#### 迭代器\n\n\n\n迭代器 Iterator 是一种设计模式，所有的 Collections 集合类都有实现这种设计模式，为得是提供一套统一的 API 来操作元素\n\n\n\n迭代器有两种属性，fail-fast 和 fail-safe\n\n* fail-fast\n\n  ArrayList 会维护一个 modCount 变量，每次对数组的增删改操作都会将 modCount 加 1。迭代器在遍历元素时直接获取原有集合的内容，在操作过程中如果发现 modCount 的值发生了变化，就会抛出异常\n\n* fail-safe\n\n  迭代器在遍历元素时，会将原有集合复制出来一份，然后在复制出来的这个集合上进行操作。这样做避免了抛出异常，但是原有集合上的操作并不能被迭代器检测到\n  \n  \n\n------\n\n## 链表\n\n### 链表的概念\n\n\n\n数组是使用最广泛的一种通用数据结构，但是也不可避免的存在着一些缺陷。在无序数组中，搜索是低效的；而在有序数组中，插入效率又很低；而不管再哪一种数组中，删除效率都很低；并且一个数组在创建后，它的大小是不可改变的。而链表则可以解决上面的一些问题\n\n\n\n链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。每个元素节点除了存储自己的数据域之外，还存储着下一个节点的指针域\n\n\n\n![image-20201110211256134](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201110211256134.png)\n\n\n\n链表需通过头元素一个一个遍历才能找到目标元素，不支持随机访问。但是链表的增删操作只需要改变节点的指针域即可，不需要移动元素，增删速度较快。除非需要频繁通过下标访问元素，否则很多使用数组的地方都可以使用链表代替。而链表也是除数组外运用第二广泛的通用数据结构\n\n\n\n------\n\n### 链表的操作\n\n#### 链表的基本结构\n\n\n\n链表作为一个集合，首先需要知道头节点的位置，否则即使查询也不知道从何查起。而集合中存储着一系列的节点，这些节点既需要保存着自己的数据域，还需要保存着下一个节点的位置\n\n\n\n```java\npublic class LinkList {\n    // 头节点\n    private Link fisrt;\n    \n    class Link {\n        // 指向下一个节点\n        private Link next;\n        // 数据域\n        private Object data;\n    }\n    ...\n}\n```\n\n\n\n这是一个链表最基本的组成，还可以通过添加其它属性和方法来丰富这个链表，比如添加 size 属性，获得这个链表的长度；还可添加 Link last 属性，来更快的找到尾节点等等\n\n\n\n------\n\n#### 链表的查询\n\n\n\n不管是查询指定值的节点，还是查询第 k 个元素，链表都需要从头节点一个个遍历，因此链表查询的时间复杂度固定为 O(n)\n\n\n\n------\n\n#### 链表的插入和删除\n\n\n\n链表删除节点 k，只需要将节点 k-1 的指针域执行节点 k+1 即可，时间复杂度为 O(1)\n\n```java\npublic void remove(Link removeLink) {\n    // 获取被删除节点的上一个节点\n    Link preLink = removeLink.pre;\n    // 将上一个节点的指针域只想被删除节点的下一个节点\n    preLink.next = removeLink.next;\n}\n```\n\n\n\n链表想在节点 k 和 k+1 之间插入一个元素，需要将节点 k 的指针域指向插入的节点，然后将插入节点的指针域指向节点 k+1，时间复杂度为 O(1)\n\n```java\npublic void insert(Link preLink, Link insertLink) {\n    // preLink为节点k，通过节点k获取节点k+1\n    Link afterLink = preLink.next;\n    // 将节点k的指针域指向插入的节点\n    preLink.next = insertLink;\n    // 将插入节点的指针域指向节点k+1\n    insertLink.next = afterLink;\n}\n```\n\n\n\n------\n\n### 不同类型的链表\n\n\n\n* 单向链表\n\n  像上面这样只能从上一个节点获取下一个节点的链表，称为单项链表\n\n* 双向链表\n\n  如果链表中的节点不仅存储着下一个节点的指针域，还存储着上一个节点的指针域，这种链表称为双向链表\n\n* 循环链表\n\n  链表的尾节点又重新指向头节点，形成了一个圈，这种链表称为循环链表\n\n\n\n------\n\n### LinkedList\n\n#### 主要的成员变量\n\n\n\n```java\ntransient int size = 0;\n\n/**\n * Pointer to first node.\n */\ntransient Node<E> first;\n\n/**\n * Pointer to last node.\n */\ntransient Node<E> last;\n```\n\n\n\nLinkedList 只有三个成员变量，size 用于记录集合中的元素个数，first 和 last 分别指向头节点和尾节点\n\n\n\n#### Node节点元素\n\n\n\n```java\nprivate static class Node<E> {\n    E item;\n    Node<E> next;\n    Node<E> prev;\n\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\n\n\n可以看出，LinkedList 的节点元素既可以指向上一个元素，也可以指向下一个元素，所以 LinkedList 是一个双向链表\n\n\n\n------\n\n#### 构造方法\n\n\n\n**无参构造方法**\n\n```java\npublic LinkedList() {\n}\n```\n\nJava 15 中，LinkedList 的无参构造方法会返回一个空集合，头节点和尾节点都是 null\n\n\n\n**有参构造方法**\n\n```java\npublic LinkedList(Collection<? extends E> c) {\n    this();\n    addAll(c);\n}\n```\n\nLinkedList 的有参构造方法可以传入一个集合，将这个集合转为 LinkedList\n\n\n\n相比与 ArrayList，LinkedList 无须扩容，新增和删除的实现方式也比较简单\n\n\n\n------\n\n## 栈和队列\n\n### 抽象数据类型（ADT）\n\n\n\n抽象数据类型（Abstract Data Type，ADT）是带有一组操作的一些对象的集合。抽象数据类型是数学的抽象，在 ADT 的定义中没有地方提到关于这组操作是如何实现的具体解释。比如我们定义了线性表（List）这么一个 ADT，要求元素像一条线一样只有前后两个方向排列，那么只要满足了这个要求的，都可以看作线性表 ADT 的具体实现\n\n\n\nJava 也考虑了 ADT 的实现，不过适当了隐藏了实现的细节。最直观的方式就是“接口”，Java 中有 List 接口，只有实现了这个接口的类，都是 List 的具体实现类，例如 ArrayList、LinkedList，还有后续的 Deque、Stack等，都可以看作一个List。而在 Java 中，这就是对象多态的体现\n\n\n\n```java\npublic static void main(String[] args) {\n\n    List<String> list1 = new ArrayList<>();\n    List<String> list2 = new LinkedList<>();\n        \n    list1.add(\"list1\");\n    list2.add(\"list2\");\n\n}\n```\n\n如上所示，我们可以只需要获得一个 List集合，然后支持 List 集合的方法即可，而不关系它究竟是 ArrayList 还是 LinkedList\n\n\n\n\n\n![image-20201115151509347](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201115151509347.png)\n\n**此图只是对ADT的简单展示，Java中数据结构中的层次远比这个复杂得多**\n\n\n\n不同的 ADT 之间也有着不同的关系，如上图所示，可以有层级关系，如 List 和 Queue 之间；也有并列关系，如 List 和 Map 之间；还有可能什么关系也没有。我们可以根据自己的需求去选用合适的 ADT 实现类，如果我们想要个 List 集合的话，就去找一个实现了 List 集合接口的类；如果想要个 Queue 的话，就去找一个实现了 Queue 接口的类；如果当前存在的都不满足需求的话，我们也可以自己实现一个，只要实现了对应的 ADT 接口即可\n\n\n\n------\n\n\n\n### 栈ADT\n\n#### 栈模型\n\n\n\n栈（Stack）是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈的顶（top）。对栈的基本操作有 push（进栈）和 pop（出栈），前者相当于插入，后者则是删除最后插入的元素。最后插入的元素可以通过 top 例程在执行 pop 之前进行考察。对空栈进行 top 或 pop 操作一般被认为栈 ADT 中的一个错误。另一方面，当运行 push 时空间用尽是一个实现限制，但不是 ADT 错误\n\n\n\n栈有时又叫做 LIFO（后进先出）表。普通的清空栈的操作和判断是否空栈的操作都是栈的操作系统指令的一部分。但是，我们对栈所能够做的，基本上也就是 pop 和 push 操作\n\n\n\n![image-20201115170259354](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201115170259354.png)\n\n![image-20201115170423180](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201115170423180.png)\n\n\n\n------\n\n### 队列ADT\n\n#### 队列模型\n\n\n\n像栈一样，队列也是表。但是，使用队列时插入在一段进行而删除则在另一端进行\n\n\n\n队列的基本操作是 enqueue（入队），它是在表的末端（叫做队尾 rear）插入一个元素；以及 dequeue（出队），它是返回并删除在表开头（叫做对头 front）的元素。队列，也叫做 FIFO（先进先出）表\n\n\n\n![image-20201115195545751](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201115195545751.png)\n\n\n\n------\n\n### 栈的具体实现\n\n#### 栈的实现\n\n\n\n由于栈是一个表，因此任何实现表的方法都能实现栈。显然，ArrayList 和 LinkedList 都支持栈操作，99% 的时间它们都是最合理的选择。偶尔设计一种特殊目的的实现可能会更快。因为栈操作的时间复杂度为 O(1)，所以，除非在非常独特的环境下，这是不可能产生任何明显的改进的。对于这些特殊的时机，一般给出了两种流行的实现方法，一种方法使用链式结构，而另一种方法使用数组，二者均简化了在 ArrayList 和 LinkedList 中的逻辑\n\n\n\n------\n\n#### 栈的链式实现\n\n\n\n栈的第一种实现方法是使用单链表，通过在表的顶端插入来实现 push，通过删除表顶端元素来实现 pop。top 操作只是考查表顶端元素并返回它的值，有时 pop 操作和 top操作合二为一\n\n\n\n------\n\n#### 栈的数组实现\n\n\n\n另一种方式避免了链并且可能是更流行的解决方案。由于模仿 ArrayList 的 add 操作，因此相应的实现方式非常简单。与每个栈相关联的操作是 theArray 和 topOfStack，对于空栈它是 -1，这就是空栈初始化的做法。为将某个元素 x 推入栈中，我们是 topOfStack 增 1 然后置 theArray[topOfStack] = x。为了弹出栈元素，我们置返回值为 theArray[topOfStack] 然后使 topOfStack 减 1\n\n\n\n注意，这些操作不仅以常数时间运行，而且是以非常快的常数时间运行。在某些机器上，若在带有自增和自减寻址功能的寄存器上操作，则（整数的）pop 和 push 都可以写成一条机器指令。最现代化的计算机将栈操作作为它指令系统的一部分，这个事实强化了这样一种观念，即栈很可能是计算机科学中在数组之后的最基本的数据结构\n\n\n\n------\n\n### 队列的具体实现\n\n#### 队列的链表实现\n\n\n\n同栈一样，任何表都可以实现队列，而使用链表来实现队列是最简单的。入队对应的就是 LinkedList 的 add 操作，而出队则是取出 first 元素，并将 first 指向后一个元素即可\n\n\n\n------\n\n#### 队列的数组实现\n\n\n\n对于每一个队列数据结构，我们保留一个数组 theArray 以及位置 front 和 back，他们代表队列的两端。还要记录实际存在与队列中的元素个数 currentSize，下图表示处于某个中间状态的队列\n\n\n\n![image-20201119210337396](C:\\Users\\A\\Desktop\\image-20201119210337396.png)\n\n\n\n为使一个元素 x 入队（即执行 enqueue），我们让 currentSize 和 back 置 1，然后置 theArray[back] = x。若是元素  dequeue（出队），我们置返回值为 theArray[front]，且 currentSize 和 front 都增 1\n\n\n\n上述实现存在着一个潜在的问题，经过 10 次 enqueue 之后队列似乎是满了，因为 back 现在是数组的最后一个下标，而下一次再 enqueue 就会是一个不存在的位置。然而，队列中也许只存在几个元素，因为若干元素可能已经出队了。像栈一样，即使在有许多操作的情况下队列也常常不是很大\n\n\n\n简单的解决办法是，只要 front 或 back 到达数组的尾端，它就又绕回开头，这就是循环数组\n\n\n\n------\n\n#### 双端队列\n\n\n\n栈和队列都是线性表的一种，且二者添加元素都是在线性表的尾部新增元素。不同的是，取出元素的时候，栈是从尾部取出的，而队列是从头部取出的。那么如果有一个线性表，既可以从头部取出元素，也可以从尾部取出元素，那么它就具备了栈和队列的双重特性，而像这样可以从两端弹出元素的线性表，则称之为双端队列\n\n\n\n双端队列让我们可以更自由的操作线性表中的元素，还可以减少代码的实现。如果想使用队列，则只从表的头部取出元素，如果想使用栈，则只从尾部取出元素。双端队列将栈和队列的抽象从数据结构层转移到了代码层，如果我们想固定使用某一种结构的话，就需要严格调用该结构对应的方法，否则就会使线性表中的元素混乱\n\n\n\nJava 将双端队列定义为一个接口 Deque，以下是 Deque 接口常用的一些方法：\n\n* push：像尾部添加元素\n* pop：移除尾部元素并返回它的值\n* poll：将头部元素弹出，如果表为空就返回 null\n* peek：查看头部元素，不会移除，如果是空就返回 null\n* element：查看头部元素，不会移除，如果是空就抛出异常\n\n\n\n------\n\n### JAVA 中的栈和队列\n\n#### LinkedList\n\n\n\n查看 LinkedList 的源码，会发现它实现了 Deque 接口，这意味着 LinkedList 也是也是一个双端队列。所以由链表实现的栈和由链表实现的队列都是 LinkedList\n\n\n\n------\n\n#### Stack\n\n\n\nStack 是由数组实现的栈，它继承了 Vector 类，Vector 是线程安全的 ArrayList，Stack 调用的也是它的方法，这意味着 Stack 也是线程安全的栈\n\n\n\n------\n\n#### ArrayQueue\n\n\n\nArrayQueue 是用数组实现的队列，底层的数据结构也是上文提到的循环数组\n\n\n\n![image-20201121224210165](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201121224210165.png)\n\n\n\n上图分别是队空时和队满时的两种状态，当队空时，头坐标和尾坐标指向同一个元素，即 front = rear；当队满时，尾坐标在头坐标的前一个位置，而头坐标指向的位置没有放置元素，这意味着循环数组能够放置的元素数量会比数组的长度小一个\n\n\n\n我们也可用一个状态标识 empty 来区分当前队列是空还是满，队列初始化时 full为 false，而当 rear 在 front 前一个位置时，我们再往其中添加一个元素，此时 full 就变成了 true，此时如果有元素出队的话，full 再重新变为 false\n\n</br>\n\n**成员变量**\n\n```java\n// 队列可容纳元素的数量\nprivate int capacity;\n// 放置元素的数组\nprivate T[] queue;\n// 头元素下标\nprivate int head;\n// 尾元素下标\nprivate int tail;\n```\n\n\n\n**构造方法**\n\n```java\npublic ArrayQueue(int capacity) {\n    // 为了让队列可容纳元素的数量为构造方法传入的值，将传入的capacity的值加1\n    this.capacity = capacity + 1;\n    this.queue = newArray(capacity + 1);\n    // 初始化时头尾坐标均指向0\n    this.head = 0;\n    this.tail = 0;\n}\n```\n\n\n\n**扩容**\n\n当 ArrayQueue 满了的时候，我们再往里面添加元素会抛出异常，如果当前队列的大小不满足需求的话，需要我们调用 resize() 方法进行扩容\n\n```java\npublic void resize(int newcapacity) {\n    // resize方法不仅可以扩容，还可以缩容，如果新队列的长度小于实际元素个数的话就会抛出异常\n    int size = size();\n    if (newcapacity < size)\n        throw new IndexOutOfBoundsException(\"Resizing would lose data\");\n    // 队列长度为目标长度+1\n    newcapacity++;\n    if (newcapacity == this.capacity)\n        return;\n    T[] newqueue = newArray(newcapacity);\n    // get(i)是循环将头节点和尾节点的元素取出\n    for (int i = 0; i < size; i++)\n        newqueue[i] = get(i);\n    this.capacity = newcapacity;\n    this.queue = newqueue;\n    // 新队列的头节点为0\n    this.head = 0;\n    this.tail = size;\n}\n```\n\n</br>\n\n**入队**\n\n```java\npublic boolean add(T o) {\n    // 先给队尾添加值，再判断是否队满\n    queue[tail] = o;\n    // 判断队满的方式：(tail + 1) % capacity == head\n    int newtail = (tail + 1) % capacity;\n    if (newtail == head)\n        throw new IndexOutOfBoundsException(\"Queue full\");\n    // 队列没满的情况下，队尾下标才会后移一位\n    tail = newtail;\n    return true; // we did add something\n}\n```\n\n先插入元素再判断队列有没有满，这样队尾下标元素实际上是有值的，但是我们无法取得而已。并且每次添加元素都会把之前的值覆盖掉\n\n</br>\n\n**出队**\n\n```java\npublic T remove(int i) {\n    // 队列只能从头元素开始取\n    if (i != 0)\n        throw new IllegalArgumentException(\"Can only remove head of queue\");\n    // 当 head == tail 的时候队列为空\n    if (head == tail)\n        throw new IndexOutOfBoundsException(\"Queue empty\");\n    // 获取头元素\n    T removed = queue[head];\n    // 将头元素置空\n    queue[head] = null;\n    // 头元素下标加1\n    head = (head + 1) % capacity;\n    return removed;\n}\n```\n\n## 树\n\n### 什么是树\n\n#### 树的简介\n\n![image-20201124204551109](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201124204551109.png)\n\n\n\n树是一种抽象数据类型或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n>0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：\n\n1. 每个节点有零个或多个子节点；\n2. 没有父节点的节点称为根节点；\n3. 每一个非根节点有且只有一个父节点；\n4. 除了根节点外，每个子节点可以分为多个不相交的子树；\n\n\n\n------\n\n#### 树的术语\n\n\n\n![image-20201124221707828](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201124221707828.png)\n\n* 结点：使用树存储结构存储的每一个数据元素都被称为结点\n* 路径：顺着连接结点的边从一个结点走到另一个节点，所经过的结点顺序排列就称为路径\n* 根结点：树顶端的结点称为根结点，如果一个结点没有父结点，那么它就是整棵树的根节点，上图的根结点就是 A\n* 父结点：每个结点（除根结点）都恰好有一条边向上连接到另一个结点，上面这个结点就称为下面这个结点的父结点\n* 子结点：与父结点相反，比如 B 是 E 的父结点，那么 E 就是 B 的子结点\n* 叶结点：如果结点没有任何子结点，那么此结点称为叶结点\n* 空树：如果集合本身为空，那么构成的树就为空树，空树没有结点\n* 子树：全部由子结点构成的树称为子树，如上图，整个是一棵树，B、E、F、K、L 也可看作一棵树，E、K、L也可看作一棵树，它们都可看作这棵树的子树\n* 结点的度：对于一个结点，拥有的子树数（结点有多少分支）称为结点的度\n* 结点的层次：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推\n* 树的深度：一棵树的深度（高度）是树中结点所在的最大的层次\n* 有序树和无序树：如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为有序树；反之称为无序树\n* 森林：由 m（m >= 0）个互不相交的树组成的集合被称为森林\n\n------\n\n### 二叉树\n\n#### 二叉树的定义\n\n\n\n简单地理解，满足以下两个条件的树就是二叉树：\n\n1. 本身是有序树\n2. 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2\n\n\n\n![image-20201211175500008](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201211175500008.png)\n\n\n\n\n\n------\n\n#### 二叉树的性质\n\n\n\n1. 二叉树中，第 i 层最多有 2^(i-1) 个结点\n2. 如果二叉树的深度为 K，那么此二叉树最多有 2^(K-1) 个结点\n3. 二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1\n\n\n\n------\n\n#### 满二叉树\n\n\n\n如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树\n\n\n\n![image-20201211180057924](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201211180057924.png)\n\n\n\n满二叉树除了满足普通二叉树的性质，还具有以下性质：\n\n1.  满二叉树中第 i 层的节点数为 2^(n-1) 个\n2. 深度为 k 的满二叉树必有 2^(k-1) 个节点 ，叶子数为 2^(k-1)\n3. 满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层\n4. 具有 n 个节点的满二叉树的深度为 log2(n+1)\n\n\n\n------\n\n#### 完全二叉树\n\n\n\n如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树\n\n![image-20201212192543825](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201212192543825.png)\n\n\n\n对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号，对于任意一个结点 i ，完全二叉树还有以下几个结论成立：\n\n1. 当 i>1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）\n2.  如果 2*i>n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2*i \n3.  如果 2*i+1>n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2*i+1 \n\n\n\n------\n\n### 二叉树的结构\n\n#### 二叉树的顺序储存结构\n\n\n\n二叉树的顺序存储，指的是使用数组存储二叉树。需要注意的是，顺序存储只适用于完全二叉树。换句话说，只有完全二叉树才可以使用顺序表存储。因此，如果我们想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树\n\n\n\n完全二叉树的顺序存储，仅需从根节点开始，按照层次依次将树中节点存储到数组即可\n\n\n\n![image-20210103150636489](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210103150636489.png)\n\n\n\n------\n\n#### 二叉树的链式存储结构\n\n\n\n其实二叉树并不适合用数组存储，因为并不是每个二叉树都是完全二叉树，普通二叉树使用顺序表存储或多或多会存在空间浪费的现象。而一棵普通的二叉树，若将其采用链式存储，则只需从树的根节点开始，将各个节点及其左右孩子使用链表存储即可\n\n\n\n![image-20210103151203203](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210103151203203.png)\n\n\n\n采用链式存储二叉树时，其节点结构由三部分组成\n\n* 指向左孩子节点的指针（leftChild）\n* 节点存储的数据（data）\n* 指向右孩子节点的指针（rightChild）\n\n![image-20210103151359861](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210103151359861.png)\n\n我们还可以在该节点中添加一个指针，指向该结点的父节点。这样的链表结构，称为三叉链表\n\n\n\n```java\npublic class Node{\n    private Node leftChild;\n    private Object Data;\n    private Node rightChild;\n    \n    private Node parent;\n}\n```\n\n\n\n------\n\n### 二叉树的遍历\n\n\n\n所谓遍历(Traversal)是指沿着某条搜索路线，依次对树中每个结点均做一次且仅做一次访问。访问结点所做的操作依赖于具体的应用问题。 遍历是二叉树上最重要的运算之一，是二叉树上进行其它运算之基础\n\n\n\n二叉树的遍历主要有以下四种方式：\n\n* 前序遍历\n* 中序遍历\n* 后序遍历\n* 层序遍历\n\n\n\n#### 前序遍历\n\n![image-20210103183839223](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210103183839223.png)\n\n二叉树前序遍历的实现思想是：\n\n1. 访问根节点\n2. 访问当前节点的左子树\n3. 若当前节点无左子树或左子树已访问过，继续访问当前节点的右子树\n\n因此，以上二叉树采用前序遍历得到的序列为：1245367\n\n\n\n```java\n/**\n* 前序遍历代码实现\n*/\npublic void preOrderTraveral(Node node) {\n    if (node == null) {\n        return;\n    }\n    System.out.println(node.data.toString());\n    preOrderTraveral(node.leftChild);\n    preOrderTraveral(node.rightChild);\n}\n```\n\n\n\n------\n\n#### 中序遍历\n\n\n\n二叉树中序遍历的实现思想是：\n\n1. 访问当前节点的左子树\n2. 访问根节点\n3. 访问当前节点的右子树\n\n因此，以上二叉树采用中序遍历得到的序列为：4251637\n\n\n\n```java\n/**\n* 中序遍历代码实现\n*/\npublic void inOrderTraveral(Node node) {\n    if (node == null) {\n        return;\n    }\n    inOrderTraveral(node.leftChild);\n    System.out.println(node.data.toString());\n    inOrderTraveral(node.rightChild);\n}\n```\n\n\n\n------\n\n#### 后序遍历\n\n\n\n二叉树前序遍历的实现思想是：\n\n1. 访问当前节点的左子树\n2. 访问当前节点的右子树\n3. 访问当前节点\n\n因此，以上二叉树采用中序遍历得到的序列为：1376254\n\n\n\n```java\n/**\n* 后序遍历代码实现\n*/\npublic void postOrderTraveral(Node node) {\n    if (node == null) {\n        return;\n    }\n    postOrderTraveral(node.leftChild);\n    postOrderTraveral(node.rightChild);\n    System.out.println(node.data.toString());\n}\n```\n\n\n\n------\n\n#### 层序遍历\n\n\n\n![image-20210110194451416](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210110194451416.png)\n\n\n\n二叉树层序遍历的实现思想是：\n\n1. 通过使用队列的数据结构，从树的根节点开始，先入队，再出队\n2. 出队的同时，将根节点的左右子结点分别入队\n3. 此后每次出队操作，都将该节点的左右孩子节点入队，知道树中的所有结点都出队\n\n```java\n/**\n* 层序遍历代码实现\n*/\npublic void levelOrder(Node root) {\n    LinkedList<Node> queue = new LinkedList<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n        node = queue.pop();\n        System.out.println(node.data.toString());\n        if (node.leftChild != null) {\n            queue.add(node.leftChild);\n        }\n        if (node.rightChild != null) {\n            queue.add(node.rightChild);\n        }\n    }\n}\n```\n\n\n\n### 线索二叉树\n\n#### 定义\n\n\n\n普通的二叉树，不管形态如何，空链域的个数总是多过非空链域的个数。所谓空链域，指的是孩子节点为 null 的指针域。实际上，n 个节点的二叉树共有 2n 个链域，其中非空链域有 n - 1 个，而空链域却有 n + 1 个\n\n\n\n因此，我们可以利用这些空链域，指向该节点的前驱节点或者后继节点，这样就可以充分利用到这些空链域，提升遍历速度。所谓前驱节点和后继节点，指的是该二叉树遍历完成后顺序输出的顺序中，该节点的前一个节点和后一个节点。众所周知，使用不同的遍历方法遍历出来的节点顺序是不一样的，因此同一个二叉树使用不同的线索顺序，同一个节点的前驱和后继节点也可能是不一样的。这里我们主要介绍一下中序遍历线索二叉树\n\n\n\n使用空链域来指向前驱后继节点，我们就需要区分该节点的左右孩子节点指向的是自己的孩子还是前驱后继节点，因此我们需要增加两个标识位，leftTag 和 rightTag，当 tag 的值为 0 时说明指向的是自己的孩子节点，值为 1 时说明指向的是前驱或者后继节点\n\n\n\n![image-20210117135411299](C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210117135411299.png)\n\n\n\n```java\npublic class Node {\n    private Object data;\n    private Node leftChild;\n    private Node rightChild;\n    private Integer leftTag;\n    private Integer rightTag;\n}\n```\n\n\n\n------\n\n#### 线索化\n\n\n\n将一棵普通的二叉树转为线索二叉树，即将二叉树所有的空链域指向自己的前驱或者后继节点，这个过程称为线索化\n\n```java\npublic class ThreadTree {\n    private Node root;\n    // 前驱节点\n    private Node pre = null;\n    \n \t/**\n \t* 将以root为根节点的二叉树线索化 中序法\n \t**/\n\tpublic void inThread(Node root) {\n    \tif (root != null) {\n        \t// 找到该二叉树的最左孩子节点，该节点即为该二叉树的最前驱节点\n        \tinThread(root.leftChild);\n        \tif (root.leftChild == null) {\n            \troot.setLeftTag(1);\n                root.setLeftChild(pre);\n        \t}\n            if (pre != null && null == pre.rightChild) {\n                pre.setRightTag(1);\n                pre.setRightChild(root);\n            }\n            pre = root;\n            inThread(root.rightChild);\n    \t}\n\t}\n}\n```\n\n","slug":"《Java数据结构与算法》","published":1,"updated":"2021-01-18T14:57:40.467Z","_id":"ckh6hkpms0000swv7e0r7gcio","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"如何区分算法的好坏\"><a href=\"#如何区分算法的好坏\" class=\"headerlink\" title=\"如何区分算法的好坏\"></a>如何区分算法的好坏</h2><h3 id=\"算法的效率\"><a href=\"#算法的效率\" class=\"headerlink\" title=\"算法的效率\"></a>算法的效率</h3><p>虽然计算机能快速的完成运算处理，但实际上，它也需要根据输入数据的大小和算法效率来消耗一定的处理器资源。要想编写出能高效运行的程序，我们就需要考虑到算法的效率</p>\n<p>算法的效率主要由以下两个复杂度来评估：<br><strong>时间复杂度</strong>：评估执行程序所需的时间。可以估算出程序对处理器的使用程度<br><strong>空间复杂度</strong>：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度</p>\n<p>设计算法时，一般是要先考虑系统环境，然后权衡时间复杂度和空间复杂度，选取一个平衡点。不过，时间复杂度要比空间复杂度更容易产生问题，因此算法研究的主要也是时间复杂度，不特别说明的情况下，复杂度就是指时间复杂度</p>\n<hr>\n<h3 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><h4 id=\"大O表示法\"><a href=\"#大O表示法\" class=\"headerlink\" title=\"大O表示法\"></a>大O表示法</h4><p>算法的时间复杂度通常用大O符号表述，定义为T[n] = O(f(n))。称函数T(n)以f(n)为界或者称T(n)受限于f(n)。  如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)。T(n)称为这一算法的“时间复杂度”。当输入量n逐渐加大时，时间复杂度的极限情形称为算法的“渐近时间复杂度”</p>\n<p><strong>推导大O阶</strong></p>\n<ol>\n<li>用常数1来取代运行时间中所有加法常数。 </li>\n<li>修改后的运行次数函数中，只保留最高阶项 </li>\n<li>如果最高阶项存在且不是1，则去除与这个项相乘的常数</li>\n</ol>\n<hr>\n<h4 id=\"常见时间复杂度\"><a href=\"#常见时间复杂度\" class=\"headerlink\" title=\"常见时间复杂度\"></a>常见时间复杂度</h4><p><strong>常数阶</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 3行代码均只执行一次</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>, a = <span class=\"number\">1</span>;</span><br><span class=\"line\">sum = (a + <span class=\"number\">1</span>) * <span class=\"number\">2</span>;</span><br><span class=\"line\">System.out.println(sum);</span><br></pre></td></tr></table></figure>\n\n<p>上面算法的运行的次数的函数为 f(n)=3，根据推导大O阶的规则1，我们需要将常数3改为1，则这个算法的时间复杂度为 O(1)。如果 sum = (a + 1) * 2 这条语句再执行10次，这个算法的复杂度仍为 O(1)，因此称之为常数阶</p>\n<p><strong>线性阶</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 时间复杂度为O(1)的算法</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面算法循环体中的代码执行了 n 次，因此这个算法的时间复杂度为 O(n)</p>\n<p><strong>对数阶</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(a &lt; n) &#123;</span><br><span class=\"line\">\ta = a * <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 时间复杂度为O(1)的算法</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面算法中，随着 a 的每次乘 2，其数值都会越来越接近 n，直到大于 n，那么就将跳出循环。假设这个算法循环了 x 次，那么 2^x = n，可算得 x = logn。因此这个算法得时间复杂度为 O(logn)</p>\n<p><strong>平方阶</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;n; j++) &#123;</span><br><span class=\"line\">\t\t <span class=\"comment\">// 时间复杂度为O(1)的算法</span></span><br><span class=\"line\">    \t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面算法中，我们已知内层循环得时间复杂度为 O(n)，再经过外层循环 n 次，因此这个算法的时间复杂度为 O(n²)</p>\n<p>如果我们算得某个算法的时间复杂度为 f(n) = 5n³ + 3n + 2，那么根据推导大O阶的第二条规则，只保留最高阶，那么这个算法的时间复杂度就变成了 f(n) = 5n³，再根据推导大O阶的第三条规则，去掉常数项，因此这个算法最终算得的时间复杂度应该是 O(n³)</p>\n<hr>\n<h4 id=\"其它常见时间复杂度\"><a href=\"#其它常见时间复杂度\" class=\"headerlink\" title=\"其它常见时间复杂度\"></a>其它常见时间复杂度</h4><p>除了常数阶、线性阶、平方阶、对数阶，还有如下时间复杂度</p>\n<ul>\n<li>f(n) = nlogn 时，时间复杂度为 O(nlogn)，称为 nlogn 阶</li>\n<li>f(n) = n³ 时，时间复杂度为 O(n³)，称为立方阶</li>\n<li>f(n) = 2ⁿ 时，时间复杂度为 O(2ⁿ)，称为指数阶</li>\n<li>f(n) = n! 时，时间复杂度为 O(n!)，称为阶乘阶</li>\n<li>f(n) = √n 时，时间复杂度为 O(√n)，称为平方根阶</li>\n</ul>\n<hr>\n<h4 id=\"时间复杂度的比较\"><a href=\"#时间复杂度的比较\" class=\"headerlink\" title=\"时间复杂度的比较\"></a>时间复杂度的比较</h4><p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201103001513219.png\" alt=\"image-20201103001513219\"></p>\n<p>在上图中，X 轴代表 n 值，Y 轴代表时间复杂度。时间复杂度随着 n 值得变化而变化，可以看到，O(n)、O(logn)、O(√n )、O(nlogn )随着 n 的增加，复杂度提升不大，而 O(2ⁿ) 和 O(n!)  在 n 值较大时变化非常之大。实际上，在 n 等于 50 时，O(2ⁿ) 和 O(n!)  的复杂度就已经突破十位数了</p>\n<p>常用的时间复杂度按照耗费的时间从小到大依次是：</p>\n<p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n²) &lt; O(n³) &lt; O(2ⁿ) &lt; O(n!)</p>\n<hr>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"数组的概念\"><a href=\"#数组的概念\" class=\"headerlink\" title=\"数组的概念\"></a>数组的概念</h3><p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201104232327992.png\" alt=\"image-20201104232327992\"></p>\n<p>定义：数组（Array）是一种线性表数据结构，他用一组连续的内存空间，来存储一组具有相同类型的数据</p>\n<ol>\n<li><p>线性表</p>\n<p>所谓线性表，指的是每个元素最多只有前后两个方向，像一条线一样进行排列，除了数组，链表、队列、栈等都是线性表</p>\n</li>\n<li><p>连续的内存空间和相同类型的数据</p>\n</li>\n</ol>\n<p>正是因为这两点，才使得数组拥有了它的核心特性 – 随机访问</p>\n<p><strong>随机访问</strong></p>\n<p>所谓随机访问，指的是能够随意访问数组中的任意一个元素，比如我想访问第 n 个元素，那么该元素的起始位置就是：</p>\n<p>​        第 n 个元素的起始位置 = 第 1 个元素的起始位置  + 下标（从0开始）* 元素的长度</p>\n<p>而不是从第 1 个元素开始，依次访问第 2 个、第 3个 …，直到访问到第 n 个为止</p>\n<hr>\n<h3 id=\"数组的操作\"><a href=\"#数组的操作\" class=\"headerlink\" title=\"数组的操作\"></a>数组的操作</h3><ul>\n<li>数组支持随机访问，根据下标获取指定元素的时间复杂度为 O(1)</li>\n<li>如果想获取数组中指定某个值的元素的话，时间复杂度就变成了 O(n)；如果是有序数组的话，使用二分法，可以将时间复杂度将为 O(logn)</li>\n<li>数组为了保证内存数据的连续性，会导致插入、删除这两个操作比较低效</li>\n</ul>\n<h4 id=\"数组的插入\"><a href=\"#数组的插入\" class=\"headerlink\" title=\"数组的插入\"></a>数组的插入</h4><ol>\n<li>从头部和中间插入<ul>\n<li>如果是无序数组的话，最简单的插入方式是将要插入的第 k 个位置的元素移到最末尾，然后将新元素放入第 k 个位置，这种插入方法的时间复杂度为 O(1)</li>\n<li>如果是有序数组的话，向第 k 个位置插入元素，那么位置 k 后的所有元素都需要向后移动一位，这种情况下最坏的时间复杂度可达到 O(n)</li>\n</ul>\n</li>\n<li>从尾部插入<ul>\n<li>从尾部插入数据的话只需要直接在数据末尾添加一个元素即可，不需要移动其它元素，时间复杂度为 O(1)</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"数组的删除\"><a href=\"#数组的删除\" class=\"headerlink\" title=\"数组的删除\"></a>数组的删除</h4><ol>\n<li>删除头部和中间元素<ul>\n<li>为了保证数组中数据的连续性，数组中间的第 k 个元素删除之后，位置 k 之后的所有元素都需要向前移动一位，最坏时间复杂度为 O(n)</li>\n</ul>\n</li>\n<li>删除尾部元素<ul>\n<li>删除尾部元素不需要移动元素，只需要将末尾元素删除即可，时间复杂度为 O(1)</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>在 Java 中，我们可以自己创建并维护一个数组，也可以使用 Java 提供的数组容器类 ArrayList。相比于自建数组，ArrayList 提供了一些高级功能，比如自动扩容、泛型、更方便的处理元素等等</p>\n<p>在我们使用数组时，除非已知数组的所有元素并且几乎不再更改，否则都会使用 ArrayList 来进行数组的相关操作</p>\n<p>ArrayList 并不是线程安全的，如果我们想要保障 ArrayList 的线程安全，需要自己使用 Synchronized 关键字维护，或者调用 Collections.synchronizedList() 方法，获得一个线程安全的 ArryList，或者直接使用 JUC 包中的 CopyOnWriteArrayList</p>\n<p>ArrayList 继承了 RandomAccess 接口，进入这个接口会发现 RandomAccess 接口中并无任何的变量或方法。事实上，这是一个“标志”接口，标志这 ArrayList 这个类具备随机访问的特性</p>\n<hr>\n<h4 id=\"主要的成员变量\"><a href=\"#主要的成员变量\" class=\"headerlink\" title=\"主要的成员变量\"></a>主要的成员变量</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Default initial capacity.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<p>ArrayList 的初始数组长度为 10</p>\n<hr>\n<h4 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h4><p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201107180130865.png\" alt=\"image-20201107180130865\"></p>\n<ul>\n<li><p>无参构造方法</p>\n<p>返回一个空数组，在第一次往数组里添加元素的时候才赋予数组长度，初始长度为 0</p>\n</li>\n<li><p>int 类型参数构造方法</p>\n<p>返回一个指定长度的数组，入参为 0 的时候返回一个空数组，与无参构造方法类似，入参小于 0 则抛出异常</p>\n</li>\n<li><p>Collection 类型参数构造方法</p>\n<p>传入一个 Collection 集合，将该集合转为 ArrayList 数组</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"扩容机制\"><a href=\"#扩容机制\" class=\"headerlink\" title=\"扩容机制\"></a>扩容机制</h4><p>调用 ArrayList 的 add() 方法时，ArrayList 都会先判断一下当前数组是否已满，如果已经满了的话，就会调用 grow() 方法进行扩容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Object[] grow(<span class=\"keyword\">int</span> minCapacity) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (oldCapacity &gt; <span class=\"number\">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> newCapacity = ArraysSupport.newLength(oldCapacity,</span><br><span class=\"line\">                minCapacity - oldCapacity, <span class=\"comment\">/* minimum growth */</span></span><br><span class=\"line\">                oldCapacity &gt;&gt; <span class=\"number\">1</span>           <span class=\"comment\">/* preferred growth */</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> elementData = <span class=\"keyword\">new</span> Object[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>add() 方法在调用 grow() 方法时，传入的 minCapacity 的值为 size+1，但是 ArraysSupport.newLength() 会判断 minCapacity 的值和 oldCapacity &gt;&gt; 1（即原数组长度的一半）哪个更大，原数组长度加上两者之间的大者即为扩容后的新数组的长度。因此通常情况下扩容后的容量为原容量的 1.5 倍</p>\n<p><strong>自动扩容带来的问题</strong></p>\n<p>数字的自动扩容会带来一些空间资源的浪费，有时候只是想往数组中添加一个元素，长度加 1 即可，但是却让数组长度变成了原来的 1.5倍。在数组长度较小的时候，些许的浪费无伤大雅，但是当数据量较大时，带来的资源浪费就显得没必要了</p>\n<p><strong>解决方法</strong></p>\n<ul>\n<li>如果在创建数组时便知道数组的长度，就可以使用 ArrayList 的 int 类型参数构造方法来创建一个指定长度的数组了</li>\n<li>如果在创建数组的时候并不知道数组的长度，但是在插入数组的时候知道了，那么可以使用 ensureCapacity() 方法来将数组扩容到想要的长度</li>\n<li>还可以在数组插入完成之后，调用 trimToSize() 方法，将数组多余的长度清空掉</li>\n</ul>\n<hr>\n<h4 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h4><p>迭代器 Iterator 是一种设计模式，所有的 Collections 集合类都有实现这种设计模式，为得是提供一套统一的 API 来操作元素</p>\n<p>迭代器有两种属性，fail-fast 和 fail-safe</p>\n<ul>\n<li><p>fail-fast</p>\n<p>ArrayList 会维护一个 modCount 变量，每次对数组的增删改操作都会将 modCount 加 1。迭代器在遍历元素时直接获取原有集合的内容，在操作过程中如果发现 modCount 的值发生了变化，就会抛出异常</p>\n</li>\n<li><p>fail-safe</p>\n<p>迭代器在遍历元素时，会将原有集合复制出来一份，然后在复制出来的这个集合上进行操作。这样做避免了抛出异常，但是原有集合上的操作并不能被迭代器检测到</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><h3 id=\"链表的概念\"><a href=\"#链表的概念\" class=\"headerlink\" title=\"链表的概念\"></a>链表的概念</h3><p>数组是使用最广泛的一种通用数据结构，但是也不可避免的存在着一些缺陷。在无序数组中，搜索是低效的；而在有序数组中，插入效率又很低；而不管再哪一种数组中，删除效率都很低；并且一个数组在创建后，它的大小是不可改变的。而链表则可以解决上面的一些问题</p>\n<p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。每个元素节点除了存储自己的数据域之外，还存储着下一个节点的指针域</p>\n<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201110211256134.png\" alt=\"image-20201110211256134\"></p>\n<p>链表需通过头元素一个一个遍历才能找到目标元素，不支持随机访问。但是链表的增删操作只需要改变节点的指针域即可，不需要移动元素，增删速度较快。除非需要频繁通过下标访问元素，否则很多使用数组的地方都可以使用链表代替。而链表也是除数组外运用第二广泛的通用数据结构</p>\n<hr>\n<h3 id=\"链表的操作\"><a href=\"#链表的操作\" class=\"headerlink\" title=\"链表的操作\"></a>链表的操作</h3><h4 id=\"链表的基本结构\"><a href=\"#链表的基本结构\" class=\"headerlink\" title=\"链表的基本结构\"></a>链表的基本结构</h4><p>链表作为一个集合，首先需要知道头节点的位置，否则即使查询也不知道从何查起。而集合中存储着一系列的节点，这些节点既需要保存着自己的数据域，还需要保存着下一个节点的位置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkList</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 头节点</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Link fisrt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Link</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 指向下一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Link next;</span><br><span class=\"line\">        <span class=\"comment\">// 数据域</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Object data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这是一个链表最基本的组成，还可以通过添加其它属性和方法来丰富这个链表，比如添加 size 属性，获得这个链表的长度；还可添加 Link last 属性，来更快的找到尾节点等等</p>\n<hr>\n<h4 id=\"链表的查询\"><a href=\"#链表的查询\" class=\"headerlink\" title=\"链表的查询\"></a>链表的查询</h4><p>不管是查询指定值的节点，还是查询第 k 个元素，链表都需要从头节点一个个遍历，因此链表查询的时间复杂度固定为 O(n)</p>\n<hr>\n<h4 id=\"链表的插入和删除\"><a href=\"#链表的插入和删除\" class=\"headerlink\" title=\"链表的插入和删除\"></a>链表的插入和删除</h4><p>链表删除节点 k，只需要将节点 k-1 的指针域执行节点 k+1 即可，时间复杂度为 O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Link removeLink)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取被删除节点的上一个节点</span></span><br><span class=\"line\">    Link preLink = removeLink.pre;</span><br><span class=\"line\">    <span class=\"comment\">// 将上一个节点的指针域只想被删除节点的下一个节点</span></span><br><span class=\"line\">    preLink.next = removeLink.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>链表想在节点 k 和 k+1 之间插入一个元素，需要将节点 k 的指针域指向插入的节点，然后将插入节点的指针域指向节点 k+1，时间复杂度为 O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Link preLink, Link insertLink)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// preLink为节点k，通过节点k获取节点k+1</span></span><br><span class=\"line\">    Link afterLink = preLink.next;</span><br><span class=\"line\">    <span class=\"comment\">// 将节点k的指针域指向插入的节点</span></span><br><span class=\"line\">    preLink.next = insertLink;</span><br><span class=\"line\">    <span class=\"comment\">// 将插入节点的指针域指向节点k+1</span></span><br><span class=\"line\">    insertLink.next = afterLink;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"不同类型的链表\"><a href=\"#不同类型的链表\" class=\"headerlink\" title=\"不同类型的链表\"></a>不同类型的链表</h3><ul>\n<li><p>单向链表</p>\n<p>像上面这样只能从上一个节点获取下一个节点的链表，称为单项链表</p>\n</li>\n<li><p>双向链表</p>\n<p>如果链表中的节点不仅存储着下一个节点的指针域，还存储着上一个节点的指针域，这种链表称为双向链表</p>\n</li>\n<li><p>循环链表</p>\n<p>链表的尾节点又重新指向头节点，形成了一个圈，这种链表称为循环链表</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h3><h4 id=\"主要的成员变量-1\"><a href=\"#主要的成员变量-1\" class=\"headerlink\" title=\"主要的成员变量\"></a>主要的成员变量</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Pointer to first node.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; first;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Pointer to last node.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>LinkedList 只有三个成员变量，size 用于记录集合中的元素个数，first 和 last 分别指向头节点和尾节点</p>\n<h4 id=\"Node节点元素\"><a href=\"#Node节点元素\" class=\"headerlink\" title=\"Node节点元素\"></a>Node节点元素</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    E item;</span><br><span class=\"line\">    Node&lt;E&gt; next;</span><br><span class=\"line\">    Node&lt;E&gt; prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.item = element;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.prev = prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>可以看出，LinkedList 的节点元素既可以指向上一个元素，也可以指向下一个元素，所以 LinkedList 是一个双向链表</p>\n<hr>\n<h4 id=\"构造方法-1\"><a href=\"#构造方法-1\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h4><p><strong>无参构造方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Java 15 中，LinkedList 的无参构造方法会返回一个空集合，头节点和尾节点都是 null</p>\n<p><strong>有参构造方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>();</span><br><span class=\"line\">    addAll(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>LinkedList 的有参构造方法可以传入一个集合，将这个集合转为 LinkedList</p>\n<p>相比与 ArrayList，LinkedList 无须扩容，新增和删除的实现方式也比较简单</p>\n<hr>\n<h2 id=\"栈和队列\"><a href=\"#栈和队列\" class=\"headerlink\" title=\"栈和队列\"></a>栈和队列</h2><h3 id=\"抽象数据类型（ADT）\"><a href=\"#抽象数据类型（ADT）\" class=\"headerlink\" title=\"抽象数据类型（ADT）\"></a>抽象数据类型（ADT）</h3><p>抽象数据类型（Abstract Data Type，ADT）是带有一组操作的一些对象的集合。抽象数据类型是数学的抽象，在 ADT 的定义中没有地方提到关于这组操作是如何实现的具体解释。比如我们定义了线性表（List）这么一个 ADT，要求元素像一条线一样只有前后两个方向排列，那么只要满足了这个要求的，都可以看作线性表 ADT 的具体实现</p>\n<p>Java 也考虑了 ADT 的实现，不过适当了隐藏了实现的细节。最直观的方式就是“接口”，Java 中有 List 接口，只有实现了这个接口的类，都是 List 的具体实现类，例如 ArrayList、LinkedList，还有后续的 Deque、Stack等，都可以看作一个List。而在 Java 中，这就是对象多态的体现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;String&gt; list1 = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    List&lt;String&gt; list2 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        </span><br><span class=\"line\">    list1.add(<span class=\"string\">&quot;list1&quot;</span>);</span><br><span class=\"line\">    list2.add(<span class=\"string\">&quot;list2&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如上所示，我们可以只需要获得一个 List集合，然后支持 List 集合的方法即可，而不关系它究竟是 ArrayList 还是 LinkedList</p>\n<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201115151509347.png\" alt=\"image-20201115151509347\"></p>\n<p><strong>此图只是对ADT的简单展示，Java中数据结构中的层次远比这个复杂得多</strong></p>\n<p>不同的 ADT 之间也有着不同的关系，如上图所示，可以有层级关系，如 List 和 Queue 之间；也有并列关系，如 List 和 Map 之间；还有可能什么关系也没有。我们可以根据自己的需求去选用合适的 ADT 实现类，如果我们想要个 List 集合的话，就去找一个实现了 List 集合接口的类；如果想要个 Queue 的话，就去找一个实现了 Queue 接口的类；如果当前存在的都不满足需求的话，我们也可以自己实现一个，只要实现了对应的 ADT 接口即可</p>\n<hr>\n<h3 id=\"栈ADT\"><a href=\"#栈ADT\" class=\"headerlink\" title=\"栈ADT\"></a>栈ADT</h3><h4 id=\"栈模型\"><a href=\"#栈模型\" class=\"headerlink\" title=\"栈模型\"></a>栈模型</h4><p>栈（Stack）是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈的顶（top）。对栈的基本操作有 push（进栈）和 pop（出栈），前者相当于插入，后者则是删除最后插入的元素。最后插入的元素可以通过 top 例程在执行 pop 之前进行考察。对空栈进行 top 或 pop 操作一般被认为栈 ADT 中的一个错误。另一方面，当运行 push 时空间用尽是一个实现限制，但不是 ADT 错误</p>\n<p>栈有时又叫做 LIFO（后进先出）表。普通的清空栈的操作和判断是否空栈的操作都是栈的操作系统指令的一部分。但是，我们对栈所能够做的，基本上也就是 pop 和 push 操作</p>\n<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201115170259354.png\" alt=\"image-20201115170259354\"></p>\n<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201115170423180.png\" alt=\"image-20201115170423180\"></p>\n<hr>\n<h3 id=\"队列ADT\"><a href=\"#队列ADT\" class=\"headerlink\" title=\"队列ADT\"></a>队列ADT</h3><h4 id=\"队列模型\"><a href=\"#队列模型\" class=\"headerlink\" title=\"队列模型\"></a>队列模型</h4><p>像栈一样，队列也是表。但是，使用队列时插入在一段进行而删除则在另一端进行</p>\n<p>队列的基本操作是 enqueue（入队），它是在表的末端（叫做队尾 rear）插入一个元素；以及 dequeue（出队），它是返回并删除在表开头（叫做对头 front）的元素。队列，也叫做 FIFO（先进先出）表</p>\n<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201115195545751.png\" alt=\"image-20201115195545751\"></p>\n<hr>\n<h3 id=\"栈的具体实现\"><a href=\"#栈的具体实现\" class=\"headerlink\" title=\"栈的具体实现\"></a>栈的具体实现</h3><h4 id=\"栈的实现\"><a href=\"#栈的实现\" class=\"headerlink\" title=\"栈的实现\"></a>栈的实现</h4><p>由于栈是一个表，因此任何实现表的方法都能实现栈。显然，ArrayList 和 LinkedList 都支持栈操作，99% 的时间它们都是最合理的选择。偶尔设计一种特殊目的的实现可能会更快。因为栈操作的时间复杂度为 O(1)，所以，除非在非常独特的环境下，这是不可能产生任何明显的改进的。对于这些特殊的时机，一般给出了两种流行的实现方法，一种方法使用链式结构，而另一种方法使用数组，二者均简化了在 ArrayList 和 LinkedList 中的逻辑</p>\n<hr>\n<h4 id=\"栈的链式实现\"><a href=\"#栈的链式实现\" class=\"headerlink\" title=\"栈的链式实现\"></a>栈的链式实现</h4><p>栈的第一种实现方法是使用单链表，通过在表的顶端插入来实现 push，通过删除表顶端元素来实现 pop。top 操作只是考查表顶端元素并返回它的值，有时 pop 操作和 top操作合二为一</p>\n<hr>\n<h4 id=\"栈的数组实现\"><a href=\"#栈的数组实现\" class=\"headerlink\" title=\"栈的数组实现\"></a>栈的数组实现</h4><p>另一种方式避免了链并且可能是更流行的解决方案。由于模仿 ArrayList 的 add 操作，因此相应的实现方式非常简单。与每个栈相关联的操作是 theArray 和 topOfStack，对于空栈它是 -1，这就是空栈初始化的做法。为将某个元素 x 推入栈中，我们是 topOfStack 增 1 然后置 theArray[topOfStack] = x。为了弹出栈元素，我们置返回值为 theArray[topOfStack] 然后使 topOfStack 减 1</p>\n<p>注意，这些操作不仅以常数时间运行，而且是以非常快的常数时间运行。在某些机器上，若在带有自增和自减寻址功能的寄存器上操作，则（整数的）pop 和 push 都可以写成一条机器指令。最现代化的计算机将栈操作作为它指令系统的一部分，这个事实强化了这样一种观念，即栈很可能是计算机科学中在数组之后的最基本的数据结构</p>\n<hr>\n<h3 id=\"队列的具体实现\"><a href=\"#队列的具体实现\" class=\"headerlink\" title=\"队列的具体实现\"></a>队列的具体实现</h3><h4 id=\"队列的链表实现\"><a href=\"#队列的链表实现\" class=\"headerlink\" title=\"队列的链表实现\"></a>队列的链表实现</h4><p>同栈一样，任何表都可以实现队列，而使用链表来实现队列是最简单的。入队对应的就是 LinkedList 的 add 操作，而出队则是取出 first 元素，并将 first 指向后一个元素即可</p>\n<hr>\n<h4 id=\"队列的数组实现\"><a href=\"#队列的数组实现\" class=\"headerlink\" title=\"队列的数组实现\"></a>队列的数组实现</h4><p>对于每一个队列数据结构，我们保留一个数组 theArray 以及位置 front 和 back，他们代表队列的两端。还要记录实际存在与队列中的元素个数 currentSize，下图表示处于某个中间状态的队列</p>\n<p><img src=\"C:\\Users\\A\\Desktop\\image-20201119210337396.png\" alt=\"image-20201119210337396\"></p>\n<p>为使一个元素 x 入队（即执行 enqueue），我们让 currentSize 和 back 置 1，然后置 theArray[back] = x。若是元素  dequeue（出队），我们置返回值为 theArray[front]，且 currentSize 和 front 都增 1</p>\n<p>上述实现存在着一个潜在的问题，经过 10 次 enqueue 之后队列似乎是满了，因为 back 现在是数组的最后一个下标，而下一次再 enqueue 就会是一个不存在的位置。然而，队列中也许只存在几个元素，因为若干元素可能已经出队了。像栈一样，即使在有许多操作的情况下队列也常常不是很大</p>\n<p>简单的解决办法是，只要 front 或 back 到达数组的尾端，它就又绕回开头，这就是循环数组</p>\n<hr>\n<h4 id=\"双端队列\"><a href=\"#双端队列\" class=\"headerlink\" title=\"双端队列\"></a>双端队列</h4><p>栈和队列都是线性表的一种，且二者添加元素都是在线性表的尾部新增元素。不同的是，取出元素的时候，栈是从尾部取出的，而队列是从头部取出的。那么如果有一个线性表，既可以从头部取出元素，也可以从尾部取出元素，那么它就具备了栈和队列的双重特性，而像这样可以从两端弹出元素的线性表，则称之为双端队列</p>\n<p>双端队列让我们可以更自由的操作线性表中的元素，还可以减少代码的实现。如果想使用队列，则只从表的头部取出元素，如果想使用栈，则只从尾部取出元素。双端队列将栈和队列的抽象从数据结构层转移到了代码层，如果我们想固定使用某一种结构的话，就需要严格调用该结构对应的方法，否则就会使线性表中的元素混乱</p>\n<p>Java 将双端队列定义为一个接口 Deque，以下是 Deque 接口常用的一些方法：</p>\n<ul>\n<li>push：像尾部添加元素</li>\n<li>pop：移除尾部元素并返回它的值</li>\n<li>poll：将头部元素弹出，如果表为空就返回 null</li>\n<li>peek：查看头部元素，不会移除，如果是空就返回 null</li>\n<li>element：查看头部元素，不会移除，如果是空就抛出异常</li>\n</ul>\n<hr>\n<h3 id=\"JAVA-中的栈和队列\"><a href=\"#JAVA-中的栈和队列\" class=\"headerlink\" title=\"JAVA 中的栈和队列\"></a>JAVA 中的栈和队列</h3><h4 id=\"LinkedList-1\"><a href=\"#LinkedList-1\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h4><p>查看 LinkedList 的源码，会发现它实现了 Deque 接口，这意味着 LinkedList 也是也是一个双端队列。所以由链表实现的栈和由链表实现的队列都是 LinkedList</p>\n<hr>\n<h4 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h4><p>Stack 是由数组实现的栈，它继承了 Vector 类，Vector 是线程安全的 ArrayList，Stack 调用的也是它的方法，这意味着 Stack 也是线程安全的栈</p>\n<hr>\n<h4 id=\"ArrayQueue\"><a href=\"#ArrayQueue\" class=\"headerlink\" title=\"ArrayQueue\"></a>ArrayQueue</h4><p>ArrayQueue 是用数组实现的队列，底层的数据结构也是上文提到的循环数组</p>\n<p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201121224210165.png\" alt=\"image-20201121224210165\"></p>\n<p>上图分别是队空时和队满时的两种状态，当队空时，头坐标和尾坐标指向同一个元素，即 front = rear；当队满时，尾坐标在头坐标的前一个位置，而头坐标指向的位置没有放置元素，这意味着循环数组能够放置的元素数量会比数组的长度小一个</p>\n<p>我们也可用一个状态标识 empty 来区分当前队列是空还是满，队列初始化时 full为 false，而当 rear 在 front 前一个位置时，我们再往其中添加一个元素，此时 full 就变成了 true，此时如果有元素出队的话，full 再重新变为 false</p>\n</br>\n\n<p><strong>成员变量</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 队列可容纳元素的数量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\"><span class=\"comment\">// 放置元素的数组</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> T[] queue;</span><br><span class=\"line\"><span class=\"comment\">// 头元素下标</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> head;</span><br><span class=\"line\"><span class=\"comment\">// 尾元素下标</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> tail;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>构造方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 为了让队列可容纳元素的数量为构造方法传入的值，将传入的capacity的值加1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.capacity = capacity + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.queue = newArray(capacity + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 初始化时头尾坐标均指向0</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.head = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.tail = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>扩容</strong></p>\n<p>当 ArrayQueue 满了的时候，我们再往里面添加元素会抛出异常，如果当前队列的大小不满足需求的话，需要我们调用 resize() 方法进行扩容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> newcapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// resize方法不仅可以扩容，还可以缩容，如果新队列的长度小于实际元素个数的话就会抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newcapacity &lt; size)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(<span class=\"string\">&quot;Resizing would lose data&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 队列长度为目标长度+1</span></span><br><span class=\"line\">    newcapacity++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newcapacity == <span class=\"keyword\">this</span>.capacity)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    T[] newqueue = newArray(newcapacity);</span><br><span class=\"line\">    <span class=\"comment\">// get(i)是循环将头节点和尾节点的元素取出</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">        newqueue[i] = get(i);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.capacity = newcapacity;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.queue = newqueue;</span><br><span class=\"line\">    <span class=\"comment\">// 新队列的头节点为0</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.head = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.tail = size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</br>\n\n<p><strong>入队</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(T o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先给队尾添加值，再判断是否队满</span></span><br><span class=\"line\">    queue[tail] = o;</span><br><span class=\"line\">    <span class=\"comment\">// 判断队满的方式：(tail + 1) % capacity == head</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newtail = (tail + <span class=\"number\">1</span>) % capacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newtail == head)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(<span class=\"string\">&quot;Queue full&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 队列没满的情况下，队尾下标才会后移一位</span></span><br><span class=\"line\">    tail = newtail;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; <span class=\"comment\">// we did add something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先插入元素再判断队列有没有满，这样队尾下标元素实际上是有值的，但是我们无法取得而已。并且每次添加元素都会把之前的值覆盖掉</p>\n</br>\n\n<p><strong>出队</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 队列只能从头元素开始取</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Can only remove head of queue&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 当 head == tail 的时候队列为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == tail)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(<span class=\"string\">&quot;Queue empty&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 获取头元素</span></span><br><span class=\"line\">    T removed = queue[head];</span><br><span class=\"line\">    <span class=\"comment\">// 将头元素置空</span></span><br><span class=\"line\">    queue[head] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 头元素下标加1</span></span><br><span class=\"line\">    head = (head + <span class=\"number\">1</span>) % capacity;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> removed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><h3 id=\"什么是树\"><a href=\"#什么是树\" class=\"headerlink\" title=\"什么是树\"></a>什么是树</h3><h4 id=\"树的简介\"><a href=\"#树的简介\" class=\"headerlink\" title=\"树的简介\"></a>树的简介</h4><p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201124204551109.png\" alt=\"image-20201124204551109\"></p>\n<p>树是一种抽象数据类型或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>\n<ol>\n<li>每个节点有零个或多个子节点；</li>\n<li>没有父节点的节点称为根节点；</li>\n<li>每一个非根节点有且只有一个父节点；</li>\n<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>\n</ol>\n<hr>\n<h4 id=\"树的术语\"><a href=\"#树的术语\" class=\"headerlink\" title=\"树的术语\"></a>树的术语</h4><p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201124221707828.png\" alt=\"image-20201124221707828\"></p>\n<ul>\n<li>结点：使用树存储结构存储的每一个数据元素都被称为结点</li>\n<li>路径：顺着连接结点的边从一个结点走到另一个节点，所经过的结点顺序排列就称为路径</li>\n<li>根结点：树顶端的结点称为根结点，如果一个结点没有父结点，那么它就是整棵树的根节点，上图的根结点就是 A</li>\n<li>父结点：每个结点（除根结点）都恰好有一条边向上连接到另一个结点，上面这个结点就称为下面这个结点的父结点</li>\n<li>子结点：与父结点相反，比如 B 是 E 的父结点，那么 E 就是 B 的子结点</li>\n<li>叶结点：如果结点没有任何子结点，那么此结点称为叶结点</li>\n<li>空树：如果集合本身为空，那么构成的树就为空树，空树没有结点</li>\n<li>子树：全部由子结点构成的树称为子树，如上图，整个是一棵树，B、E、F、K、L 也可看作一棵树，E、K、L也可看作一棵树，它们都可看作这棵树的子树</li>\n<li>结点的度：对于一个结点，拥有的子树数（结点有多少分支）称为结点的度</li>\n<li>结点的层次：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推</li>\n<li>树的深度：一棵树的深度（高度）是树中结点所在的最大的层次</li>\n<li>有序树和无序树：如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为有序树；反之称为无序树</li>\n<li>森林：由 m（m &gt;= 0）个互不相交的树组成的集合被称为森林</li>\n</ul>\n<hr>\n<h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><h4 id=\"二叉树的定义\"><a href=\"#二叉树的定义\" class=\"headerlink\" title=\"二叉树的定义\"></a>二叉树的定义</h4><p>简单地理解，满足以下两个条件的树就是二叉树：</p>\n<ol>\n<li>本身是有序树</li>\n<li>树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2</li>\n</ol>\n<p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201211175500008.png\" alt=\"image-20201211175500008\"></p>\n<hr>\n<h4 id=\"二叉树的性质\"><a href=\"#二叉树的性质\" class=\"headerlink\" title=\"二叉树的性质\"></a>二叉树的性质</h4><ol>\n<li>二叉树中，第 i 层最多有 2^(i-1) 个结点</li>\n<li>如果二叉树的深度为 K，那么此二叉树最多有 2^(K-1) 个结点</li>\n<li>二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1</li>\n</ol>\n<hr>\n<h4 id=\"满二叉树\"><a href=\"#满二叉树\" class=\"headerlink\" title=\"满二叉树\"></a>满二叉树</h4><p>如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树</p>\n<p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201211180057924.png\" alt=\"image-20201211180057924\"></p>\n<p>满二叉树除了满足普通二叉树的性质，还具有以下性质：</p>\n<ol>\n<li>满二叉树中第 i 层的节点数为 2^(n-1) 个</li>\n<li>深度为 k 的满二叉树必有 2^(k-1) 个节点 ，叶子数为 2^(k-1)</li>\n<li>满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层</li>\n<li>具有 n 个节点的满二叉树的深度为 log2(n+1)</li>\n</ol>\n<hr>\n<h4 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h4><p>如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树</p>\n<p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201212192543825.png\" alt=\"image-20201212192543825\"></p>\n<p>对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号，对于任意一个结点 i ，完全二叉树还有以下几个结论成立：</p>\n<ol>\n<li>当 i&gt;1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）</li>\n<li>如果 2<em>i&gt;n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2</em>i </li>\n<li>如果 2<em>i+1&gt;n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2</em>i+1 </li>\n</ol>\n<hr>\n<h3 id=\"二叉树的结构\"><a href=\"#二叉树的结构\" class=\"headerlink\" title=\"二叉树的结构\"></a>二叉树的结构</h3><h4 id=\"二叉树的顺序储存结构\"><a href=\"#二叉树的顺序储存结构\" class=\"headerlink\" title=\"二叉树的顺序储存结构\"></a>二叉树的顺序储存结构</h4><p>二叉树的顺序存储，指的是使用数组存储二叉树。需要注意的是，顺序存储只适用于完全二叉树。换句话说，只有完全二叉树才可以使用顺序表存储。因此，如果我们想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树</p>\n<p>完全二叉树的顺序存储，仅需从根节点开始，按照层次依次将树中节点存储到数组即可</p>\n<p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210103150636489.png\" alt=\"image-20210103150636489\"></p>\n<hr>\n<h4 id=\"二叉树的链式存储结构\"><a href=\"#二叉树的链式存储结构\" class=\"headerlink\" title=\"二叉树的链式存储结构\"></a>二叉树的链式存储结构</h4><p>其实二叉树并不适合用数组存储，因为并不是每个二叉树都是完全二叉树，普通二叉树使用顺序表存储或多或多会存在空间浪费的现象。而一棵普通的二叉树，若将其采用链式存储，则只需从树的根节点开始，将各个节点及其左右孩子使用链表存储即可</p>\n<p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210103151203203.png\" alt=\"image-20210103151203203\"></p>\n<p>采用链式存储二叉树时，其节点结构由三部分组成</p>\n<ul>\n<li>指向左孩子节点的指针（leftChild）</li>\n<li>节点存储的数据（data）</li>\n<li>指向右孩子节点的指针（rightChild）</li>\n</ul>\n<p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210103151359861.png\" alt=\"image-20210103151359861\"></p>\n<p>我们还可以在该节点中添加一个指针，指向该结点的父节点。这样的链表结构，称为三叉链表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node leftChild;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object Data;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node rightChild;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node parent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h3><p>所谓遍历(Traversal)是指沿着某条搜索路线，依次对树中每个结点均做一次且仅做一次访问。访问结点所做的操作依赖于具体的应用问题。 遍历是二叉树上最重要的运算之一，是二叉树上进行其它运算之基础</p>\n<p>二叉树的遍历主要有以下四种方式：</p>\n<ul>\n<li>前序遍历</li>\n<li>中序遍历</li>\n<li>后序遍历</li>\n<li>层序遍历</li>\n</ul>\n<h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210103183839223.png\" alt=\"image-20210103183839223\"></p>\n<p>二叉树前序遍历的实现思想是：</p>\n<ol>\n<li>访问根节点</li>\n<li>访问当前节点的左子树</li>\n<li>若当前节点无左子树或左子树已访问过，继续访问当前节点的右子树</li>\n</ol>\n<p>因此，以上二叉树采用前序遍历得到的序列为：1245367</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 前序遍历代码实现</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">preOrderTraveral</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(node.data.toString());</span><br><span class=\"line\">    preOrderTraveral(node.leftChild);</span><br><span class=\"line\">    preOrderTraveral(node.rightChild);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><p>二叉树中序遍历的实现思想是：</p>\n<ol>\n<li>访问当前节点的左子树</li>\n<li>访问根节点</li>\n<li>访问当前节点的右子树</li>\n</ol>\n<p>因此，以上二叉树采用中序遍历得到的序列为：4251637</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 中序遍历代码实现</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inOrderTraveral</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    inOrderTraveral(node.leftChild);</span><br><span class=\"line\">    System.out.println(node.data.toString());</span><br><span class=\"line\">    inOrderTraveral(node.rightChild);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><p>二叉树前序遍历的实现思想是：</p>\n<ol>\n<li>访问当前节点的左子树</li>\n<li>访问当前节点的右子树</li>\n<li>访问当前节点</li>\n</ol>\n<p>因此，以上二叉树采用中序遍历得到的序列为：1376254</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 后序遍历代码实现</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postOrderTraveral</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    postOrderTraveral(node.leftChild);</span><br><span class=\"line\">    postOrderTraveral(node.rightChild);</span><br><span class=\"line\">    System.out.println(node.data.toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h4 id=\"层序遍历\"><a href=\"#层序遍历\" class=\"headerlink\" title=\"层序遍历\"></a>层序遍历</h4><p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210110194451416.png\" alt=\"image-20210110194451416\"></p>\n<p>二叉树层序遍历的实现思想是：</p>\n<ol>\n<li>通过使用队列的数据结构，从树的根节点开始，先入队，再出队</li>\n<li>出队的同时，将根节点的左右子结点分别入队</li>\n<li>此后每次出队操作，都将该节点的左右孩子节点入队，知道树中的所有结点都出队</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 层序遍历代码实现</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">levelOrder</span><span class=\"params\">(Node root)</span> </span>&#123;</span><br><span class=\"line\">    LinkedList&lt;Node&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    queue.add(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">        node = queue.pop();</span><br><span class=\"line\">        System.out.println(node.data.toString());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.leftChild != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            queue.add(node.leftChild);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.rightChild != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            queue.add(node.rightChild);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"线索二叉树\"><a href=\"#线索二叉树\" class=\"headerlink\" title=\"线索二叉树\"></a>线索二叉树</h3><h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>普通的二叉树，不管形态如何，空链域的个数总是多过非空链域的个数。所谓空链域，指的是孩子节点为 null 的指针域。实际上，n 个节点的二叉树共有 2n 个链域，其中非空链域有 n - 1 个，而空链域却有 n + 1 个</p>\n<p>因此，我们可以利用这些空链域，指向该节点的前驱节点或者后继节点，这样就可以充分利用到这些空链域，提升遍历速度。所谓前驱节点和后继节点，指的是该二叉树遍历完成后顺序输出的顺序中，该节点的前一个节点和后一个节点。众所周知，使用不同的遍历方法遍历出来的节点顺序是不一样的，因此同一个二叉树使用不同的线索顺序，同一个节点的前驱和后继节点也可能是不一样的。这里我们主要介绍一下中序遍历线索二叉树</p>\n<p>使用空链域来指向前驱后继节点，我们就需要区分该节点的左右孩子节点指向的是自己的孩子还是前驱后继节点，因此我们需要增加两个标识位，leftTag 和 rightTag，当 tag 的值为 0 时说明指向的是自己的孩子节点，值为 1 时说明指向的是前驱或者后继节点</p>\n<p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210117135411299.png\" alt=\"image-20210117135411299\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object data;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node leftChild;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node rightChild;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer leftTag;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer rightTag;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h4 id=\"线索化\"><a href=\"#线索化\" class=\"headerlink\" title=\"线索化\"></a>线索化</h4><p>将一棵普通的二叉树转为线索二叉树，即将二叉树所有的空链域指向自己的前驱或者后继节点，这个过程称为线索化</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadTree</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node root;</span><br><span class=\"line\">    <span class=\"comment\">// 前驱节点</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node pre = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"> \t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> \t* 将以root为根节点的二叉树线索化 中序法</span></span><br><span class=\"line\"><span class=\"comment\"> \t**/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inThread</span><span class=\"params\">(Node root)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 找到该二叉树的最左孩子节点，该节点即为该二叉树的最前驱节点</span></span><br><span class=\"line\">        \tinThread(root.leftChild);</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span> (root.leftChild == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            \troot.setLeftTag(<span class=\"number\">1</span>);</span><br><span class=\"line\">                root.setLeftChild(pre);</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"keyword\">null</span> == pre.rightChild) &#123;</span><br><span class=\"line\">                pre.setRightTag(<span class=\"number\">1</span>);</span><br><span class=\"line\">                pre.setRightChild(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pre = root;</span><br><span class=\"line\">            inThread(root.rightChild);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"如何区分算法的好坏\"><a href=\"#如何区分算法的好坏\" class=\"headerlink\" title=\"如何区分算法的好坏\"></a>如何区分算法的好坏</h2><h3 id=\"算法的效率\"><a href=\"#算法的效率\" class=\"headerlink\" title=\"算法的效率\"></a>算法的效率</h3><p>虽然计算机能快速的完成运算处理，但实际上，它也需要根据输入数据的大小和算法效率来消耗一定的处理器资源。要想编写出能高效运行的程序，我们就需要考虑到算法的效率</p>\n<p>算法的效率主要由以下两个复杂度来评估：<br><strong>时间复杂度</strong>：评估执行程序所需的时间。可以估算出程序对处理器的使用程度<br><strong>空间复杂度</strong>：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度</p>\n<p>设计算法时，一般是要先考虑系统环境，然后权衡时间复杂度和空间复杂度，选取一个平衡点。不过，时间复杂度要比空间复杂度更容易产生问题，因此算法研究的主要也是时间复杂度，不特别说明的情况下，复杂度就是指时间复杂度</p>\n<hr>\n<h3 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><h4 id=\"大O表示法\"><a href=\"#大O表示法\" class=\"headerlink\" title=\"大O表示法\"></a>大O表示法</h4><p>算法的时间复杂度通常用大O符号表述，定义为T[n] = O(f(n))。称函数T(n)以f(n)为界或者称T(n)受限于f(n)。  如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)。T(n)称为这一算法的“时间复杂度”。当输入量n逐渐加大时，时间复杂度的极限情形称为算法的“渐近时间复杂度”</p>\n<p><strong>推导大O阶</strong></p>\n<ol>\n<li>用常数1来取代运行时间中所有加法常数。 </li>\n<li>修改后的运行次数函数中，只保留最高阶项 </li>\n<li>如果最高阶项存在且不是1，则去除与这个项相乘的常数</li>\n</ol>\n<hr>\n<h4 id=\"常见时间复杂度\"><a href=\"#常见时间复杂度\" class=\"headerlink\" title=\"常见时间复杂度\"></a>常见时间复杂度</h4><p><strong>常数阶</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 3行代码均只执行一次</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>, a = <span class=\"number\">1</span>;</span><br><span class=\"line\">sum = (a + <span class=\"number\">1</span>) * <span class=\"number\">2</span>;</span><br><span class=\"line\">System.out.println(sum);</span><br></pre></td></tr></table></figure>\n\n<p>上面算法的运行的次数的函数为 f(n)=3，根据推导大O阶的规则1，我们需要将常数3改为1，则这个算法的时间复杂度为 O(1)。如果 sum = (a + 1) * 2 这条语句再执行10次，这个算法的复杂度仍为 O(1)，因此称之为常数阶</p>\n<p><strong>线性阶</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 时间复杂度为O(1)的算法</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面算法循环体中的代码执行了 n 次，因此这个算法的时间复杂度为 O(n)</p>\n<p><strong>对数阶</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(a &lt; n) &#123;</span><br><span class=\"line\">\ta = a * <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 时间复杂度为O(1)的算法</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面算法中，随着 a 的每次乘 2，其数值都会越来越接近 n，直到大于 n，那么就将跳出循环。假设这个算法循环了 x 次，那么 2^x = n，可算得 x = logn。因此这个算法得时间复杂度为 O(logn)</p>\n<p><strong>平方阶</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;n; j++) &#123;</span><br><span class=\"line\">\t\t <span class=\"comment\">// 时间复杂度为O(1)的算法</span></span><br><span class=\"line\">    \t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面算法中，我们已知内层循环得时间复杂度为 O(n)，再经过外层循环 n 次，因此这个算法的时间复杂度为 O(n²)</p>\n<p>如果我们算得某个算法的时间复杂度为 f(n) = 5n³ + 3n + 2，那么根据推导大O阶的第二条规则，只保留最高阶，那么这个算法的时间复杂度就变成了 f(n) = 5n³，再根据推导大O阶的第三条规则，去掉常数项，因此这个算法最终算得的时间复杂度应该是 O(n³)</p>\n<hr>\n<h4 id=\"其它常见时间复杂度\"><a href=\"#其它常见时间复杂度\" class=\"headerlink\" title=\"其它常见时间复杂度\"></a>其它常见时间复杂度</h4><p>除了常数阶、线性阶、平方阶、对数阶，还有如下时间复杂度</p>\n<ul>\n<li>f(n) = nlogn 时，时间复杂度为 O(nlogn)，称为 nlogn 阶</li>\n<li>f(n) = n³ 时，时间复杂度为 O(n³)，称为立方阶</li>\n<li>f(n) = 2ⁿ 时，时间复杂度为 O(2ⁿ)，称为指数阶</li>\n<li>f(n) = n! 时，时间复杂度为 O(n!)，称为阶乘阶</li>\n<li>f(n) = √n 时，时间复杂度为 O(√n)，称为平方根阶</li>\n</ul>\n<hr>\n<h4 id=\"时间复杂度的比较\"><a href=\"#时间复杂度的比较\" class=\"headerlink\" title=\"时间复杂度的比较\"></a>时间复杂度的比较</h4><p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201103001513219.png\" alt=\"image-20201103001513219\"></p>\n<p>在上图中，X 轴代表 n 值，Y 轴代表时间复杂度。时间复杂度随着 n 值得变化而变化，可以看到，O(n)、O(logn)、O(√n )、O(nlogn )随着 n 的增加，复杂度提升不大，而 O(2ⁿ) 和 O(n!)  在 n 值较大时变化非常之大。实际上，在 n 等于 50 时，O(2ⁿ) 和 O(n!)  的复杂度就已经突破十位数了</p>\n<p>常用的时间复杂度按照耗费的时间从小到大依次是：</p>\n<p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n²) &lt; O(n³) &lt; O(2ⁿ) &lt; O(n!)</p>\n<hr>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"数组的概念\"><a href=\"#数组的概念\" class=\"headerlink\" title=\"数组的概念\"></a>数组的概念</h3><p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201104232327992.png\" alt=\"image-20201104232327992\"></p>\n<p>定义：数组（Array）是一种线性表数据结构，他用一组连续的内存空间，来存储一组具有相同类型的数据</p>\n<ol>\n<li><p>线性表</p>\n<p>所谓线性表，指的是每个元素最多只有前后两个方向，像一条线一样进行排列，除了数组，链表、队列、栈等都是线性表</p>\n</li>\n<li><p>连续的内存空间和相同类型的数据</p>\n</li>\n</ol>\n<p>正是因为这两点，才使得数组拥有了它的核心特性 – 随机访问</p>\n<p><strong>随机访问</strong></p>\n<p>所谓随机访问，指的是能够随意访问数组中的任意一个元素，比如我想访问第 n 个元素，那么该元素的起始位置就是：</p>\n<p>​        第 n 个元素的起始位置 = 第 1 个元素的起始位置  + 下标（从0开始）* 元素的长度</p>\n<p>而不是从第 1 个元素开始，依次访问第 2 个、第 3个 …，直到访问到第 n 个为止</p>\n<hr>\n<h3 id=\"数组的操作\"><a href=\"#数组的操作\" class=\"headerlink\" title=\"数组的操作\"></a>数组的操作</h3><ul>\n<li>数组支持随机访问，根据下标获取指定元素的时间复杂度为 O(1)</li>\n<li>如果想获取数组中指定某个值的元素的话，时间复杂度就变成了 O(n)；如果是有序数组的话，使用二分法，可以将时间复杂度将为 O(logn)</li>\n<li>数组为了保证内存数据的连续性，会导致插入、删除这两个操作比较低效</li>\n</ul>\n<h4 id=\"数组的插入\"><a href=\"#数组的插入\" class=\"headerlink\" title=\"数组的插入\"></a>数组的插入</h4><ol>\n<li>从头部和中间插入<ul>\n<li>如果是无序数组的话，最简单的插入方式是将要插入的第 k 个位置的元素移到最末尾，然后将新元素放入第 k 个位置，这种插入方法的时间复杂度为 O(1)</li>\n<li>如果是有序数组的话，向第 k 个位置插入元素，那么位置 k 后的所有元素都需要向后移动一位，这种情况下最坏的时间复杂度可达到 O(n)</li>\n</ul>\n</li>\n<li>从尾部插入<ul>\n<li>从尾部插入数据的话只需要直接在数据末尾添加一个元素即可，不需要移动其它元素，时间复杂度为 O(1)</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"数组的删除\"><a href=\"#数组的删除\" class=\"headerlink\" title=\"数组的删除\"></a>数组的删除</h4><ol>\n<li>删除头部和中间元素<ul>\n<li>为了保证数组中数据的连续性，数组中间的第 k 个元素删除之后，位置 k 之后的所有元素都需要向前移动一位，最坏时间复杂度为 O(n)</li>\n</ul>\n</li>\n<li>删除尾部元素<ul>\n<li>删除尾部元素不需要移动元素，只需要将末尾元素删除即可，时间复杂度为 O(1)</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>在 Java 中，我们可以自己创建并维护一个数组，也可以使用 Java 提供的数组容器类 ArrayList。相比于自建数组，ArrayList 提供了一些高级功能，比如自动扩容、泛型、更方便的处理元素等等</p>\n<p>在我们使用数组时，除非已知数组的所有元素并且几乎不再更改，否则都会使用 ArrayList 来进行数组的相关操作</p>\n<p>ArrayList 并不是线程安全的，如果我们想要保障 ArrayList 的线程安全，需要自己使用 Synchronized 关键字维护，或者调用 Collections.synchronizedList() 方法，获得一个线程安全的 ArryList，或者直接使用 JUC 包中的 CopyOnWriteArrayList</p>\n<p>ArrayList 继承了 RandomAccess 接口，进入这个接口会发现 RandomAccess 接口中并无任何的变量或方法。事实上，这是一个“标志”接口，标志这 ArrayList 这个类具备随机访问的特性</p>\n<hr>\n<h4 id=\"主要的成员变量\"><a href=\"#主要的成员变量\" class=\"headerlink\" title=\"主要的成员变量\"></a>主要的成员变量</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Default initial capacity.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<p>ArrayList 的初始数组长度为 10</p>\n<hr>\n<h4 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h4><p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201107180130865.png\" alt=\"image-20201107180130865\"></p>\n<ul>\n<li><p>无参构造方法</p>\n<p>返回一个空数组，在第一次往数组里添加元素的时候才赋予数组长度，初始长度为 0</p>\n</li>\n<li><p>int 类型参数构造方法</p>\n<p>返回一个指定长度的数组，入参为 0 的时候返回一个空数组，与无参构造方法类似，入参小于 0 则抛出异常</p>\n</li>\n<li><p>Collection 类型参数构造方法</p>\n<p>传入一个 Collection 集合，将该集合转为 ArrayList 数组</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"扩容机制\"><a href=\"#扩容机制\" class=\"headerlink\" title=\"扩容机制\"></a>扩容机制</h4><p>调用 ArrayList 的 add() 方法时，ArrayList 都会先判断一下当前数组是否已满，如果已经满了的话，就会调用 grow() 方法进行扩容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Object[] grow(<span class=\"keyword\">int</span> minCapacity) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (oldCapacity &gt; <span class=\"number\">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> newCapacity = ArraysSupport.newLength(oldCapacity,</span><br><span class=\"line\">                minCapacity - oldCapacity, <span class=\"comment\">/* minimum growth */</span></span><br><span class=\"line\">                oldCapacity &gt;&gt; <span class=\"number\">1</span>           <span class=\"comment\">/* preferred growth */</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> elementData = <span class=\"keyword\">new</span> Object[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>add() 方法在调用 grow() 方法时，传入的 minCapacity 的值为 size+1，但是 ArraysSupport.newLength() 会判断 minCapacity 的值和 oldCapacity &gt;&gt; 1（即原数组长度的一半）哪个更大，原数组长度加上两者之间的大者即为扩容后的新数组的长度。因此通常情况下扩容后的容量为原容量的 1.5 倍</p>\n<p><strong>自动扩容带来的问题</strong></p>\n<p>数字的自动扩容会带来一些空间资源的浪费，有时候只是想往数组中添加一个元素，长度加 1 即可，但是却让数组长度变成了原来的 1.5倍。在数组长度较小的时候，些许的浪费无伤大雅，但是当数据量较大时，带来的资源浪费就显得没必要了</p>\n<p><strong>解决方法</strong></p>\n<ul>\n<li>如果在创建数组时便知道数组的长度，就可以使用 ArrayList 的 int 类型参数构造方法来创建一个指定长度的数组了</li>\n<li>如果在创建数组的时候并不知道数组的长度，但是在插入数组的时候知道了，那么可以使用 ensureCapacity() 方法来将数组扩容到想要的长度</li>\n<li>还可以在数组插入完成之后，调用 trimToSize() 方法，将数组多余的长度清空掉</li>\n</ul>\n<hr>\n<h4 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h4><p>迭代器 Iterator 是一种设计模式，所有的 Collections 集合类都有实现这种设计模式，为得是提供一套统一的 API 来操作元素</p>\n<p>迭代器有两种属性，fail-fast 和 fail-safe</p>\n<ul>\n<li><p>fail-fast</p>\n<p>ArrayList 会维护一个 modCount 变量，每次对数组的增删改操作都会将 modCount 加 1。迭代器在遍历元素时直接获取原有集合的内容，在操作过程中如果发现 modCount 的值发生了变化，就会抛出异常</p>\n</li>\n<li><p>fail-safe</p>\n<p>迭代器在遍历元素时，会将原有集合复制出来一份，然后在复制出来的这个集合上进行操作。这样做避免了抛出异常，但是原有集合上的操作并不能被迭代器检测到</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><h3 id=\"链表的概念\"><a href=\"#链表的概念\" class=\"headerlink\" title=\"链表的概念\"></a>链表的概念</h3><p>数组是使用最广泛的一种通用数据结构，但是也不可避免的存在着一些缺陷。在无序数组中，搜索是低效的；而在有序数组中，插入效率又很低；而不管再哪一种数组中，删除效率都很低；并且一个数组在创建后，它的大小是不可改变的。而链表则可以解决上面的一些问题</p>\n<p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。每个元素节点除了存储自己的数据域之外，还存储着下一个节点的指针域</p>\n<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201110211256134.png\" alt=\"image-20201110211256134\"></p>\n<p>链表需通过头元素一个一个遍历才能找到目标元素，不支持随机访问。但是链表的增删操作只需要改变节点的指针域即可，不需要移动元素，增删速度较快。除非需要频繁通过下标访问元素，否则很多使用数组的地方都可以使用链表代替。而链表也是除数组外运用第二广泛的通用数据结构</p>\n<hr>\n<h3 id=\"链表的操作\"><a href=\"#链表的操作\" class=\"headerlink\" title=\"链表的操作\"></a>链表的操作</h3><h4 id=\"链表的基本结构\"><a href=\"#链表的基本结构\" class=\"headerlink\" title=\"链表的基本结构\"></a>链表的基本结构</h4><p>链表作为一个集合，首先需要知道头节点的位置，否则即使查询也不知道从何查起。而集合中存储着一系列的节点，这些节点既需要保存着自己的数据域，还需要保存着下一个节点的位置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkList</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 头节点</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Link fisrt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Link</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 指向下一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Link next;</span><br><span class=\"line\">        <span class=\"comment\">// 数据域</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Object data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这是一个链表最基本的组成，还可以通过添加其它属性和方法来丰富这个链表，比如添加 size 属性，获得这个链表的长度；还可添加 Link last 属性，来更快的找到尾节点等等</p>\n<hr>\n<h4 id=\"链表的查询\"><a href=\"#链表的查询\" class=\"headerlink\" title=\"链表的查询\"></a>链表的查询</h4><p>不管是查询指定值的节点，还是查询第 k 个元素，链表都需要从头节点一个个遍历，因此链表查询的时间复杂度固定为 O(n)</p>\n<hr>\n<h4 id=\"链表的插入和删除\"><a href=\"#链表的插入和删除\" class=\"headerlink\" title=\"链表的插入和删除\"></a>链表的插入和删除</h4><p>链表删除节点 k，只需要将节点 k-1 的指针域执行节点 k+1 即可，时间复杂度为 O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Link removeLink)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取被删除节点的上一个节点</span></span><br><span class=\"line\">    Link preLink = removeLink.pre;</span><br><span class=\"line\">    <span class=\"comment\">// 将上一个节点的指针域只想被删除节点的下一个节点</span></span><br><span class=\"line\">    preLink.next = removeLink.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>链表想在节点 k 和 k+1 之间插入一个元素，需要将节点 k 的指针域指向插入的节点，然后将插入节点的指针域指向节点 k+1，时间复杂度为 O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Link preLink, Link insertLink)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// preLink为节点k，通过节点k获取节点k+1</span></span><br><span class=\"line\">    Link afterLink = preLink.next;</span><br><span class=\"line\">    <span class=\"comment\">// 将节点k的指针域指向插入的节点</span></span><br><span class=\"line\">    preLink.next = insertLink;</span><br><span class=\"line\">    <span class=\"comment\">// 将插入节点的指针域指向节点k+1</span></span><br><span class=\"line\">    insertLink.next = afterLink;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"不同类型的链表\"><a href=\"#不同类型的链表\" class=\"headerlink\" title=\"不同类型的链表\"></a>不同类型的链表</h3><ul>\n<li><p>单向链表</p>\n<p>像上面这样只能从上一个节点获取下一个节点的链表，称为单项链表</p>\n</li>\n<li><p>双向链表</p>\n<p>如果链表中的节点不仅存储着下一个节点的指针域，还存储着上一个节点的指针域，这种链表称为双向链表</p>\n</li>\n<li><p>循环链表</p>\n<p>链表的尾节点又重新指向头节点，形成了一个圈，这种链表称为循环链表</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h3><h4 id=\"主要的成员变量-1\"><a href=\"#主要的成员变量-1\" class=\"headerlink\" title=\"主要的成员变量\"></a>主要的成员变量</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Pointer to first node.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; first;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Pointer to last node.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>LinkedList 只有三个成员变量，size 用于记录集合中的元素个数，first 和 last 分别指向头节点和尾节点</p>\n<h4 id=\"Node节点元素\"><a href=\"#Node节点元素\" class=\"headerlink\" title=\"Node节点元素\"></a>Node节点元素</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    E item;</span><br><span class=\"line\">    Node&lt;E&gt; next;</span><br><span class=\"line\">    Node&lt;E&gt; prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.item = element;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.prev = prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>可以看出，LinkedList 的节点元素既可以指向上一个元素，也可以指向下一个元素，所以 LinkedList 是一个双向链表</p>\n<hr>\n<h4 id=\"构造方法-1\"><a href=\"#构造方法-1\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h4><p><strong>无参构造方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Java 15 中，LinkedList 的无参构造方法会返回一个空集合，头节点和尾节点都是 null</p>\n<p><strong>有参构造方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>();</span><br><span class=\"line\">    addAll(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>LinkedList 的有参构造方法可以传入一个集合，将这个集合转为 LinkedList</p>\n<p>相比与 ArrayList，LinkedList 无须扩容，新增和删除的实现方式也比较简单</p>\n<hr>\n<h2 id=\"栈和队列\"><a href=\"#栈和队列\" class=\"headerlink\" title=\"栈和队列\"></a>栈和队列</h2><h3 id=\"抽象数据类型（ADT）\"><a href=\"#抽象数据类型（ADT）\" class=\"headerlink\" title=\"抽象数据类型（ADT）\"></a>抽象数据类型（ADT）</h3><p>抽象数据类型（Abstract Data Type，ADT）是带有一组操作的一些对象的集合。抽象数据类型是数学的抽象，在 ADT 的定义中没有地方提到关于这组操作是如何实现的具体解释。比如我们定义了线性表（List）这么一个 ADT，要求元素像一条线一样只有前后两个方向排列，那么只要满足了这个要求的，都可以看作线性表 ADT 的具体实现</p>\n<p>Java 也考虑了 ADT 的实现，不过适当了隐藏了实现的细节。最直观的方式就是“接口”，Java 中有 List 接口，只有实现了这个接口的类，都是 List 的具体实现类，例如 ArrayList、LinkedList，还有后续的 Deque、Stack等，都可以看作一个List。而在 Java 中，这就是对象多态的体现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;String&gt; list1 = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    List&lt;String&gt; list2 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        </span><br><span class=\"line\">    list1.add(<span class=\"string\">&quot;list1&quot;</span>);</span><br><span class=\"line\">    list2.add(<span class=\"string\">&quot;list2&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如上所示，我们可以只需要获得一个 List集合，然后支持 List 集合的方法即可，而不关系它究竟是 ArrayList 还是 LinkedList</p>\n<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201115151509347.png\" alt=\"image-20201115151509347\"></p>\n<p><strong>此图只是对ADT的简单展示，Java中数据结构中的层次远比这个复杂得多</strong></p>\n<p>不同的 ADT 之间也有着不同的关系，如上图所示，可以有层级关系，如 List 和 Queue 之间；也有并列关系，如 List 和 Map 之间；还有可能什么关系也没有。我们可以根据自己的需求去选用合适的 ADT 实现类，如果我们想要个 List 集合的话，就去找一个实现了 List 集合接口的类；如果想要个 Queue 的话，就去找一个实现了 Queue 接口的类；如果当前存在的都不满足需求的话，我们也可以自己实现一个，只要实现了对应的 ADT 接口即可</p>\n<hr>\n<h3 id=\"栈ADT\"><a href=\"#栈ADT\" class=\"headerlink\" title=\"栈ADT\"></a>栈ADT</h3><h4 id=\"栈模型\"><a href=\"#栈模型\" class=\"headerlink\" title=\"栈模型\"></a>栈模型</h4><p>栈（Stack）是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈的顶（top）。对栈的基本操作有 push（进栈）和 pop（出栈），前者相当于插入，后者则是删除最后插入的元素。最后插入的元素可以通过 top 例程在执行 pop 之前进行考察。对空栈进行 top 或 pop 操作一般被认为栈 ADT 中的一个错误。另一方面，当运行 push 时空间用尽是一个实现限制，但不是 ADT 错误</p>\n<p>栈有时又叫做 LIFO（后进先出）表。普通的清空栈的操作和判断是否空栈的操作都是栈的操作系统指令的一部分。但是，我们对栈所能够做的，基本上也就是 pop 和 push 操作</p>\n<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201115170259354.png\" alt=\"image-20201115170259354\"></p>\n<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201115170423180.png\" alt=\"image-20201115170423180\"></p>\n<hr>\n<h3 id=\"队列ADT\"><a href=\"#队列ADT\" class=\"headerlink\" title=\"队列ADT\"></a>队列ADT</h3><h4 id=\"队列模型\"><a href=\"#队列模型\" class=\"headerlink\" title=\"队列模型\"></a>队列模型</h4><p>像栈一样，队列也是表。但是，使用队列时插入在一段进行而删除则在另一端进行</p>\n<p>队列的基本操作是 enqueue（入队），它是在表的末端（叫做队尾 rear）插入一个元素；以及 dequeue（出队），它是返回并删除在表开头（叫做对头 front）的元素。队列，也叫做 FIFO（先进先出）表</p>\n<p><img src=\"https://simon-bookcase.oss-cn-beijing.aliyuncs.com/image-20201115195545751.png\" alt=\"image-20201115195545751\"></p>\n<hr>\n<h3 id=\"栈的具体实现\"><a href=\"#栈的具体实现\" class=\"headerlink\" title=\"栈的具体实现\"></a>栈的具体实现</h3><h4 id=\"栈的实现\"><a href=\"#栈的实现\" class=\"headerlink\" title=\"栈的实现\"></a>栈的实现</h4><p>由于栈是一个表，因此任何实现表的方法都能实现栈。显然，ArrayList 和 LinkedList 都支持栈操作，99% 的时间它们都是最合理的选择。偶尔设计一种特殊目的的实现可能会更快。因为栈操作的时间复杂度为 O(1)，所以，除非在非常独特的环境下，这是不可能产生任何明显的改进的。对于这些特殊的时机，一般给出了两种流行的实现方法，一种方法使用链式结构，而另一种方法使用数组，二者均简化了在 ArrayList 和 LinkedList 中的逻辑</p>\n<hr>\n<h4 id=\"栈的链式实现\"><a href=\"#栈的链式实现\" class=\"headerlink\" title=\"栈的链式实现\"></a>栈的链式实现</h4><p>栈的第一种实现方法是使用单链表，通过在表的顶端插入来实现 push，通过删除表顶端元素来实现 pop。top 操作只是考查表顶端元素并返回它的值，有时 pop 操作和 top操作合二为一</p>\n<hr>\n<h4 id=\"栈的数组实现\"><a href=\"#栈的数组实现\" class=\"headerlink\" title=\"栈的数组实现\"></a>栈的数组实现</h4><p>另一种方式避免了链并且可能是更流行的解决方案。由于模仿 ArrayList 的 add 操作，因此相应的实现方式非常简单。与每个栈相关联的操作是 theArray 和 topOfStack，对于空栈它是 -1，这就是空栈初始化的做法。为将某个元素 x 推入栈中，我们是 topOfStack 增 1 然后置 theArray[topOfStack] = x。为了弹出栈元素，我们置返回值为 theArray[topOfStack] 然后使 topOfStack 减 1</p>\n<p>注意，这些操作不仅以常数时间运行，而且是以非常快的常数时间运行。在某些机器上，若在带有自增和自减寻址功能的寄存器上操作，则（整数的）pop 和 push 都可以写成一条机器指令。最现代化的计算机将栈操作作为它指令系统的一部分，这个事实强化了这样一种观念，即栈很可能是计算机科学中在数组之后的最基本的数据结构</p>\n<hr>\n<h3 id=\"队列的具体实现\"><a href=\"#队列的具体实现\" class=\"headerlink\" title=\"队列的具体实现\"></a>队列的具体实现</h3><h4 id=\"队列的链表实现\"><a href=\"#队列的链表实现\" class=\"headerlink\" title=\"队列的链表实现\"></a>队列的链表实现</h4><p>同栈一样，任何表都可以实现队列，而使用链表来实现队列是最简单的。入队对应的就是 LinkedList 的 add 操作，而出队则是取出 first 元素，并将 first 指向后一个元素即可</p>\n<hr>\n<h4 id=\"队列的数组实现\"><a href=\"#队列的数组实现\" class=\"headerlink\" title=\"队列的数组实现\"></a>队列的数组实现</h4><p>对于每一个队列数据结构，我们保留一个数组 theArray 以及位置 front 和 back，他们代表队列的两端。还要记录实际存在与队列中的元素个数 currentSize，下图表示处于某个中间状态的队列</p>\n<p><img src=\"C:\\Users\\A\\Desktop\\image-20201119210337396.png\" alt=\"image-20201119210337396\"></p>\n<p>为使一个元素 x 入队（即执行 enqueue），我们让 currentSize 和 back 置 1，然后置 theArray[back] = x。若是元素  dequeue（出队），我们置返回值为 theArray[front]，且 currentSize 和 front 都增 1</p>\n<p>上述实现存在着一个潜在的问题，经过 10 次 enqueue 之后队列似乎是满了，因为 back 现在是数组的最后一个下标，而下一次再 enqueue 就会是一个不存在的位置。然而，队列中也许只存在几个元素，因为若干元素可能已经出队了。像栈一样，即使在有许多操作的情况下队列也常常不是很大</p>\n<p>简单的解决办法是，只要 front 或 back 到达数组的尾端，它就又绕回开头，这就是循环数组</p>\n<hr>\n<h4 id=\"双端队列\"><a href=\"#双端队列\" class=\"headerlink\" title=\"双端队列\"></a>双端队列</h4><p>栈和队列都是线性表的一种，且二者添加元素都是在线性表的尾部新增元素。不同的是，取出元素的时候，栈是从尾部取出的，而队列是从头部取出的。那么如果有一个线性表，既可以从头部取出元素，也可以从尾部取出元素，那么它就具备了栈和队列的双重特性，而像这样可以从两端弹出元素的线性表，则称之为双端队列</p>\n<p>双端队列让我们可以更自由的操作线性表中的元素，还可以减少代码的实现。如果想使用队列，则只从表的头部取出元素，如果想使用栈，则只从尾部取出元素。双端队列将栈和队列的抽象从数据结构层转移到了代码层，如果我们想固定使用某一种结构的话，就需要严格调用该结构对应的方法，否则就会使线性表中的元素混乱</p>\n<p>Java 将双端队列定义为一个接口 Deque，以下是 Deque 接口常用的一些方法：</p>\n<ul>\n<li>push：像尾部添加元素</li>\n<li>pop：移除尾部元素并返回它的值</li>\n<li>poll：将头部元素弹出，如果表为空就返回 null</li>\n<li>peek：查看头部元素，不会移除，如果是空就返回 null</li>\n<li>element：查看头部元素，不会移除，如果是空就抛出异常</li>\n</ul>\n<hr>\n<h3 id=\"JAVA-中的栈和队列\"><a href=\"#JAVA-中的栈和队列\" class=\"headerlink\" title=\"JAVA 中的栈和队列\"></a>JAVA 中的栈和队列</h3><h4 id=\"LinkedList-1\"><a href=\"#LinkedList-1\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h4><p>查看 LinkedList 的源码，会发现它实现了 Deque 接口，这意味着 LinkedList 也是也是一个双端队列。所以由链表实现的栈和由链表实现的队列都是 LinkedList</p>\n<hr>\n<h4 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h4><p>Stack 是由数组实现的栈，它继承了 Vector 类，Vector 是线程安全的 ArrayList，Stack 调用的也是它的方法，这意味着 Stack 也是线程安全的栈</p>\n<hr>\n<h4 id=\"ArrayQueue\"><a href=\"#ArrayQueue\" class=\"headerlink\" title=\"ArrayQueue\"></a>ArrayQueue</h4><p>ArrayQueue 是用数组实现的队列，底层的数据结构也是上文提到的循环数组</p>\n<p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201121224210165.png\" alt=\"image-20201121224210165\"></p>\n<p>上图分别是队空时和队满时的两种状态，当队空时，头坐标和尾坐标指向同一个元素，即 front = rear；当队满时，尾坐标在头坐标的前一个位置，而头坐标指向的位置没有放置元素，这意味着循环数组能够放置的元素数量会比数组的长度小一个</p>\n<p>我们也可用一个状态标识 empty 来区分当前队列是空还是满，队列初始化时 full为 false，而当 rear 在 front 前一个位置时，我们再往其中添加一个元素，此时 full 就变成了 true，此时如果有元素出队的话，full 再重新变为 false</p>\n</br>\n\n<p><strong>成员变量</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 队列可容纳元素的数量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\"><span class=\"comment\">// 放置元素的数组</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> T[] queue;</span><br><span class=\"line\"><span class=\"comment\">// 头元素下标</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> head;</span><br><span class=\"line\"><span class=\"comment\">// 尾元素下标</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> tail;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>构造方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 为了让队列可容纳元素的数量为构造方法传入的值，将传入的capacity的值加1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.capacity = capacity + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.queue = newArray(capacity + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 初始化时头尾坐标均指向0</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.head = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.tail = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>扩容</strong></p>\n<p>当 ArrayQueue 满了的时候，我们再往里面添加元素会抛出异常，如果当前队列的大小不满足需求的话，需要我们调用 resize() 方法进行扩容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> newcapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// resize方法不仅可以扩容，还可以缩容，如果新队列的长度小于实际元素个数的话就会抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newcapacity &lt; size)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(<span class=\"string\">&quot;Resizing would lose data&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 队列长度为目标长度+1</span></span><br><span class=\"line\">    newcapacity++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newcapacity == <span class=\"keyword\">this</span>.capacity)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    T[] newqueue = newArray(newcapacity);</span><br><span class=\"line\">    <span class=\"comment\">// get(i)是循环将头节点和尾节点的元素取出</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">        newqueue[i] = get(i);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.capacity = newcapacity;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.queue = newqueue;</span><br><span class=\"line\">    <span class=\"comment\">// 新队列的头节点为0</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.head = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.tail = size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</br>\n\n<p><strong>入队</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(T o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先给队尾添加值，再判断是否队满</span></span><br><span class=\"line\">    queue[tail] = o;</span><br><span class=\"line\">    <span class=\"comment\">// 判断队满的方式：(tail + 1) % capacity == head</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newtail = (tail + <span class=\"number\">1</span>) % capacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newtail == head)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(<span class=\"string\">&quot;Queue full&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 队列没满的情况下，队尾下标才会后移一位</span></span><br><span class=\"line\">    tail = newtail;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; <span class=\"comment\">// we did add something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先插入元素再判断队列有没有满，这样队尾下标元素实际上是有值的，但是我们无法取得而已。并且每次添加元素都会把之前的值覆盖掉</p>\n</br>\n\n<p><strong>出队</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 队列只能从头元素开始取</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Can only remove head of queue&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 当 head == tail 的时候队列为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == tail)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(<span class=\"string\">&quot;Queue empty&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 获取头元素</span></span><br><span class=\"line\">    T removed = queue[head];</span><br><span class=\"line\">    <span class=\"comment\">// 将头元素置空</span></span><br><span class=\"line\">    queue[head] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 头元素下标加1</span></span><br><span class=\"line\">    head = (head + <span class=\"number\">1</span>) % capacity;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> removed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><h3 id=\"什么是树\"><a href=\"#什么是树\" class=\"headerlink\" title=\"什么是树\"></a>什么是树</h3><h4 id=\"树的简介\"><a href=\"#树的简介\" class=\"headerlink\" title=\"树的简介\"></a>树的简介</h4><p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201124204551109.png\" alt=\"image-20201124204551109\"></p>\n<p>树是一种抽象数据类型或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>\n<ol>\n<li>每个节点有零个或多个子节点；</li>\n<li>没有父节点的节点称为根节点；</li>\n<li>每一个非根节点有且只有一个父节点；</li>\n<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>\n</ol>\n<hr>\n<h4 id=\"树的术语\"><a href=\"#树的术语\" class=\"headerlink\" title=\"树的术语\"></a>树的术语</h4><p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201124221707828.png\" alt=\"image-20201124221707828\"></p>\n<ul>\n<li>结点：使用树存储结构存储的每一个数据元素都被称为结点</li>\n<li>路径：顺着连接结点的边从一个结点走到另一个节点，所经过的结点顺序排列就称为路径</li>\n<li>根结点：树顶端的结点称为根结点，如果一个结点没有父结点，那么它就是整棵树的根节点，上图的根结点就是 A</li>\n<li>父结点：每个结点（除根结点）都恰好有一条边向上连接到另一个结点，上面这个结点就称为下面这个结点的父结点</li>\n<li>子结点：与父结点相反，比如 B 是 E 的父结点，那么 E 就是 B 的子结点</li>\n<li>叶结点：如果结点没有任何子结点，那么此结点称为叶结点</li>\n<li>空树：如果集合本身为空，那么构成的树就为空树，空树没有结点</li>\n<li>子树：全部由子结点构成的树称为子树，如上图，整个是一棵树，B、E、F、K、L 也可看作一棵树，E、K、L也可看作一棵树，它们都可看作这棵树的子树</li>\n<li>结点的度：对于一个结点，拥有的子树数（结点有多少分支）称为结点的度</li>\n<li>结点的层次：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推</li>\n<li>树的深度：一棵树的深度（高度）是树中结点所在的最大的层次</li>\n<li>有序树和无序树：如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为有序树；反之称为无序树</li>\n<li>森林：由 m（m &gt;= 0）个互不相交的树组成的集合被称为森林</li>\n</ul>\n<hr>\n<h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><h4 id=\"二叉树的定义\"><a href=\"#二叉树的定义\" class=\"headerlink\" title=\"二叉树的定义\"></a>二叉树的定义</h4><p>简单地理解，满足以下两个条件的树就是二叉树：</p>\n<ol>\n<li>本身是有序树</li>\n<li>树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2</li>\n</ol>\n<p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201211175500008.png\" alt=\"image-20201211175500008\"></p>\n<hr>\n<h4 id=\"二叉树的性质\"><a href=\"#二叉树的性质\" class=\"headerlink\" title=\"二叉树的性质\"></a>二叉树的性质</h4><ol>\n<li>二叉树中，第 i 层最多有 2^(i-1) 个结点</li>\n<li>如果二叉树的深度为 K，那么此二叉树最多有 2^(K-1) 个结点</li>\n<li>二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1</li>\n</ol>\n<hr>\n<h4 id=\"满二叉树\"><a href=\"#满二叉树\" class=\"headerlink\" title=\"满二叉树\"></a>满二叉树</h4><p>如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树</p>\n<p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201211180057924.png\" alt=\"image-20201211180057924\"></p>\n<p>满二叉树除了满足普通二叉树的性质，还具有以下性质：</p>\n<ol>\n<li>满二叉树中第 i 层的节点数为 2^(n-1) 个</li>\n<li>深度为 k 的满二叉树必有 2^(k-1) 个节点 ，叶子数为 2^(k-1)</li>\n<li>满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层</li>\n<li>具有 n 个节点的满二叉树的深度为 log2(n+1)</li>\n</ol>\n<hr>\n<h4 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h4><p>如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树</p>\n<p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201212192543825.png\" alt=\"image-20201212192543825\"></p>\n<p>对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号，对于任意一个结点 i ，完全二叉树还有以下几个结论成立：</p>\n<ol>\n<li>当 i&gt;1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）</li>\n<li>如果 2<em>i&gt;n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2</em>i </li>\n<li>如果 2<em>i+1&gt;n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2</em>i+1 </li>\n</ol>\n<hr>\n<h3 id=\"二叉树的结构\"><a href=\"#二叉树的结构\" class=\"headerlink\" title=\"二叉树的结构\"></a>二叉树的结构</h3><h4 id=\"二叉树的顺序储存结构\"><a href=\"#二叉树的顺序储存结构\" class=\"headerlink\" title=\"二叉树的顺序储存结构\"></a>二叉树的顺序储存结构</h4><p>二叉树的顺序存储，指的是使用数组存储二叉树。需要注意的是，顺序存储只适用于完全二叉树。换句话说，只有完全二叉树才可以使用顺序表存储。因此，如果我们想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树</p>\n<p>完全二叉树的顺序存储，仅需从根节点开始，按照层次依次将树中节点存储到数组即可</p>\n<p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210103150636489.png\" alt=\"image-20210103150636489\"></p>\n<hr>\n<h4 id=\"二叉树的链式存储结构\"><a href=\"#二叉树的链式存储结构\" class=\"headerlink\" title=\"二叉树的链式存储结构\"></a>二叉树的链式存储结构</h4><p>其实二叉树并不适合用数组存储，因为并不是每个二叉树都是完全二叉树，普通二叉树使用顺序表存储或多或多会存在空间浪费的现象。而一棵普通的二叉树，若将其采用链式存储，则只需从树的根节点开始，将各个节点及其左右孩子使用链表存储即可</p>\n<p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210103151203203.png\" alt=\"image-20210103151203203\"></p>\n<p>采用链式存储二叉树时，其节点结构由三部分组成</p>\n<ul>\n<li>指向左孩子节点的指针（leftChild）</li>\n<li>节点存储的数据（data）</li>\n<li>指向右孩子节点的指针（rightChild）</li>\n</ul>\n<p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210103151359861.png\" alt=\"image-20210103151359861\"></p>\n<p>我们还可以在该节点中添加一个指针，指向该结点的父节点。这样的链表结构，称为三叉链表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node leftChild;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object Data;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node rightChild;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node parent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h3><p>所谓遍历(Traversal)是指沿着某条搜索路线，依次对树中每个结点均做一次且仅做一次访问。访问结点所做的操作依赖于具体的应用问题。 遍历是二叉树上最重要的运算之一，是二叉树上进行其它运算之基础</p>\n<p>二叉树的遍历主要有以下四种方式：</p>\n<ul>\n<li>前序遍历</li>\n<li>中序遍历</li>\n<li>后序遍历</li>\n<li>层序遍历</li>\n</ul>\n<h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210103183839223.png\" alt=\"image-20210103183839223\"></p>\n<p>二叉树前序遍历的实现思想是：</p>\n<ol>\n<li>访问根节点</li>\n<li>访问当前节点的左子树</li>\n<li>若当前节点无左子树或左子树已访问过，继续访问当前节点的右子树</li>\n</ol>\n<p>因此，以上二叉树采用前序遍历得到的序列为：1245367</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 前序遍历代码实现</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">preOrderTraveral</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(node.data.toString());</span><br><span class=\"line\">    preOrderTraveral(node.leftChild);</span><br><span class=\"line\">    preOrderTraveral(node.rightChild);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><p>二叉树中序遍历的实现思想是：</p>\n<ol>\n<li>访问当前节点的左子树</li>\n<li>访问根节点</li>\n<li>访问当前节点的右子树</li>\n</ol>\n<p>因此，以上二叉树采用中序遍历得到的序列为：4251637</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 中序遍历代码实现</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inOrderTraveral</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    inOrderTraveral(node.leftChild);</span><br><span class=\"line\">    System.out.println(node.data.toString());</span><br><span class=\"line\">    inOrderTraveral(node.rightChild);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><p>二叉树前序遍历的实现思想是：</p>\n<ol>\n<li>访问当前节点的左子树</li>\n<li>访问当前节点的右子树</li>\n<li>访问当前节点</li>\n</ol>\n<p>因此，以上二叉树采用中序遍历得到的序列为：1376254</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 后序遍历代码实现</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postOrderTraveral</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    postOrderTraveral(node.leftChild);</span><br><span class=\"line\">    postOrderTraveral(node.rightChild);</span><br><span class=\"line\">    System.out.println(node.data.toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h4 id=\"层序遍历\"><a href=\"#层序遍历\" class=\"headerlink\" title=\"层序遍历\"></a>层序遍历</h4><p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210110194451416.png\" alt=\"image-20210110194451416\"></p>\n<p>二叉树层序遍历的实现思想是：</p>\n<ol>\n<li>通过使用队列的数据结构，从树的根节点开始，先入队，再出队</li>\n<li>出队的同时，将根节点的左右子结点分别入队</li>\n<li>此后每次出队操作，都将该节点的左右孩子节点入队，知道树中的所有结点都出队</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 层序遍历代码实现</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">levelOrder</span><span class=\"params\">(Node root)</span> </span>&#123;</span><br><span class=\"line\">    LinkedList&lt;Node&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    queue.add(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">        node = queue.pop();</span><br><span class=\"line\">        System.out.println(node.data.toString());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.leftChild != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            queue.add(node.leftChild);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.rightChild != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            queue.add(node.rightChild);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"线索二叉树\"><a href=\"#线索二叉树\" class=\"headerlink\" title=\"线索二叉树\"></a>线索二叉树</h3><h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>普通的二叉树，不管形态如何，空链域的个数总是多过非空链域的个数。所谓空链域，指的是孩子节点为 null 的指针域。实际上，n 个节点的二叉树共有 2n 个链域，其中非空链域有 n - 1 个，而空链域却有 n + 1 个</p>\n<p>因此，我们可以利用这些空链域，指向该节点的前驱节点或者后继节点，这样就可以充分利用到这些空链域，提升遍历速度。所谓前驱节点和后继节点，指的是该二叉树遍历完成后顺序输出的顺序中，该节点的前一个节点和后一个节点。众所周知，使用不同的遍历方法遍历出来的节点顺序是不一样的，因此同一个二叉树使用不同的线索顺序，同一个节点的前驱和后继节点也可能是不一样的。这里我们主要介绍一下中序遍历线索二叉树</p>\n<p>使用空链域来指向前驱后继节点，我们就需要区分该节点的左右孩子节点指向的是自己的孩子还是前驱后继节点，因此我们需要增加两个标识位，leftTag 和 rightTag，当 tag 的值为 0 时说明指向的是自己的孩子节点，值为 1 时说明指向的是前驱或者后继节点</p>\n<p><img src=\"C:\\Users\\A\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210117135411299.png\" alt=\"image-20210117135411299\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object data;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node leftChild;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node rightChild;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer leftTag;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer rightTag;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h4 id=\"线索化\"><a href=\"#线索化\" class=\"headerlink\" title=\"线索化\"></a>线索化</h4><p>将一棵普通的二叉树转为线索二叉树，即将二叉树所有的空链域指向自己的前驱或者后继节点，这个过程称为线索化</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadTree</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node root;</span><br><span class=\"line\">    <span class=\"comment\">// 前驱节点</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node pre = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"> \t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> \t* 将以root为根节点的二叉树线索化 中序法</span></span><br><span class=\"line\"><span class=\"comment\"> \t**/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inThread</span><span class=\"params\">(Node root)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 找到该二叉树的最左孩子节点，该节点即为该二叉树的最前驱节点</span></span><br><span class=\"line\">        \tinThread(root.leftChild);</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span> (root.leftChild == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            \troot.setLeftTag(<span class=\"number\">1</span>);</span><br><span class=\"line\">                root.setLeftChild(pre);</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"keyword\">null</span> == pre.rightChild) &#123;</span><br><span class=\"line\">                pre.setRightTag(<span class=\"number\">1</span>);</span><br><span class=\"line\">                pre.setRightChild(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pre = root;</span><br><span class=\"line\">            inThread(root.rightChild);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckepsik5t0001r0v73ptdd86d","category_id":"ckf19kvi600073gv7hf3hdesn","_id":"ckf19kvi7000a3gv7dk320aq3"},{"post_id":"ckepsik5p0000r0v7et8vhcq7","category_id":"ckf2nyd4n00000ov7h91g1nu5","_id":"ckf2nyd4p00010ov797uja6nl"},{"post_id":"ckfa0xrer0001c4v7hhwn0tfb","category_id":"ckfa0xret0003c4v74sjfhxhu","_id":"ckfa0xrex0006c4v70y4sgy38"},{"post_id":"ckfa0xres0002c4v72ghi4ake","category_id":"ckf2nyd4n00000ov7h91g1nu5","_id":"ckfatby3l00012wv72pp5cf59"},{"post_id":"ckh6hkpms0000swv7e0r7gcio","category_id":"ckhirtmbc0000v0v7hxq3fxj1","_id":"ckhirtmbe0003v0v7bp330vta"}],"PostTag":[{"post_id":"ckepsik5p0000r0v7et8vhcq7","tag_id":"ckf19kvi300023gv750ahc38k","_id":"ckf19kvi400033gv7bgsi895i"},{"post_id":"ckepsik5t0001r0v73ptdd86d","tag_id":"ckf19kvi700083gv7hyvlbptu","_id":"ckf19kvi700093gv7fof69rvt"},{"post_id":"ckfa0xrer0001c4v7hhwn0tfb","tag_id":"ckfa0xreu0004c4v79oqf4fy7","_id":"ckfa0xrex0005c4v7da6whxhw"},{"post_id":"ckfa0xres0002c4v72ghi4ake","tag_id":"ckfatby3k00002wv7cc431ubq","_id":"ckfatby3l00022wv7ftkz7pt8"},{"post_id":"ckh6hkpms0000swv7e0r7gcio","tag_id":"ckhirtmbd0001v0v7cxp76irf","_id":"ckhirtmbe0002v0v79v4669kp"}],"Tag":[{"name":"计算机基础","_id":"ckf19kvi300023gv750ahc38k"},{"name":"Butterfly","_id":"ckf19kvi700083gv7hyvlbptu"},{"name":"技术相关","_id":"ckfa0xreu0004c4v79oqf4fy7"},{"name":"计算机组成原理","_id":"ckfatby3k00002wv7cc431ubq"},{"name":"数据结构与算法","_id":"ckhirtmbd0001v0v7cxp76irf"}]}}