---
title: 如何设计一个秒杀系统
date: 2022-03-18 22:28:53
tags: 后端架构
categories: 
  - 后端架构
top_img: https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/image-20220522000516990.png
cover: https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/image-20220522000516990.png
---

## 如何设计一个秒杀系统

### 秒杀系统的架构原则



1. 数据尽量少

   这个数据既包括请求和响应的数据，也包括数据库中的数据。减少请求和响应数据可减少网络传输过程中的是时间，也缓解了 CPU 序列化和反序列化的压力，减少数据库中的数据则可以避免查询时间过长

2. 请求数尽量少

   减少请求数可缩减建立和断开 Socket 连接的时间消耗，比如请求多个静态资源可以只有一个请求，然后用逗号分隔开，但这就需要服务器解析的时候做一些自定义的处理

3. 路径尽量短

   路径指的是从客户端发出请求到服务端响应这个链路中的所有节点

4. 依赖尽量少

   依赖指的是完成一次用户请求所必须依赖的服务或系统

5. 不要有单点



------

### 热点的处理

#### 什么是热点



热点分为热点操作和热点数据。热点请求即用户操作较多的请求，比如支付系统中的下单支付操作，APP 的首页查询操作等，而热点数据就是用户的热点请求对应的数据



热点数据又分为静态热点数据和动态热点数据。静态热点数据就是可以提前预知的热点数据，比如定时秒杀的商品，动态热点数据则是无法被提前预知的热点数据，比如微博热搜，爆款商品等等



静态热点数据的定位比较简单，因为它是可提前预知的。与之相反，动态热点数据的定位则难了不少，需要根据具体业务来使用不同的方法，比如可以单独部署一个热点监听业务，异步监听服务链路中的热点 key 值，如果发现某个数据访问量突然增加，则通知或透传给下游服务系统



------

#### 如何处理热点数据



处理热点数据的思路有三种，分别是优化、限制和隔离



优化数据最常用的方法就是缓存，可以将静态资源缓存部署在 CDN，然后将常用数据库资源在 Redis 中进行缓存。隔离是一种保护机制，比如说将秒杀抢单的请求按 key 进入不同的消息队列，然后慢慢消费，避免热点商品占用过多的服务器资源。隔离就是将热点操作和热点数据隔离出来，包括系统隔离和数据隔离



------

### 削峰



削峰是应对高并发请求常用的处理手段，就是将峰值时的请求保存下来慢慢消费，避免服务器资源耗光或者被请求冲垮。主要的实现方式有三种，分别是排队、答题和分层过滤



------

#### 排队



排队是削峰最常用的处理手段，主要方式就是使用消息队列。请求进来之后先进入消息队列，再由消费者慢慢消费。使用消息队列的话就需要考虑消息积压的数量是否会超过消息队列的存储上限



除了消息队列，还有其它方式可以实现排队：

* 利用线程池加锁等待
* 利用先进先出、先进后出等常用内存排队算法
* 把请求序列化到文件中，再按照顺序读取文件（例如基于 MySQL binlog 的同步机制）



------

#### 答题



在秒杀开始之前可以添加一个答题或者验证的操作，这样既可以避免机器人抢单，也可以延缓请求，达到流量削峰的作用





------



#### 分层过滤



![image-20220317120548909](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/image-20220317120548909.png)



分层过滤的思想就在于：在不同的层次尽可能地过滤掉无效请求，让到达最底层的都是有效请求



分层校验的基本原则是：

1. 将动态请求的读数据缓存（Cache）在 Web 端，过滤掉无效的数据读
2. 对读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题
3. 对写数据进行基于时间的合理分片，过滤掉过期的失效请求
4. 对写请求做限流保护，将超出系统承载能力的请求过滤掉
5. 对写数据进行强一致性校验，只保留最后有效的数据



分层校验的目的是：在读系统中，尽量减少由于一致性校验带来的系统瓶颈，但是尽量将不影响性能的检查条件提前，如用户是否具有秒杀资格、商品状态是否正常、用户答题是否正确、秒杀是否已经结束、是否非法请求、营销等价物是否充足等；在写数据系统中，主要对写的数据（如“库存”）做一致性检查，最后在数据库层保证数据的最终准确性（如“库存”不能减为负数）



------

### 减库存

#### 常用的减库存方案



* **下单减库存**

  即当买家下单后，在商品的总库存中减去买家购买数量。下单减库存是最简单的减库存方式，也是控制最精确的一种，下单时直接通过数据库的事务机制控制商品库存，这样一定不会出现超卖的情况

  但并不是所有的订单下单之后都会付款，竞争对手可以在秒杀活动开始时将商品均下单，但不进行付款，消耗完库存

* **付款减库存**

  即买家下单后，并不立即减库存，而是等到有用户付款后才真正减库存，否则库存一直保留给其他买家。但因为付款时才减库存，如果并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了

  付款减库存可能出现的问题就是有很多用户下了单，但是无法进行付款，会造成用户体验较差

* **预扣库存**

  买家下单后，库存为其保留一定的时间（如 10  分钟），超过这个时间，库存将会自动释放，释放后其他买家就可以继续购买。在买家付款前，系统会校验该订单的库存是否还有保留：如果没有保留，则再次尝试预扣；如果库存不足（也就是预扣失败）则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存

  这种方案相比于下单减库存多了一步订单超时释放库存的操作，但是并不能完全解决恶意下单的问题，用户仍可以在订单超时之后再次下单。针对这种情况，可以使用风控检测用户毁单状况，超过一定次数便不允许下单，或者一件商品同一用户最多只能下 n 单等方式来解决



目前来看，业务系统中最常见的就是预扣库存方案，像你在买机票、买电影票时，下单后一般都有个“有效付款时间”，超过这个时间订单自动释放，这都是典型的预扣库存方案。由于参加秒杀的商品，一般都是“抢到就是赚到”，所以成功下单后却不付款的情况比较少，再加上卖家对秒杀商品的库存有严格限制，所以秒杀商品采用“下单减库存”更加合理。另外，理论上由于“下单减库存”比“预扣库存”以及涉及第三方支付的“付款减库存”在逻辑上更为简单，所以性能上更占优势



“下单减库存”在数据一致性上，主要就是保证大并发请求时库存数据不能为负数，也就是要保证数据库中的库存字段值不能为负数，一般我们有多种解决方案：一种是在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚；另一种办法是直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行 SQL 语句来报错；再有一种就是使用 CASE WHEN 判断语句



------

#### 减库存方案的优化



如果你的秒杀商品的减库存逻辑非常单一，可以直接将库存值放在 Redis 数据库中进行操作。但是如果有比较复杂的减库存逻辑，或者需要使用事务，还是必须在数据库中完成减库存



如果使用传统数据库完成减库存，就需要对数据库的读写数据进行优化，比如在数据库层进行排队，或者对 innoDB 的死锁检测机制进行优化，这些就属于比较高端的操作了

