---
title: 多线程
date: 2021-11-08 21:01:53
tags:
---





### 进程

#### 进程的概念



进程就是正在运行的程序,它会占用对应的内存区域，由CPU进行执行与计算



------

#### 进程的特点



* 独立性

  进程是系统中独立存在的实体，它可以拥有自己独立的资源，每个进程都拥有自己私有的地址空间，在没有经过进程本身允许的情况下，一个用户进程不可以直接访问其他进程的地址空间

* 动态性

  进程与程序的区别在于，程序只是一个静态的指令集合，而进程是一个正在系统中活动的指令集合，程序加入了时间的概念以后，称为进程，具有自己的生命周期和各种不同的状态，这些概念都是程序所不具备的

* 并发性

  多个进程可以在单个处理器CPU上并发执行，多个进程之间不会互相影响



------

### 线程

#### 线程的概念



线程是操作系统OS能够进行运算调度的最小单位,它被包含在进程之中,是进程中的实际运作单位
 一个进程可以开启多个线程，其中有一个主线程来调用本进程中的其他线程
 我们看到的进程的切换，切换的也是不同进程的主线程
 多线程可以让同一个进程同时并发处理多个任务，相当于扩展了进程的功能



------

#### 进程与线程的关系



一个操作系统中可以有多个进程，一个进程中可以包含一个线程（单线程程序），也可以包含多个线程（多线程程序）

![进程与线程的关系](https://img-blog.csdnimg.cn/20210317231249749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4NDIzNA==,size_16,color_FFFFFF,t_70)



每个线程在共享同一个进程中的内存的同时,又有自己独立的内存空间.
 所以想使用线程技术,得先有进程,进程的创建是OS操作系统来创建的,一般都是C或者C++完成



![进程与线程的关系](https://img-blog.csdnimg.cn/20210317231707165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4NDIzNA==,size_16,color_FFFFFF,t_70)



### 多线程的特性

#### 随机性



我们宏观上觉得多个进程是同时运行的,但实际的微观层面上，一个CPU【单核】只能执行一个进程中的一个线程。
那为什么看起来像是多个进程同时执行呢？
是因为CPU以纳秒级别甚至是更快的速度高效切换着，超过了人的反应速度，这使得各个进程从看起来是同时进行的,也就是说,宏观层面上,所有的进程看似并行【同时运行】,但是微观层面上是串行的【同一时刻,一个CPU只能处理一件事】

![线程切换](https://img-blog.csdnimg.cn/20210317231806318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4NDIzNA==,size_16,color_FFFFFF,t_70)



**串行与并行**

串行是指同一时刻一个CPU只能处理一件事，类似于单车道
并行是指同一时刻多个CPU可以处理多件事，类似于多车道

![在这里插入图片描述](https://img-blog.csdnimg.cn/f7228c53c50b46d0ae132bc30cadad7c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56iL5bqP5aqbIOazoeazoQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

![在这里插入图片描述](https://img-blog.csdnimg.cn/0c08ef4ce38c4fbdb79f7c35918a8fbf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56iL5bqP5aqbIOazoeazoQ==,size_19,color_FFFFFF,t_70,g_se,x_16)



------

#### CPU 分时调度



时间片，即CPU分配给各个线程的一个时间段，称作它的时间片，即该线程被允许运行的时间，如果在时间片用完时线程还在执行，那CPU将被剥夺并分配给另一个线程，将当前线程挂起，如果线程在时间片用完之前阻塞或结束，则CPU当即进行切换，从而避免CPU资源浪费，当再次切换到之前挂起的线程，恢复现场，继续执行

![CPU分片](https://img-blog.csdnimg.cn/20210322132231224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4NDIzNA==,size_16,color_FFFFFF,t_70)

------

### 多线程的实现

#### 继承 Thread 类



继承 Thread 类并重写 run 方法

```java
/**
 * 1. 不能多次调用 Thread 中的 start() 方法，否则会抛出 IllegalThreadStateException 异常
 * 2. 启动线程的方法不是 run()方法而是 start 方法，如果调用的是 run() 方法就是同步的，并不能异步执行
 * 3. 执行start()方法的顺序不代表线程启动的顺序，即并不是说，越早调用某个线程的start()方法，它就能越早的执行其中的run()方法
 */
public class ThreadTest {

    public static class MyThread1 extends Thread {
        @Override
        public void run() {
            for (int i = 0; i < 100; i++) {
                System.out.println("Thread 01 is running");
            }
        }
    }

    public static class MyThread2 extends Thread {
        @Override
        public void run() {
            for (int i = 0; i < 100; i++) {
                System.out.println("Thread 02 is running");
            }
        }
    }

    public static void main(String[] args) {
        Thread thread01 = new MyThread1();
        Thread thread02 = new MyThread2();
        thread01.start();
        thread02.start();
    }

}
```



------

#### 实现 Runnable 接口



实现Runnable接口，重写run()方法

```java
/**
 * 因为Thread类也实现了Runnable接口，
 * 所以Thread中的构造函数就可以传入一个Runnable接口的对象，也可以传入一个Thread类的对象
 */
public class RunnableTest {

    public static class MyThread implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 100; i++) {
                System.out.println(Thread.currentThread().getName() + " is running");
            }
        }
    }

    public static void main(String[] args) {
        Thread thread01 = new Thread(new MyThread(), "Thread01");
        Thread thread02 = new Thread(new MyThread(), "Thread02");
        thread01.start();
        thread02.start();
    }

}
```



------

#### 实现 Callable 接口


实现Callable接口，重写call()方法

```java
/**
 * 实现 Callable 接口。 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常
 */
public class CallableTest {

    public static class MyThread1 implements Callable<Date> {
        @Override
        public Date call() throws Exception {
            for (int i = 0; i < 100; i++) {
                System.out.println("Thread 01 is running");
            }
            Thread.sleep(1000);
            return new Date();
        }
    }

    public static class MyThread2 implements Callable<Date> {
        @Override
        public Date call() throws Exception {
            for (int i = 0; i < 100; i++) {
                System.out.println("Thread 02 is running");
            }
            return new Date();
        }
    }

    public static void main(String[] args) throws Exception {
        // 执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果
        FutureTask<Date> future01 = new FutureTask<>(new MyThread1());
        Thread thread01 = new Thread(future01);
        FutureTask<Date> future02 = new FutureTask<>(new MyThread2());
        Thread thread02 = new Thread(future02);
        thread01.start();
        thread02.start();
        // 接收线程运算后的结果
        System.out.println(future01.get());
        System.out.println(future02.get());
    }

}
```



**推荐使用实现 Runable 接口的方式来实现多线程**

1. Thread 类中定义了多种方法可以被派生类使用或重写，但是只有 run() 方法必须被重写的，在 run() 方法中实现这个线程的主要功能,这就是 Runnable 接口所需实现的方法

2. 通过继承 Thread 的实现方法与实现 Runnable 接口的效果相同，并且 Java 只能是单继承、多实现，如果一个类中已经继承其他所需的类，那实现一个接口是必须的
   



------

### 线程的状态

#### 线程的生命周期



![线程状态与代码对照](https://img-blog.csdnimg.cn/20210322132536358.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4NDIzNA==,size_16,color_FFFFFF,t_70)



线程的生命周期，主要有 5 种状态：

1. 新建状态

   当线程对象创建后就进入了新建状态

2. 就绪状态（可运行状态）

   当调用线程对象的 start() 方法,线程即为进入就绪状态
   
   处于就绪状态的线程，只是说明线程已经做好准备,随时等待 CPU 调度执行,并不是执行了 t.start() 此线程立即就会执行
   
3. 运行状态

   当 CPU 调度了处于就绪状态的线程时,此线程才是真正的执行,即进入到运行状态

   就绪状态是进入运行状态的唯一入口,也就是线程想要进入运行状态状态执行,先得处于就绪状态

4. 阻塞状态

   处于运状态中的线程由于某种原因,暂时放弃对 CPU 的使用权,停止执行,此时进入阻塞状态,直到其进入就绪状态才有机会被 CPU 选中再次执行

   根据阻塞状态产生的原因不同,阻塞状态又可以细分成三种：

   * 等待阻塞：运行状态中的线程执行 wait() 方法,本线程进入到等待阻塞状态
   * 同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其他线程占用),它会进入同步阻塞状态
   * 其他阻塞：调用线程的 sleep() 或者 join() 或发出了 I/O 请求时,线程会进入到阻塞状态，当 sleep() 状态超时，join() 等待线程终止或者超时或者 I/O 处理完毕时线程重新转入就绪状态

5. 死亡状态

   线程执行完了或者因异常退出了run()方法,该线程结束生命周期



------

### 线程的常用操作及方法

#### 线程的停止



在 JDK 中，Thread 类的 stop()、destory() 方法都是加了 @Deprecated 注解的，也就是说，不推荐直接使用 stop() 或 destory() 方法来停止线程，而是应该让线程自己停下来。具体操作便是设置一个标志位或者偏移量，当标志位或者偏移量不满足要求的时候则终止线程运行



```java
public class TreadStopTest implements Runnable {

    // 标志位
    private boolean flag = true;

    // 自定义接口的 stop 方法，修改标志位状态
    public void stop() {
        this.flag = false;
    }

    @Override
    public void run() {
        int i = 0;
        // 当标志位为 true 的时候，不断循环输出
        while (flag) {
            System.out.println("i = " + i++);
        }
    }

    public static void main(String[] args) throws Exception {
        // 创建并启动线程
        TreadStopTest runnable = new TreadStopTest();
        Thread thread = new Thread(runnable);
        thread.start();

        // main 方法的线程阻塞十秒，与新建的 thread 无关，TreadStopTest 仍在循环输出
        Thread.sleep(1000);
        // 十秒之后，修改标志位状态，TreadStopTest 停止输出
        runnable.stop();
    }

}
```



------

#### 线程的休眠



sleep(时间) 指定当前线程阻塞的毫秒数

sleep() 方法会抛出一个 InterruptedException 异常

休眠时间结束后线程会回到就绪状态

sleep 方法可以模拟网络延时、倒计时等

每一个对象都有一个锁，sleep() 方法不会释放锁



```java
/**
 * 模拟 10 秒倒计时
 */
public class ThreadSleepTest {


    public static void countdown() throws InterruptedException {
        int i = 10;
        while (i > 0) {
            System.out.println(i);
            i--;
            Thread.sleep(1000);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        countdown();
    }

}
```



------

#### 线程的礼让



yield() 方法，当前线程放弃获得的时间片，重新进入就绪状态，争夺时间片

放弃的时间片只有线程优先级比当前线程高或者相等的线程才能获得



```java
public class ThreadYieldTest implements Runnable {

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "开始执行");
        Thread.yield();
        System.out.println(Thread.currentThread().getName() + "执行完毕");
    }

    public static void main(String[] args) {
        ThreadYieldTest threadYieldTest = new ThreadYieldTest();
        new Thread(threadYieldTest, "线程A").start();
        new Thread(threadYieldTest, "线程B").start();
    }

}
```



------

#### 线程的 join



join() 方法让调用该方法的线程“插队”到当前线程之前，只有调用 join() 方法的线程执行完毕之后，当前线程才会继续执行，否则会处于阻塞状态



```java
public class ThreadJoinTest implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println("VIP线程：" + i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        ThreadJoinTest threadJoinTest = new ThreadJoinTest();
        Thread thread = new Thread(threadJoinTest);
        thread.start();

        for (int i = 0; i < 10; i++) {
            if (i == 5) {
                thread.join();
            }
            System.out.println("排队进行中：" + i);
        }
    }

}
```



------

#### 线程的优先级

Java线程可以有优先级的设定，高优先级的线程比低优先级的线程有更高的权重得到执行：

1. 当线程的优先级没有指定时，所有线程都携带普通优先级
2. 优先级可以用从1到10的范围指定。10表示最高优先级，1表示最低优先级，5是普通优先级
3. 优先级最高的线程在执行时被给予优先。但是不能保证线程在启动时就进入运行状态
4. 由调度程序决定哪一个线程被执行
5. 可以使用常量，如MIN_PRIORITY,MAX_PRIORITY，NORM_PRIORITY来设定优先级



```java
public class ThreadPriorityTest implements Runnable {

    int i = 0;

    @Override
    public void run() {
        while (i < 7) {
            System.out.println(Thread.currentThread().getName());
            i++;
            try {
                Thread.yield();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        ThreadPriorityTest priorityTest = new ThreadPriorityTest();
        Thread threadA = new Thread(priorityTest, "线程A");
        threadA.setPriority(1);
        Thread threadB = new Thread(priorityTest, "线程B");
        threadB.setPriority(2);
        Thread threadC = new Thread(priorityTest, "线程C");
        threadC.setPriority(4);
        threadA.start();
        threadB.start();
        threadC.start();
    }

}
```



------

#### 守护线程



线程分为用户线程和守护线程

只要当前 JVM 实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着 JVM 一同结束工作

Daemon 的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)

设置守护线程的方法：thread.setDaemon(true);

查看当前线程是否是守护线程：thread.isDaemon();
