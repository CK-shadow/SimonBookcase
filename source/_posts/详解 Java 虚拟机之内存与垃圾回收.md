---
title: 详解 Java 虚拟机之内存与垃圾回收
date: 2023-05-03 16:25:35
tags: JAVA
categories: 
  - JAVA
top_img: https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/preview.jpg
cover: https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/preview.jpg
---

# 详解 Java 虚拟机之内存与垃圾回收

## 类加载子系统

### 内存结构概述



![image-20230328234157167](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230328234157167.png)





![image-20230328234207110](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230328234207110.png)





------

### 类加载过程



![image-20230328235335033](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230328235335033.png)



1. 加载阶段
   * 通过一个类的全限定名获取定义此类的二进制字节流
   * 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
   * 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口
2. 链接阶段
   * 验证
     * 目的在子确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全
     * 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证
   * 准备
     * 为类变量分配内存并且设置该类变量的默认初始值，即零值
     * 这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，准备阶段会显式初始化
     * 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中
   * 解析
     * 将常量池内的符号引用转换为直接引用的过程
     * 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行
     * 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等
3. 初始化
   * 初始化阶段就是执行类构造器方法 clinit 的过程
   * 此方法不需定义，是 javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来
   * 构造器方法中指令按语句在源文件中出现的顺序执行
   * clinit 不同于类的构造器
   * 若该类具有父类，JVM会保证子类的 clinit 执行前，父类的 clinit 已经执行完毕
   * 虚拟机必须保证一个类的 clinit 方法在多线程下被同步加锁



------

### 类加载器的分类



1. 启动类加载器（Bootstrap ClassLoader）
   * 这个类加载使用 C/C++ 语言实现的，嵌套在 JVM 内部
   * 它用来加载 Java 的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类
   * 并不继承自 java.lang.ClassLoader，没有父加载器
   * 加载扩展类和应用程序类加载器，并指定为他们的父类加载器
   * 出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类
2. 扩展类加载器（Extension ClassLoader）
   * Java语言编写，派生于 ClassLoader 类
   * 父类加载器为启动类加载器
   * 从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载
3. 应用程序类加载器（App ClassLoader）
   * Java语言编写，派生于 ClassLoader 类
   * 父类加载器为扩展类加载器
   * 它负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库
   * 该类加载是程序中默认的类加载器，一般来说，Java 应用的类都是由它来完成加载
4. 用户自定义类加载器
   * 在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式
   * 作用在于隔离加载类、修改类加载的方式、扩展加载源、防止源码泄漏等



------

### ClassLoader 使用说明



ClassLoader 类是一个抽象类，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器）

![image-20230329234815457](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230329234815457.png)



获取 ClassLoader 的方式：

```java
// 方式一：获取当前ClassLoader
clazz.getClassLoader()

// 方式二：获取当前线程上下文的ClassLoader 
Thread.currentThread().getContextClassLoader()

//  方式三：获取系统的ClassLoader 
ClassLoader.getSystemClassLoader()

// 方式四：获取调用者的ClassLoader 
DriverManager.getCallerClassLoader()
```



------

### 双亲委派机制



Java 虚拟机对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式



![image-20230331184136067](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230331184136067.png)

1. 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行
2. 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器
3. 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式



双亲委派机制可以避免类的重复加载，保护程序安全，防止核心API被随意篡改。如果想破坏双亲委派机制，有两种方法，一是自定义类加载，重写 loadclass 方法；二是使用线程上下文类



在 JVM 中表示两个 class 对象是否为同一个类存在两个必要条件：

1. 类的完整类名必须一致，包括包名
2. 加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同



------

## 运行时数据区和程序计数器

### 运行时数据区概述



内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行 JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异

![image-20230331210133270](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230331210133270.png)



通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁

![image-20230331210206407](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230331210206407.png)

其中程序计数器、虚拟机栈和本地方法栈是线程私有的，堆和元数据去是线程共享的



------

### 线程



线程是一个程序里的运行单元。JVM 允许一个应用有多个线程并行的执行。 在 Hotspot JVM 里，每个线程都与操作系统的本地线程直接映射

当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java 线程执行终止后，本地线程也会回收

操作系统负责所有线程的安排调度到任何一个可用的 CPU 上。一旦本地线程初始化成功，它就会调用 Java 线程中的 run() 方法



------

### 程序计数器



JVM 中的程序计数寄存器（Program Counter Register）中，Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的现场信息。CPU 只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为 PC 计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟

PC 寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令

![image-20230401100858195](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230401100858195.png)

它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行 native 方法，则是未指定值（undefined）。它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。它是唯一一个在Java虚拟机规范中没有规定任何 OutofMemoryError 情况的区域



------

## 虚拟机栈

### 概述



由于跨平台性的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的。栈解决程序的运行问题，即程序如何执行，或者说如何处理数据，堆解决的是数据存储的问题，即数据怎么放，放哪里

Java 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用，是线程私有的，生命周期和线程一致

虚拟机栈主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。JVM 直接对 Java 栈的操作只有两个，一是每个方法执行，伴随着进栈（入栈、压栈），二是执行结束后的出栈工作

Java 虚拟机规范允许 Java 栈的大小是动态的或者是固定不变的。如果采用固定大小的 Java 虚拟机栈，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常。如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个  OutOfMemoryError 异常



------

### 栈的存储单位



每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。在这个线程上正在执行的每个方法都各自对应一个栈帧，栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息

JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。执行引擎运行的所有字节码指令只针对当前栈帧进行操作，如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧

![image-20230401191532500](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230401191532500.png)



不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。Java 方法有两种返回函数的方式，一种是正常的函数返回，使用 return 指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出

栈帧中主要包含以下信息：

![image-20230401191614124](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230401191614124.png)

并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表和操作数栈决定的



------

### 局部变量表



局部变量表也被称之为局部变量数组或本地变量表

* 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及 returnAddress 类型

-  由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题 

-  局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的 Code 属性的 maximum local variables 数据项中。在方法运行期间是不会改变局部变量表的大小的。

-  方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减。 

-  局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁



我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用



------

### 操作数栈



每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出的操作数栈，也可以称之为表达式栈

操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈和出栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间



操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值

我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈



------

### 栈顶缓存技术



基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派次数和内存读/写次数

由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 的设计者们提出了栈顶缓存技术，将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率



------

### 动态链接



每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如： invokedynamic 指令

在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在 class 文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用

![image-20230401223954769](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230401223954769.png)



------

## 本地方法接口和本地方法栈

### 本地方法



简单地讲，一个 Native Method 是一个 Java 调用非 Java 代码的接囗。一个 Native Method 是这样一个 Java 方法：该方法的实现由非 Java 语言实现，比如 C。这个特征并非 Java 所特有，很多其它的编程语言都有这一机制

定义一个 native method 时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非 java 语言在外面实现的。本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++ 程序

![image-20230401224411780](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230401224411780.png)



------

### 本地方法栈



Java 虚拟机栈于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用，也是线程私有的

本地方法是使用C语言实现的，它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库

![image-20230401232039440](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230401232039440.png)



当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存

并不是所有的 JVM 都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native方法，也可以无需实现本地方法栈。在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一



------

## 堆

### 概述



一个 JVM 实例只存在一个堆内存，堆也是Java内存管理的核心区域，《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除，堆是GC 执行垃圾回收的重点区域

jdk 7 及之前，堆分为三个部分，新生代、老年代和永久代，jdk 8 之后，分为新生代、老年代和元空间



------

### 新生代和老年代



存储在 JVM 中的 Java 对象可以被划分为两类，一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速，另外一类对象的生命周期却非常长，在某些极端的情况下还能够与 JVM 的生命周期保持一致。Java 堆区进一步细分的话，可以划分为年轻代和老年代，其中年轻代又可以划分为 Eden 空间、Survivor0 空间和 Survivor1 空间

在 HotSpot 中，Eden 空间和另外两个 survivor 空间缺省所占的比例是 8：1：1



------

### 对象分配过程



1. new 的对象先放 Eden 区。此区有大小限制
2. 当 Eden 的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对 Eden 区进行垃圾回收（MinorGC），将 Eden 区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到 Eden 区 
3. 然后将 Eden 中的剩余对象移动到 S0 区
4. 如果再次触发垃圾回收，此时上次幸存下来的放到 S0 区的，如果没有回收，就会放到 S1 区
5. 如果再次经历垃圾回收，此时会重新放回 S0 区，接着再去 S1 区
6. 默认经过 15 次垃圾回收之后仍存活的对象进入老年区，在老年区，相对悠闲。当老年区内存不足时，再次触发 GC：Major GC，进行老年区的内存清理
7. 若老年区执行了 Major GC 之后，发现依然无法进行对象的保存，就会产生 OOM 异常



------

### 垃圾回收的分类



JVM 在进行 GC 时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代

针对 Hotspot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）

- 部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为： 

- - 新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集

- - 老年代收集（Major GC / Old GC）：只是老年代的圾收集。

- - - 目前，只有CMSGC会有单独收集老年代的行为

- - - 注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收

- - 混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。

- - - 目前，只有G1 GC会有这种行为

- 整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集



------

### 分代 GC 的触发条件



* 年轻代GC（Minor GC）触发机制

  * 当年轻代空间不足时，就会触发 MinorGC，这里的年轻代满指的是 Eden 区满，Survivor 满不会引发 GC。（每次Minor GC会清理年轻代的内存） 

  -  因为 Java 对象大多都具备朝生夕灭的特性.，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。

  -  Minor GC 会引发 STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行

* 老年代GC（Major GC / Full GC）触发机制

  * 指发生在老年代的 GC，对象从老年代消失时，我们说 “Major GC” 或 “Full GC” 发生了 

  -  出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程） 

  - 也就是在老年代空间不足时，会先尝试触发 Minor GC。如果之后空间还不足，则触发 Major GC

  -  Major GC 的速度一般会比 Minor GC 慢 10 倍以上，STW 的时间更长 

  -  如果 Major GC 后，内存还不足，就报 OOM 了

* Full GC 触发机制

  * 调用 System.gc() 时，系统建议执行 Full GC，但是不必然执行
  * 老年代空间不足
  * 方法区空间不足
  * 通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存
  * 由 Eden 区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小





------

## 方法区

### 概述



《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于 HotSpotJVM 而言，方法区还有一个别名叫做 Non-Heap（非堆），目的就是要和堆分开。所以，方法区看作是一块独立于 Java 堆的内存空间

在 jdk7 及以前，习惯上把方法区，称为永久代。jdk8 开始，使用元空间取代了永久代。在 jdk7 及以前，习惯上把方法区，称为永久代。jdk8 开始，使用元空间取代了永久代

元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存



------

### 方法区内部结构



![image-20230402160303187](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230402160303187.png)



《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等



------

### 方法区的垃圾回收



有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK11 时期的 zGC 收集器就不支持类卸载）

一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前 sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存泄漏

方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型

HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收



------

## 对象实例化及直接内存

### 创建对象的方式



- new：最常见的方式、Xxx 的静态方法，XxxBuilder/XxxFactory 的静态方法

- Class 的 newInstance 方法：反射的方式，只能调用空参的构造器，权限必须是 public

- Constructor 的 newInstance(XXX)：反射的方式，可以调用空参、带参的构造器，权限没有要求

- 使用 clone()：不调用任何的构造器，要求当前的类需要实现 Cloneable 接口，实现 clone()

- 使用序列化：从文件中、从网络中获取一个对象的二进制流

- 第三方库 Objenesis



------

### 创建对象的步骤



![image-20230402161543887](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230402161543887.png)



------

### 对象内存布局



![image-20230402161716088](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230402161716088.png)



------

## 执行引擎

### 概述



执行引擎属于 JVM 的下层，里面包括解释器、及时编译器、垃圾回收器



![image-20230402224343207](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230402224343207.png)



执行引擎是 Java 虚拟机核心的组成部分之一

“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式

JVM 的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被 JVM 所识别的字节码指令、符号表，以及其他辅助信息



------

### 解释器



JVM 设计者们的初衷仅仅只是单纯地为了满足 Java 程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法

解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。当一条字节码指令被解释执行完成后，接着再根据 PC 寄存器中记录的下一条需要被执行的字节码指令执行解释操作



在 Java 的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能

在 HotSpot JVM 中，解释器主要由 Interpreter 模块和 Code 模块构成。Interpreter 模块实现了解释器的核心功能，Code模块用于管理 HotSpot JVM 在运行时生成的本地机器指令



由于解释器在设计和实现上非常简单，因此除了 Java 语言之外，还有许多高级语言同样也是基于解释器执行的，比如 Python、Perl、Ruby 等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些 C/C++ 程序员所调侃。为了解决这个问题，JVM 平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升



------

### JIT 编译器



Java 代码的执行分为两类，第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行 ，第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行 

HotSpot VM 是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在 Java 虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间

当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率



------

### 热点代码探测技术



是否需要启动 JIT 编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码，也被称之为“热点代码”，JIT 编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升 Java 程序的执行性能

一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过 JIT 编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为 OSR（On Stack Replacement）编译

一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准，必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能

目前 HotSpot VM 所采用的热点探测方式是基于计数器的热点探测。采用基于计数器的热点探测，HotSpot VM 将会为每一个方法都建立 2 个不同类型的计数器，分别为方法调用计数器和回边计数器。方法调用计数器用于统计方法的调用次数，回边计数器则用于统计循环体执行的循环次数



方法计数器用于统计方法被调用的次数，它的默认阀值在 Client 模式下是 1500 次，在 Server 模式下是 10000 次。超过这个阈值，就会触发 JIT 编译。这个阀值可以通过虚拟机参数  -XX:CompileThreshold 来人为设定

当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加 1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求

![image-20230406235706856](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230406235706856.png)



回边计数器作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发 OSR 编译

![image-20230406235740736](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230406235740736.png)



------

## 垃圾回收概述及算法

### 对象存活判断



判断对象存活一般有两种方式：引用计数算法和可达性分析算法



引用计数算法比较简单，对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，即表示对象 A 不可能再被使用，可进行回收

优点是实现简单，垃圾对象便于辨识，判定效率高，回收没有延迟性。缺点是需要计数器，增加了空间和时间的开销，也无法解决循环引用的问题。正因为如此，Java 的垃圾回收器中没有使用这类算法



可达性分析算法又叫根搜索算法、追踪性垃圾收集

可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）。如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象

根节点包括虚拟机栈中引用的对象、本地方法栈内JNI（通常说的本地方法）引用的对象、方法区中类静态属性引用的对象 、方法区中常量引用的对象 、所有被同步锁 synchronized 持有的对象、Java 虚拟机内部的引用、反映 java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等

如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。这点也是导致 GC 进行时必须 “stop The World” 的一个重要原因。即使是号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的



------

### 对象的 finalize 机制



Java 语言提供了对象终止机制来允许开发人员提供对象被销毁之前的自定义处理逻辑，当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 finalize() 方法。finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等



虚拟机中的对象可能的三种状态：

* 可触及的：从根节点开始，可以到达这个对象
* 可复活的：对象的所有引用都被释放，但是对象有可能在 finalize() 中复活
* 不可触及的：对象的 finalize() 被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为 finalize() 只会被调用一次



判定一个对象 objA 是否可回收，至少要经历两次标记过程：

1. 如果对象 objA 到 GC Roots 没有引用链，则进行第一次标记
2. 进行筛选，判断此对象是否有必要执行 finalize() 方法
3. 如果对象 objA 没有重写 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA 被判定为不可触及的
4. 如果对象 objA 重写了 finalize() 方法，且还未执行过，那么 objA 会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其finalize() 方法执行
5. finalize() 方法是对象逃脱死亡的最后机会，稍后 GC 会对 F-Queue 队列中的对象进行第二次标记。如果 objA 在 finalize() 方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA 会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的 finalize 方法只会被调用一次



------

### 垃圾收集算法



目前在 JVM 中比较常见的三种垃圾收集算法是标记一清除算法、复制算法、标记-压缩算法



标记-清除算法是一种非常基础和常见的垃圾收集算法，当堆中的有效内存空间被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除

标记阶段从引用根节点开始遍历，标记所有被引用的对象，清除阶段对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收。这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址

这种算法的缺点在于效率一般，GC 的时候需要 STW，并且容易产生内存碎片



复制算法将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收

优点在于实现简单，运行高效，并且不会产生内存碎片。缺点在于需要两倍的内存空间



标记-压缩算法第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象，第二阶段将所有的存活对象压缩到内存的一端，按顺序排放，之后，清理边界外所有的空间。标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩算法

标记压缩算法的效率低于标记清楚算法和复制算法，但是不会产生内存碎片，也不需要两倍的内存空间



前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生

分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。目前几乎所有的 GC 都采用分代收集算法执行垃圾回收的

年轻代特点是区域相对老年代较小，对象生命周期短、存活率低，回收频繁，因此采用复制算法。老年代特点是区域较大，对象生命周期长、存活率高，回收不及年轻代频繁，一般采用标记清楚或标记整理算法



------

## 垃圾回收相关概念

### 内存溢出和内存泄漏



由于 GC 一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现 OOM 的情况

javadoc 中对 OutOfMemoryError 的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存



只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄漏



------

### Stop The World



Stop-the-World，简称 STW，指的是 GC 事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为 STW

可达性分析算法中枚举根节点会导致所有 Java 执行线程停顿

被 STW 中断的应用程序线程会在完成 GC 之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少 STW 的发生，STW 事件和采用哪款 GC 无关，所有的 GC 都有这个事件



------

### 安全点与安全区域



程序执行时并非在所有地方都能停顿下来开始 GC，只有在特定的位置才能停顿下来开始 GC，这些位置称为安全点（Safepoint）

Safe Point 的选择很重要，如果太少可能导致 GC 等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为 Safe Point，如方法调用、循环跳转和异常跳转等

让线程都中断下来，现在的 JVM 使用的都是主动式中断，设置一个中断标志，各个线程运行到 Safe Point 的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）



Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safepoint。但是，程序“不执行”的时候呢？例如线程处于 Sleep 状态或 Blocked 状态，这时候线程无法响应 JVM 的中断请求，“走”到安全点去中断挂起，JVM 也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决

安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始 GC 都是安全的。我们也可以把 Safe Region 看做是被扩展了的 Safepoint

当线程运行到 Safe Region 的代码时，首先标识已经进入了 Safe Relgion，如果这段时间内发生 GC，JVM 会忽略标识为 Safe Region 状态的线程。当线程即将离开 Safe Region 时，会检查 JVM 是否已经完成 GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开 Safe Region 的信号为止



------

### 引用的分类



- 强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似 Object obj = new Object() 这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象

- 软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常

- 弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象

- 虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知



------

## 垃圾回收器

### 垃圾回收器的分类



按线程数分，可以分为串行垃圾回收器和并行垃圾回收器

按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器

按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器

按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器



------

### CMS 收集器



在 JDK1.5 时期，Hotspot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作

CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验

CMS 的垃圾收集算法采用标记-清除算法，并且也会"Stop-the-World"



![image-20230408230516408](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/JAVA/%E8%AF%A6%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20230408230516408.png)



CMS整个过程比之前的收集器要复杂，整个过程分为 4 个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段：

1. 初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为 “Stop-the-World” 机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出 GCRoots 能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快
2. 并发标记（Concurrent-Mark）阶段：从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行
3. 重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短
4. 并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的



由于在垃圾收集阶段用户线程没有中断，所以在 CMS 回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次 “Concurrent Mode Failure”  失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了

CMS 收集器的垃圾收集算法采用的是标记清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配



------

### G1 收集器



G1 GC 有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给 G1 一个名字：垃圾优先（Garbage First）

在 JDK1.7 版本正式启用，移除了 Experimenta1 的标识，是 JDK9 以后的默认垃圾回收器，取代了 CMS 回收器以及 Parallel+Parallel Old 组合。被 Oracle 官方称为“全功能的垃圾收集器”
