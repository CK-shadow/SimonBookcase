---
title: 秒杀系统的架构与设计
date: 2024-06-15 09:37:58
tags: 系统架构
categories: 系统架构
top_img: https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/preview.jpg
cover: https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/preview.jpg
---

# 秒杀系统的架构与设计

## 目标与挑战

### 秒杀系统的目标与挑战



对于 C 端用户来说，最重要的目标就是页面流畅不卡顿，不出现白屏，接口要稳定，数据要准确

对于 B 端用户来说，最重要的目标就是数据准确，资金安全，价格隔离和渠道隔离

对于平台来说，最重要的目标就是保证 B 端和 C 端目标落地，并做到业务隔离和数据隔离



秒杀系统面临的挑战有

* 巨大的瞬时流量
* 热点数据，可能达到几十万甚至上百万，Redis 都扛不住
* 库存超卖
* 恶意刷单流量



------

### 秒杀系统大流量的应对之道



**分离之道**

* 资源分离，主要是前后端资源分离，前端资源可以通过 CDN 加速
* 接口分离，秒杀接口与其它接口分离，高频访问接口与低频访问接口分离
* 数据分离，秒杀数据与其它数据分离，动态数据与静态数据分离
* 业务分离，秒杀业务与其它业务进行分离
* 系统分离，在系统分离层面，一般会将详情页系统、结算页系统、购物车系统和订单系统系统进行分离，并且会申请单独的域名和负载均衡器等，并会对相应的微服务集群进行分组隔离
* 流量分离，秒杀系统与其它系统的流量进行分离



**限流之道**

* 提前预约秒杀，通过将抢购的用户控制在预约人数之中，在一定程度上大大减少秒杀的峰值流量，对秒杀系统起到一定的防护作用
* 打散客户流量，通过设置答题、验证码和滑块等方式，根据用户操作速度不同，将大并发流量分散到一小段时间内，也能起到一定的防刷保护作用
* 消息队列，使用消息队列进行削峰
* 网关限流
* API 限流
* 应用层限流，通过设置最大线程数等方式来实现限流
* 安全校验，对黄牛、刷单的恶意请求进行拦截
* 像一些大型互联网公司，为了兼得用户体验和系统资源，不会间的的使用答题、验证码等方式打散客户流量，更倾向于采用非公平的策略，使用有损逐级限流和分层过滤的方式来达到限流目的



**快速响应之道**

* 多用缓存，包括但不限于本地缓存和分布式缓存
* 数据和计算尽量少
* 流程尽量简单



**准确一致之道**

* 缓存与数据库数据一致
* 本地缓存与分布式缓存一致
* 商品库存与订单数据一致
* 前后端数据一致



**全链路压测之道**



------

## 需求梳理

### 系统需求



![image-20240602234811036](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240602234811036.png)



用户角度的需求

![image-20240602234913877](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240602234913877.png)



运营角度的需求

![image-20240602234922066](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240602234922066.png)



业务流程

![image-20240602234933548](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240602234933548.png)



------

### 流程梳理



在用户访问秒杀系统时，请求流量首先会通过 DNS 将域名解析成 IP 地址，通过 IP 地址访问到服务器。进入 Nginx，由 Nginx 进行一系列的负载均衡和限流等功能，到达系统的业务网关，通过业务网关进行路由、限充、服务降级以及风控等，进入到 Web 服务，Web 服务会对外提供交互接口，解析接收的请求数据，以及聚合查询的数据等。随后进入到基础服务，基础服务的功能比较单一和灵活，基本都是一些简单的业务处理。最后会进入数据服务层，数据服务主要就是存储、操作和查询数据，可以包含 Redis、MySQL 和其他数据服务

![image-20240602235029370](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240602235029370.png)



![image-20240602235037169](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240602235037169.png)



对于秒杀系统这种瞬时高并发大流量的系统来说，可以将一些校验操作前置化，采用分层过滤的原则来控制流量最终充入系统的大小。并且使用分层过滤的原则和设计可以对流量做精细化筛选，尽量保证流入到下游系统的流量，都是优质的系统流量，分层过滤的漏洞槿型可以设计成如图所示

![image-20240602235044169](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240602235044169.png)



------

## 架构设计

### 系统架构设计



**技术选型**

开发框架：SpringBoot、SpringCloud、SpringCloud Alibaba、Dubbo

缓存：Redis + Guava

数据库：MySQL

流量网关：OpenResty + Lua

业务网关：SpringCloud Gateway

持久层框架：MyBatis

服务配置与注册发现：Nacos

单机异步：Cola

分布式事务：Hmily、Seata、RocketMQ

分库分表：ShardingSphere

日志：ELK（Elasticsearch、Logstash、Kibana）

链路追踪：Sleuth、Zipkin、Prometheus

容器：Docker

容器化管理：Swarm、Portainer

监控：Prometheus、Grafana

系统限流：OpenResty + Lua、Sentinel

消息中间件：RocketMQ

单元测试：Junit

压测工具：JMeter





**一般系统架构设计**

![image-20240602235147462](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240602235147462.png)

这种系统架构在一般系统中没什么问题，但是放在秒杀系统中，则会存在很多问题

一个是 Web 服务器的性能问题，Nginx 只做了反向代理和负载均衡的功能，绝大部分的流量仍旧会打在 Web 服务器上。Tomcat 是通过线程池来处理请求的，如此多的请求，如果 Tomcat 线程池的等待队列被占满后，不仅会影响性能，还会使大量的请求被拒绝

另一个是静态资源的加载问题，静态资源无论是放在 CDN 还是放在 Web 服务器，都会影响加载速度且占用大量带宽



**秒杀系统的总体架构设计**

![image-20240602235156731](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240602235156731.png)

针对于一般系统的两个问题，秒杀系统架构做了两点优化

一是将静态资源放在了 CDN，提升了加载速度。另一个是放大 Nginx 的职责，减少落在 Web 服务器上的请求流量。除了在 Nginx 层进行限流，Web 服务器也可以进行限流、降级等流量管控措施，避免大量请求冲垮服务器



**秒杀系统的容器化架构设计**

![image-20240602235204572](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240602235204572.png)



**DDD 分层业务架构设计**

![image-20240602235231495](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240602235231495.png)

展示层：也叫用户 UI 层，是 DDD 设计的最上层，对外提供 API 接口，接收客户端请求，解析参数，返回结果数据，并对异常进行处理

应用层：也叫 Application 层，应用层主要处理容易变化的业务场景，可对相关的事件、调度和其它聚合操作进行相关的操作

领域层：也叫 Domain 层，可以说是 DDD 设计的精髓所在，将业务系统中相对不变的部分抽象出来封装成领域模型

基础设施层：也叫 Infrastructure 层，基础设施层会对其他各层提供通用的基础能力



------

### 数据模型设计



对于用户数据模型来说，简化后的字段模型包括：用户 ID、用户名、密码和状态，整体如下

| 字段名称  | 类型    | 长度 | 默认值   | 说明                     |
| --------- | ------- | ---- | -------- | ------------------------ |
| id        | bigint  | 20   | 无       | 用户 ID                  |
| user_name | varchar | 20   | 空字符串 | 用户名                   |
| password  | varchar | 64   | 空字符串 | 密码                     |
| status    | int     | 2    | 1        | 用户状态：1 正常、2 冻结 |



对于秒杀活动来说，简化后的字段模型包括：活动 ID、活动名称、开始时间、结束时间、状态、描述，整体如下

| 字段名称      | 类型     | 长度 | 默认值   | 说明                               |
| ------------- | -------- | ---- | -------- | ---------------------------------- |
| id            | bigint   | 20   | 无       | 活动 ID                            |
| activity_name | varchar  | 128  | 空字符串 | 活动名称                           |
| start_time    | datetime | 默认 | NULL     | 开始时间                           |
| end_time      | datetime | 默认 | NULL     | 结束时间                           |
| status        | int      | 2    | 0        | 状态：0 已发布、1 已上线、2 已下线 |
| activity_desc | varchar  | 255  | 空字符串 | 活动描述                           |



对于秒杀商品来说，简化后的字段模型包括：商品 ID、商品名称、活动 ID、开始时间、结束时间、活动原价格、商品秒杀价格、商品初始库存、商品当前可用库存、商品描述、商品图片、商品状态和限购个数，整体如下

| 字段名称        | 类型     | 长度 | 默认值   | 说明             |
| --------------- | -------- | ---- | -------- | ---------------- |
| id              | bigint   | 20   | 无       | 商品 ID          |
| goods_name      | varchar  | 128  | 空字符串 | 商品名称         |
| activity_id     | bigint   | 20   | 0        | 活动 ID          |
| start_time      | datetime | 默认 | NULL     | 开始时间         |
| end_time        | datetime | 默认 | NULL     | 结束时间         |
| original_price  | decimal  | 10,2 | 0.00     | 活动原价格       |
| activity_price  | decimal  | 10,2 | 0.00     | 活动秒杀价格     |
| initial_stock   | int      | 10   | 0        | 商品初始库存     |
| available_stock | int      | 10   | 0        | 商品当前可用库存 |
| description     | varchar  | 255  | 空字符串 | 商品描述         |
| img_url         | varchar  | 100  | 空字符串 | 商品图片         |
| status          | int      | 2    | 0        | 商品状态         |
| limit_num       | int      | 11   | 1        | 限购个数         |



对于秒杀订单来说，简化后的字段模型包括：订单 ID、用户 ID、商品 ID、商品名称、秒杀价格、下单商品数量、订单总金额、活动 ID、订单状态和创建时间，整体如下

| 字段名称       | 类型     | 长度 | 默认值   | 说明         |
| -------------- | -------- | ---- | -------- | ------------ |
| id             | bigint   | 20   | 无       | 订单 ID      |
| user_id        | bigint   | 20   | 0        | 用户 ID      |
| goods_id       | bigint   | 20   | 0        | 商品 ID      |
| goods_name     | varchar  | 128  | 空字符串 | 商品名称     |
| activity_price | decimal  | 10,2 | 0.00     | 秒杀价格     |
| quantity       | int      | 10   | 0        | 下单商品数量 |
| order_price    | decimai  | 10,2 | 0.00     | 订单总金额   |
| activity_id    | bigint   | 20   | 0        | 活动 ID      |
| status         | int      | 2    | 0        | 订单状态     |
| create_time    | datetime | 默认 | NULL     | 创建时间     |



------

## 项目搭建



基于 DDD 架构设计搭建项目，总体结构与工程依赖关系如下：

![image-20240606235814366](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240606235814366.png)

![image-20240606235819184](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240606235819184.png)



------

## 常规系统设计

### 用户部分



使用 JWT 进行用户的登录授权认证

![image-20240607000429188](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240607000429188.png)



------

### 活动部分





![image-20240608233955633](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240608233955633.png)

![image-20240608234006652](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240608234006652.png)



------

### 商品部分



![image-20240608234549880](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240608234549880.png)

![image-20240608234555462](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240608234555462.png)



------

### 订单部分



![image-20240608234718379](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240608234718379.png)

![image-20240608234722519](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240608234722519.png)



------

## 常规系统经典问题



![image-20240608235523118](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240608235523118.png)



------

## 混合型缓存

### 作用



良好的缓存设计不仅能提升系统的总体性能，还能作为抗瞬时流量洪峰的有效防线



![image-20240609235115089](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240609235115089.png)



经过前置的流量管控、流量清洗和限流等措施的第一道防线，本地缓存的第二道防线，分布式缓存的第三道防线，真正进入数据库的流量就会比较小了



------

### 读取缓存流程



![image-20240609235311065](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240609235311065.png)



------

### 技术选型



![image-20240609235821743](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240609235821743.png)



------

## 缓存领域事件



对活动和商品数据整合缓存后，就面临一个比较棘手的问题，那就是数据一致性的问题，最直接的就是缓存数据与数居库数据一致性的问题，将活动和商品数据整合缓存后，当运营端发布了活动或者商品，或者对活动或者商品的状态进行了变更，如果缓存中的数据未发生变化，那么客户端获取活动或者商品数据时，就会获取到脏数据

很容易想到的一种方案就是:在运营管理端发布活动或者商品，或者变更活动或者商品的状态时，同步缓存数据。但是这种方案会增加数据操作失败的风险。还有一种方案就是在运营管理端对活动和商品进行管理时，同步清除爱存中的数据，这种方案在流量比较小的系统中是可行的，如果放到类似秒杀系统这种高并发、大流量的场景中，直接清除缓存中的数据，如果对流量控制不佳，很有可能使大量的流量瞬间打入数据库而导致数据库宕机崩溃



当活动和商品数据整合缓存后，在运营管理端对活动和商品进行管理时，可以对外发布一个事件，发布事件后即可不再关注处理事件的细节，类似于生产者-消费者模式，生产者生产消息，将消息发布到对应的消息队列或者消息中间而不必关注消费者是如何从消息队列或者消息中间件中获取数据并消费

当在运营管理端对活动和商品进行管理时，执行完操作数据库的业务逻辑后，对外发布一个事件，方法即可结束。而在系统的其他领域层，会监听对应的事件，当接收到对应的事件后，更新缓存中的数据



在秒杀系统中，针对秒杀系统中缓存数据的变更，领域事件发布的流程如图所示

![image-20240614232343369](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240614232343369.png)



------

## 库存扣减

### 常见的库存扣减方式



**下单减库存**

下单扣减库存的方式比较容易理解，就是用户提交订单后，在商品的总库存中减去用户购买的商品数量。这种减库存方式是最简单的，也是将商品库存统计得最准确的。但是经常会碰到用户提交订单下付款的问题

这就会存在一个问题:恶意刷单。例如，用户 A 作为商家参与了某平台的“双11”秒杀活动，该平台扣减库存的方式为单减库存，如果用户A的竞争对手通过恶意下单的方式将用户 A 参与秒杀的商品全部下单，让用户 A 的商品库存减为 0,旦是并不付款，那么用户 A 参与“双11”秒杀的商品就不能正常售卖这就是下单减库存存在的问题



**付款减库存**

既然下单减库存存在问题，那么再来分析一下付款减库存。库存减库存就是在用户提交订单后，并不会立刻扣减商品的库存，而是等到用户真正付款后才会扣减库存。这种方式会经常遇到用户明明下单成功了，却提示不能付款的问其原因就是当某个用户下单后，执行付款操作时，相应的商品可能已经被其他人买走了

付款减库存有可能造成另一个更为严重的后果:库存超卖。因为在用户提交订单时，系统不会扣减库存，所以最终用户成功下单的订单数量可能远远大于商品的库存数量



**预扣减库存**

预扣减库存比前面两种方式复杂一些。用户提交订单后，为用户预留购买数量的商品库存，例如预留 10 min，一旦超过 10 min 就释放为用户预留的库存，其他的用户可以继续下单购买。用户下单预扣减库存之后，在付款时，系统会检验对立的订单是否存在有效的预留库存，如果存在，则真正扣减库存并付款。如果不存在，则再次尝试预扣减库存。如果库存呢不足，则不再付款。如果预扣减库存成功，则真正扣减库存并付款

但是，预扣减库存并没有完全解决下单减库存和付款减库存两种方式中的问题

例如，对恶意下单来说，虽然将有效的付款时间控制在一小段时间内，但是恶意用户完全有可能在一段时间后再次下单。也有可能在开始下单时，一次性选择所有的库存下单。仍然不能彻底解决问题



------

### 扣减库存的解决方案



秒杀系统中的主要问题是恶意下单和库存超卖，以下方案可以在一定程度上解决恶意下单问题：

1. 为经常提交订单却不付款的用户添加对应的标签，当这些用户下单时，进行特殊处理，例如不扣减库存等(具体可以根据需求确定)
2. 在秒杀活动期间，为商品设置同一个人的最多购买件数，比如最多购买 2 件。维度可以是单一用户ID、同一手机、同一收件地址、同一设备 IP 等
3. 对秒杀商品进行限制，例如在北京、上海、广州、深圳这些一线城市投放，那么就只有收货地址是这些城市的用才能参与抢购，而且各地区库存量是隔离的，互不影响
4. 对不付款重复下单的操作进行限制，例如，对同一商品下单时，首先校验当前用户是否存在未付款的订单，如果存在则提示用户付款后再提交新订单



通过前面对三种扣减库存方式的介绍，也许有不少人会认为高并发秒杀系统会采用预扣减库存的方式，其实，在真正的高并发、大流量场景下，大部分秒杀系统会采用下单减库存的方式。在下单扣减库存的业务场景中，需要保证高并发、大流量下商品的库存不能被扣减至负数

1. 扣减库存时，只有商品剩余库存数量大于用户购买数量时，才扣减库存，否则提示库存不足
2. 扣减库存后，在应用程序的事务中判断商品库存是否为负，如果是，则回滚事务不再扣减库存
3. 在数据库中设置库存字段为无符号整数，从数据库层面保证无法出现负数的情况



------

### 基于数据库实现库存扣减



基于数据库实现库存扣减的核心在于一条 SQL 语句，通过 SQL 的执行条件和设置库存字段不小于 0 来保证库存扣减的安全

```SQL
update secki1l_goods set available_stock = available_stock - #{count} where id = #{id} and available_stock >= #{count}
```



这种实现方式最为简单，无需额外中间件，安全性也很有保障。缺点在于每次库存扣减都需要执行数据库写操作，并且在库存扣减完成之后，每次下单仍需要执行 DB SQL，对于数据库而言具有很大的压力。适用于并发量不大，库存扣减速度比较平缓的场景



------

### 基于分布式锁实现库存扣减



![image-20240615170730719](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240615170730719.png)



使用 Redis 分布式锁来实现库存扣减过程中的数据安全，并将库存数据放到 Redis 中，可以将数据库读写的压力转到 Redis 上，性能更好

但是这样锁的粒度较大，并不能完全发挥服务性能，并且如果在执行过程中服务器宕机，没能及时释放锁，即使设置了锁的超时时间，也会导致在一段时间内用户无法下单



------

### 基于 Lua 脚本实现库存扣减



使用 Lua 脚本扣减库存，利用的是 Redis 的单线程特性，在同一时间内只会有一个 Lua 脚本在执行，并且将 Lua 脚本内的所有操作视为一个原子操作，不会有并发数据问题，从而替代分布式锁，减少锁粒度，提升性能



```LUA
-- lua逻辑：首先判断活动库存是否存在，如果库存不存在则返回-1，接下来判断传入的要扣减的库存是否大于0，如果要扣减的库存不大于0，则返回-2，库存不足返回-3，扣减库存成功返回1
-- 两个入参：
-- KEYS[1] : 活动库存的key
-- ARGV[1] : 活动库存的扣减数量
local stock = redis.call('get', KEYS[1])

-- 商品库存不存在
if not stock then
    return -1
end

-- 获取Redis库存和扣减的库存数量
local intStock = tonumber(stock)
local paramStock = tonumber(ARGV[1])

-- 参数不能小于或者等于0
if paramStock <= 0 then
    return -2
end

-- 库存不足
if intStock < paramStock then
    return -3
end

-- 正常扣减库存
redis.call('decrby',KEYS[1], paramStock)

return 1
```



------

## 分库分表

### 分库分表设计



对商品库存进行分库分表设计时，一个很重要的设计就是对分片键的设计。所谓的分片键就是指定一个字段，通过这个字段将数据路由到对应的数据库和数据表中。在秒杀系统分片键的设计上，尽量将同一个用户的同一次事务中的相关操作路由到同一个数据库中，降低跨库操作的事务成本



![image-20240615224649905](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240615224649905.png)



可以看到，对于商品商品库存来说，分库分表后，会分成一个商品库和两个库存库，其中商品库中存放的是秒杀商品信息，主要在用户抢购下单的业务场景中，以读操作为主。库存库中则存放的是库存分桶数据，每个库存库中存放了个分桶后的库存信息。这些分库分表的数据，大家可以根据实际重要灵活调整

对于商品库存的分库分表来说，在实际场景下，可以根据商品 id 进行分片。也就是说，这里我们选择的分片键是商品的，同一个商品的库存会被路由到同一个数据库中，不会出现跨数据库的操作



------

### 分桶设计



在分库分表的基础上，为了进一步提升数据库的并发写性能，可以对商品的库存进行分桶存储。当运营人员在配置库存信息时，可以设置库存的总量和分桶数量，比如，要将 1500 个商品分配到 5 个分桶中，则每个分桶中会分得 300 个商品库存

![image-20240616120057960](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240616120057960.png)

这样，每个分桶就能够承担一部分写压力，从而将商品的库存写压力分担出去，使得秒杀系统的库存数据库能够具备更高的并发写能力

当用户抢购下单时，会根据分桶的数量对用户的 id 进行取模来定位对应的库存分桶，比如用户的 id 为 10001，目前库存的分桶数量设置为 5，则用户抢购下单时，会将当前用户抢购下单时，扣减商品库存的请求路由到分桶 1



每个分桶中保存的是当前商品的一部分库存信息，那如何确定主商品的总库存

* 第一个方案就是在多个分桶中选择一个主分桶用来存储商品的总库存
* 第二个方案就是在商品数据表中存储商品的总库存和分桶数量，每个分桶中存储当前分桶的商品总库存和当前可用库存

考虑到对商品库存的并发写操作，以及后续运营人员可能要调整商品的库存信息，采用方案二也就是在商品数据表中存储商品总库存和分桶数量，每个分桶中存储当前分桶的商品总库存和当前可用库存



------

### 分桶库存扣减策略



id 为 10001 的用户抢购下单时会被路由到分桶 1，id 为 10002 的用户抢购下单时，会被路由到分桶 2。有可能存在的一种情况是:此时分桶 1 中没有库存了，分桶 2 中有库存，那对于 id 为 10001 的用户来说，该怎么处理呢。此时，可以考虑三种方案：

1. 设计库存分桶的争抢机制，类似 Java 中的 Fork/Join 框架，如果当前分桶中的库存不足，则按照一定的规则争抢其他分桶中的库存
2. 每个分桶中预留一些冗余的库存，某个分桶库存不足，向其他分桶借用
3.  路由到不同库存分桶的用户看到的剩余库存量不同，如果某个分桶的库存不足，直接向路由到该分桶的用户提示库存不足



方案 1 和方案 2 在实现上比较复杂，要充分考虑在高并发、大流量场景下如何实现库存的争抢机制，并要考虑不能出现库存超卖和少卖的问题，无疑是在系统的架构设计和实现层面增加了复杂度。在这种秒杀场景下，大可不必非要实现方案 1 和方案 2，换个角度思考，对于平台和商户来说，保证所有商品都能售罄，并保证数据一致。对于用户来说，完全必要保证库存数据的强一致性，只要保证用户能看到对应分桶中的库存就可以了，完全没必要保证用户看到库存数据的强一致性



------

## 防刷方案

### 基于条件的防刷限流



基于条件限流防刷。主要基于条件来实现接口的访问频率，例如请求中携带 Token 来进行校验，以此来达到接口防刷的目的，重点掌握基于条件防刷的实现原理与落地实现方案，并能够将其灵活立用到自身实际项目中



------

### 基于 Token 编排机制的防刷限流



![image-20240616154518650](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240616154518650.png)



可以看到，访问下一个接口时，会在 header 中带上一个接口的 header 里返回的 x-st-token，下一个接口会对 x-sttoken 进行校验，如果校验成功，则执行后续业务逻辑，并返回结果。如果校验失败，则直接返回错误信息

这里每一个接口的 header 里返回的 x-st-token 都不同，下一个接口对上一个接口返回的 x-st-token 进行严格校验，如果校验失败，直接返回错误信息，只有校验成功，才会执行接口业务逻辑，以此达到接口编排的效果



------

### 基于黑名单的防刷限流



主要就是利用 Lua 共享缓存功能，去统计一段时间窗口内某个用户或者 IP 的请求频率，如果请求的频率达到设定的阈值，就可以认为这是刷单流量，将其放入黑名单。被放入黑名单的用户或者 IP 访问接口时，会被拦截

黑名单功能可以被所有的接口共享，一旦某个用户或者 IP 被拉进黑名单，这个用户或者IP访问所有接口时，都会被拦截，这样，就能够将刷单流量挡在秒杀系统之外



![image-20240616154815325](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240616154815325.png)



------

## 风控系统



一上来就设计和实现一个非常完善的风控系统是不可能的。在设计和实现风控规则时，我们要做到高度可扩展可编排和可配置，随时可以扩展其他的风控规则，也能够随时对这些风控规则进行编排，同时，能够随时配置风控的是具体规则

当请求进入业务网关时，会触发风控规则，此时会执行风控链中的校验规则，只有经过所有过滤器链的校验之后，请求才会被业务网关路由到正确的服务上执行后续业务逻辑



![image-20240616175748831](https://simon-bookcase.oss-cn-beijing.aliyuncs.com/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/image-20240616175748831.png)

可以看到，用户在访问秒杀系统时，请求会首先到达流量网关，经过流量网关的流控、限流、防刷和黑白名单等校验，到达业务网关。在业务网关会经过多重风控校验和鉴权校验。而在多重风控校验设计中，会提供风控扩展点接口，后续要新增风控规则时，只需要新建一个扩展点实现类，实现风控扩展点接口即可，并且可以对这些具体的风控逻辑进行编排，使其按照自己想要的顺序执行完全做到可配置和可编排

实现了风控可扩展点接口的具体实现类，就是风控要执行的具体逻辑了，在执行风控逻辑时，会以责任链模式以此执行风控可扩展接口实现类中的逻辑，例如:账户风控、IP 风控、设备风控、防攻击风控、自定义风控、其他风控等等。只有通过所有风控逻辑的校验之后，接下来就是对请求进行鉴权校验，通过鉴权校验的请求才会被业务网关路由到目标微服务执行具体业务逻辑

